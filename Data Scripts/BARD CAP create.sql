--
-- ER/Studio Data Architect 9.1 SQL Code Generation
-- Project :      CAP and Data entry.DM1
--
-- Date Created : Wednesday, May 15, 2013 18:19:59
-- Target DBMS : Oracle 11g
--

DROP VIEW ASSAY_ELEMENT
;
DROP VIEW BIOLOGY_ELEMENT
;
DROP VIEW INSTANCE_ELEMENT
;
DROP VIEW LABORATORY_ELEMENT
;
DROP VIEW RESULT_TYPE_ELEMENT
;
DROP VIEW STAGE_ELEMENT
;
DROP VIEW UNIT_ELEMENT
;
DROP TABLE ASSAY CASCADE CONSTRAINTS
;
DROP TABLE Assay_Context CASCADE CONSTRAINTS
;
DROP TABLE Assay_Context_Item CASCADE CONSTRAINTS
;
DROP TABLE ASSAY_CONTEXT_MEASURE CASCADE CONSTRAINTS
;
DROP TABLE Assay_Descriptor_Tree CASCADE CONSTRAINTS
;
DROP TABLE ASSAY_DOCUMENT CASCADE CONSTRAINTS
;
DROP TABLE AUDIT_COLUMN_LOG CASCADE CONSTRAINTS
;
DROP TABLE AUDIT_ROW_LOG CASCADE CONSTRAINTS
;
DROP TABLE AUDIT_SETTING CASCADE CONSTRAINTS
;
DROP TABLE BARD_TREE CASCADE CONSTRAINTS
;
DROP TABLE Biology_Descriptor_tree CASCADE CONSTRAINTS
;
DROP TABLE CONFIDENCE_LEVEL_FACTOR CASCADE CONSTRAINTS
;
DROP TABLE CONFIDENCE_LEVEL_SCORE CASCADE CONSTRAINTS
;
DROP TABLE DICTIONARY_TREE CASCADE CONSTRAINTS
;
DROP TABLE ELEMENT CASCADE CONSTRAINTS
;
DROP TABLE ELEMENT_HIERARCHY CASCADE CONSTRAINTS
;
DROP TABLE ERROR_LOG CASCADE CONSTRAINTS
;
DROP TABLE EXPERIMENT CASCADE CONSTRAINTS
;
DROP TABLE EXPERIMENT_FILE CASCADE CONSTRAINTS
;
DROP TABLE EXPRMT_CONTEXT CASCADE CONSTRAINTS
;
DROP TABLE EXPRMT_CONTEXT_ITEM CASCADE CONSTRAINTS
;
DROP TABLE EXPRMT_MEASURE CASCADE CONSTRAINTS
;
DROP TABLE EXT_ONTOLOGY_TREE CASCADE CONSTRAINTS
;
DROP TABLE EXTERNAL_REFERENCE CASCADE CONSTRAINTS
;
DROP TABLE EXTERNAL_SYSTEM CASCADE CONSTRAINTS
;
DROP TABLE FACTOR_COMPONENT CASCADE CONSTRAINTS
;
DROP TABLE FAVORITE CASCADE CONSTRAINTS
;
DROP TABLE IDENTIFIER_MAPPING CASCADE CONSTRAINTS
;
DROP TABLE Instance_Descriptor_tree CASCADE CONSTRAINTS
;
DROP TABLE Laboratory_tree CASCADE CONSTRAINTS
;
DROP TABLE MEASURE CASCADE CONSTRAINTS
;
DROP TABLE MIGRATION_ACTION CASCADE CONSTRAINTS
;
DROP TABLE MIGRATION_AID CASCADE CONSTRAINTS
;
DROP TABLE MIGRATION_DAY CASCADE CONSTRAINTS
;
DROP TABLE MIGRATION_EVENT CASCADE CONSTRAINTS
;
DROP TABLE MIGRATION_PERSON CASCADE CONSTRAINTS
;
DROP TABLE ONTOLOGY CASCADE CONSTRAINTS
;
DROP TABLE ONTOLOGY_ITEM CASCADE CONSTRAINTS
;
DROP TABLE PERSON CASCADE CONSTRAINTS
;
DROP TABLE PERSON_ROLE CASCADE CONSTRAINTS
;
DROP TABLE PRJCT_EXPRMT_CNTXT_ITEM CASCADE CONSTRAINTS
;
DROP TABLE PRJCT_EXPRMT_CONTEXT CASCADE CONSTRAINTS
;
DROP TABLE PROJECT CASCADE CONSTRAINTS
;
DROP TABLE PROJECT_CONTEXT CASCADE CONSTRAINTS
;
DROP TABLE Project_Context_Item CASCADE CONSTRAINTS
;
DROP TABLE PROJECT_DOCUMENT CASCADE CONSTRAINTS
;
DROP TABLE PROJECT_EXPERIMENT CASCADE CONSTRAINTS
;
DROP TABLE Project_Step CASCADE CONSTRAINTS
;
DROP TABLE RESULT CASCADE CONSTRAINTS
;
--DROP TABLE RESULT_MAP CASCADE CONSTRAINTS
--;
DROP TABLE Result_type_tree CASCADE CONSTRAINTS
;
DROP TABLE "ROLE" CASCADE CONSTRAINTS
;
DROP TABLE Rslt_Context_Item CASCADE CONSTRAINTS
;
DROP TABLE Stage_tree CASCADE CONSTRAINTS
;
DROP TABLE STATEMENT_LOG CASCADE CONSTRAINTS
;
DROP TABLE STATS_MODIFIER_TREE CASCADE CONSTRAINTS
;
DROP TABLE STEP_CONTEXT CASCADE CONSTRAINTS
;
DROP TABLE STEP_CONTEXT_ITEM CASCADE CONSTRAINTS
;
DROP TABLE SUBSTANCE CASCADE CONSTRAINTS
;
DROP TABLE TEAM CASCADE CONSTRAINTS
;
DROP TABLE TEAM_MEMBER CASCADE CONSTRAINTS
;
DROP TABLE TEMP_CONTEXT_ITEM CASCADE CONSTRAINTS
;
DROP TABLE TREE_ROOT CASCADE CONSTRAINTS
;
DROP TABLE UNIT_CONVERSION CASCADE CONSTRAINTS
;
DROP TABLE Unit_tree CASCADE CONSTRAINTS
;
DROP PACKAGE AUDITING
;
DROP PACKAGE AUDITING_INIT
;
DROP PACKAGE AUDITING_SETUP
;
DROP PACKAGE BARD_CONTEXT
;
DROP PACKAGE CONFIDENCE_LEVEL_UTIL
;
DROP PACKAGE LOAD_DATA
;
DROP PACKAGE MANAGE_NAMES
;
DROP PACKAGE MANAGE_ONTOLOGY
;
DROP PACKAGE MIGRATION_STATS
;
DROP PACKAGE RESULT_MAP_UTIL
;
--DROP PROCEDURE MAKE_PROJECTS
--;
DROP PROCEDURE RESET_SEQUENCES
;
--DROP PROCEDURE RESULT_ID_UPDATE
--;
--DROP PROCEDURE UPDATE_ACTIVITY_THRESHOLD
--;
DROP SEQUENCE ASSAY_CONTEXT_ID_SEQ
;
DROP SEQUENCE ASSAY_CONTEXT_ITEM_ID_SEQ
;
DROP SEQUENCE ASSAY_CONTEXT_MEASURE_ID_SEQ
;
DROP SEQUENCE ASSAY_DOCUMENT_ID_SEQ
;
DROP SEQUENCE ASSAY_ID_SEQ
;
DROP SEQUENCE AUDIT_ID_SEQ
;
DROP SEQUENCE BARD_ONTOLOGY_SEQ
;
DROP SEQUENCE CONFIDENCE_LEVEL_FACTOR_ID_SEQ
;
DROP SEQUENCE CONFIDENCE_LEVEL_SCORE_ID_SEQ
;
DROP SEQUENCE ELEMENT_HIERARCHY_ID_SEQ
;
DROP SEQUENCE ELEMENT_ID_SEQ
;
DROP SEQUENCE ERROR_LOG_ID_SEQ
;
DROP SEQUENCE EXPERIMENT_FILE_ID_SEQ
;
DROP SEQUENCE EXPERIMENT_ID_SEQ
;
DROP SEQUENCE EXPRMT_CONTEXT_ID_SEQ
;
DROP SEQUENCE EXPRMT_CONTEXT_ITEM_ID_SEQ
;
DROP SEQUENCE EXPRMT_MEASURE_ID_SEQ
;
DROP SEQUENCE EXTERNAL_REFERENCE_ID_SEQ
;
DROP SEQUENCE EXTERNAL_SYSTEM_ID_SEQ
;
DROP SEQUENCE FACTOR_COMPONENT_ID_SEQ
;
DROP SEQUENCE FAVORITE_ID_SEQ
;
DROP SEQUENCE MEASURE_ID_SEQ
;
DROP SEQUENCE ONTOLOGY_ID_SEQ
;
DROP SEQUENCE ONTOLOGY_ITEM_ID_SEQ
;
DROP SEQUENCE PERSON_ID_SEQ
;
DROP SEQUENCE PERSON_ROLE_ID_SEQ
;
DROP SEQUENCE PRJCT_EXPRMT_CNTXT_ITEM_ID_SEQ
;
DROP SEQUENCE PRJCT_EXPRMT_CONTEXT_ID_SEQ
;
DROP SEQUENCE PROJECT_CONTEXT_ID_SEQ
;
DROP SEQUENCE PROJECT_CONTEXT_ITEM_ID_SEQ
;
DROP SEQUENCE PROJECT_DOCUMENT_ID_SEQ
;
DROP SEQUENCE PROJECT_EXPERIMENT_ID_SEQ
;
DROP SEQUENCE PROJECT_ID_SEQ
;
DROP SEQUENCE PROJECT_STEP_ID_SEQ
;
DROP SEQUENCE RESULT_ID_SEQ
;
DROP SEQUENCE ROLE_ID_SEQ
;
DROP SEQUENCE RSLT_CONTEXT_ITEM_ID_SEQ
;
DROP SEQUENCE STEP_CONTEXT_ID_SEQ
;
DROP SEQUENCE STEP_CONTEXT_ITEM_ID_SEQ
;
DROP SEQUENCE TEAM_ID_SEQ
;
DROP SEQUENCE TEAM_MEMBER_ID_SEQ
;
DROP SEQUENCE UNIT_CONVERSION_ID_SEQ
;
--
-- SEQUENCE: ASSAY_CONTEXT_ID_SEQ
--

CREATE SEQUENCE ASSAY_CONTEXT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ASSAY_CONTEXT_ITEM_ID_SEQ
--

CREATE SEQUENCE ASSAY_CONTEXT_ITEM_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ASSAY_CONTEXT_MEASURE_ID_SEQ
--

CREATE SEQUENCE ASSAY_CONTEXT_MEASURE_ID_SEQ
    START WITH 111
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: ASSAY_DOCUMENT_ID_SEQ
--

CREATE SEQUENCE ASSAY_DOCUMENT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ASSAY_ID_SEQ
--

CREATE SEQUENCE ASSAY_ID_SEQ
    START WITH 3
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: AUDIT_ID_SEQ
--

CREATE SEQUENCE AUDIT_ID_SEQ
    START WITH 2855001
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 200
    NOORDER
;

--
-- SEQUENCE: BARD_ONTOLOGY_SEQ
--

CREATE SEQUENCE BARD_ONTOLOGY_SEQ
    START WITH 1853
    INCREMENT BY 1
    NOMINVALUE
    NOMAXVALUE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: CONFIDENCE_LEVEL_FACTOR_ID_SEQ
--

CREATE SEQUENCE CONFIDENCE_LEVEL_FACTOR_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: CONFIDENCE_LEVEL_SCORE_ID_SEQ
--

CREATE SEQUENCE CONFIDENCE_LEVEL_SCORE_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ELEMENT_HIERARCHY_ID_SEQ
--

CREATE SEQUENCE ELEMENT_HIERARCHY_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ELEMENT_ID_SEQ
--

CREATE SEQUENCE DATA_MIG.ELEMENT_ID_SEQ
    START WITH 1510
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: ERROR_LOG_ID_SEQ
--

CREATE SEQUENCE ERROR_LOG_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: EXPERIMENT_FILE_ID_SEQ
--

CREATE SEQUENCE EXPERIMENT_FILE_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: EXPERIMENT_ID_SEQ
--

CREATE SEQUENCE EXPERIMENT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: EXPRMT_CONTEXT_ID_SEQ
--

CREATE SEQUENCE EXPRMT_CONTEXT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: EXPRMT_CONTEXT_ITEM_ID_SEQ
--

CREATE SEQUENCE EXPRMT_CONTEXT_ITEM_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: EXPRMT_MEASURE_ID_SEQ
--

CREATE SEQUENCE EXPRMT_MEASURE_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: EXTERNAL_REFERENCE_ID_SEQ
--

CREATE SEQUENCE EXTERNAL_REFERENCE_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: EXTERNAL_SYSTEM_ID_SEQ
--

CREATE SEQUENCE EXTERNAL_SYSTEM_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    NOCACHE
    NOORDER
;

--
-- SEQUENCE: FACTOR_COMPONENT_ID_SEQ
--

CREATE SEQUENCE FACTOR_COMPONENT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: FAVORITE_ID_SEQ
--

CREATE SEQUENCE FAVORITE_ID_SEQ
    START WITH 3
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: MEASURE_ID_SEQ
--

CREATE SEQUENCE MEASURE_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ONTOLOGY_ID_SEQ
--

CREATE SEQUENCE ONTOLOGY_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ONTOLOGY_ITEM_ID_SEQ
--

CREATE SEQUENCE ONTOLOGY_ITEM_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: PERSON_ID_SEQ
--

CREATE SEQUENCE PERSON_ID_SEQ
    START WITH 3
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: PERSON_ROLE_ID_SEQ
--

CREATE SEQUENCE PERSON_ROLE_ID_SEQ
    START WITH 3
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: PRJCT_EXPRMT_CNTXT_ITEM_ID_SEQ
--

CREATE SEQUENCE PRJCT_EXPRMT_CNTXT_ITEM_ID_SEQ
    START WITH 3797
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: PRJCT_EXPRMT_CONTEXT_ID_SEQ
--

CREATE SEQUENCE PRJCT_EXPRMT_CONTEXT_ID_SEQ
    START WITH 1550
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: PROJECT_CONTEXT_ID_SEQ
--

CREATE SEQUENCE PROJECT_CONTEXT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: PROJECT_CONTEXT_ITEM_ID_SEQ
--

CREATE SEQUENCE PROJECT_CONTEXT_ITEM_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: PROJECT_DOCUMENT_ID_SEQ
--

CREATE SEQUENCE PROJECT_DOCUMENT_ID_SEQ
    START WITH 43566
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: PROJECT_EXPERIMENT_ID_SEQ
--

CREATE SEQUENCE PROJECT_EXPERIMENT_ID_SEQ
    START WITH 5117
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: PROJECT_ID_SEQ
--

CREATE SEQUENCE PROJECT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: PROJECT_STEP_ID_SEQ
--

CREATE SEQUENCE PROJECT_STEP_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 20
    NOORDER
;

--
-- SEQUENCE: RESULT_ID_SEQ
--

CREATE SEQUENCE RESULT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: ROLE_ID_SEQ
--

CREATE SEQUENCE ROLE_ID_SEQ
    START WITH 3
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: RSLT_CONTEXT_ITEM_ID_SEQ
--

CREATE SEQUENCE RSLT_CONTEXT_ITEM_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: STEP_CONTEXT_ID_SEQ
--

CREATE SEQUENCE STEP_CONTEXT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: STEP_CONTEXT_ITEM_ID_SEQ
--

CREATE SEQUENCE STEP_CONTEXT_ITEM_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: TEAM_ID_SEQ
--

CREATE SEQUENCE TEAM_ID_SEQ
    START WITH 3
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: TEAM_MEMBER_ID_SEQ
--

CREATE SEQUENCE TEAM_MEMBER_ID_SEQ
    START WITH 3
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- SEQUENCE: UNIT_CONVERSION_ID_SEQ
--

CREATE SEQUENCE UNIT_CONVERSION_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 2
    NOORDER
;

--
-- TABLE: ASSAY
--

CREATE TABLE ASSAY(
    ASSAY_ID                NUMBER(19, 0)     NOT NULL,
    ASSAY_STATUS            VARCHAR2(20)      DEFAULT 'Draft' NOT NULL,
    Assay_Short_Name        VARCHAR2(250)     DEFAULT ' ' NOT NULL,
    ASSAY_NAME              VARCHAR2(1000 CHAR) NOT NULL,
    ASSAY_VERSION           VARCHAR2(10)      DEFAULT 1 NOT NULL,
    ASSAY_TYPE              VARCHAR2(20)      DEFAULT 'Regular' NOT NULL,
    DESIGNED_BY             VARCHAR2(100),
    READY_FOR_EXTRACTION    VARCHAR2(20)      DEFAULT 'Not Ready' NOT NULL,
    VERSION                 NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED            TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated            TIMESTAMP(6),
    MODIFIED_BY             VARCHAR2(40),
    CONSTRAINT CK_ASSAY_STATUS CHECK (Assay_Status IN ('Draft', 'Approved', 'Retired')),
    CONSTRAINT CK_ASSAY_EXTRACTION CHECK (ready_for_extraction IN ('Not Ready', 'Ready', 'Started', 'Complete')),
    CONSTRAINT CK_ASSAY_TYPE CHECK (Assay_Type IN ('Regular', 'Panel - Array', 'Panel - Group', 'Template')),
    CONSTRAINT PK_ASSAY PRIMARY KEY (ASSAY_ID)
)
;



--
-- TABLE: Assay_Context
--

CREATE TABLE Assay_Context(
    Assay_Context_ID    NUMBER(19, 0)    NOT NULL,
    ASSAY_ID            NUMBER(19, 0)    NOT NULL,
    CONTEXT_NAME        VARCHAR2(128),
    Context_Group       VARCHAR2(256),
    VERSION             NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DISPLAY_ORDER       NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    Date_Created        TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    Last_Updated        TIMESTAMP(6),
    MODIFIED_BY         VARCHAR2(40),
    CONSTRAINT PK_ASSAY_CONTEXT PRIMARY KEY (Assay_Context_ID)
)
;



COMMENT ON COLUMN Assay_Context.CONTEXT_NAME IS 'used as a title for the cards in the UI'
;
--
-- TABLE: Assay_Context_Item
--

CREATE TABLE Assay_Context_Item(
    Assay_Context_Item_ID    NUMBER(19, 0)     NOT NULL,
    Assay_Context_ID         NUMBER(19, 0)     NOT NULL,
    DISPLAY_ORDER            NUMBER(5, 0)      DEFAULT 0 NOT NULL,
    ATTRIBUTE_TYPE           VARCHAR2(20)      NOT NULL,
    ATTRIBUTE_ID             NUMBER(19, 0)     NOT NULL,
    QUALIFIER                CHAR(2),
    VALUE_ID                 NUMBER(19, 0),
    EXT_VALUE_ID             VARCHAR2(60),
    VALUE_DISPLAY            VARCHAR2(500),
    VALUE_NUM                NUMBER(30, 15),
    VALUE_MIN                NUMBER(30, 15),
    VALUE_MAX                NUMBER(30, 15),
    VERSION                  NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created             TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated             TIMESTAMP(6),
    MODIFIED_BY              VARCHAR2(40),
    CONSTRAINT CK_ATTRIBUTE_TYPE CHECK (Attribute_Type in ('Fixed', 'List', 'Range', 'Free')),
    CONSTRAINT CK_ASSAY_CONTEXT_ITEM_QALFR CHECK (QUALIFIER IN ('= ', '< ', '<=', '> ', '>=', '<<', '>>', '~ ')),
    CONSTRAINT PK_ASSAY_CONTEXT_ITEM PRIMARY KEY (Assay_Context_Item_ID)
)
;



COMMENT ON COLUMN Assay_Context_Item.VALUE_DISPLAY IS 'This is not a general text entry field, rather it is an easily displayable text version of the other value columns'
;
--
-- TABLE: ASSAY_CONTEXT_MEASURE
--

CREATE TABLE ASSAY_CONTEXT_MEASURE(
    ASSAY_CONTEXT_MEASURE_ID    NUMBER(19, 0)    NOT NULL,
    Assay_Context_ID            NUMBER(19, 0)    NOT NULL,
    MEASURE_ID                  NUMBER(19, 0)    NOT NULL,
    VERSION                     NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED                TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED                TIMESTAMP(6),
    MODIFIED_BY                 VARCHAR2(40),
    CONSTRAINT PK_ASSAY_CONTEXT_MEASURE PRIMARY KEY (ASSAY_CONTEXT_MEASURE_ID)
)
;



--
-- TABLE: Assay_Descriptor_Tree
--

CREATE TABLE Assay_Descriptor_Tree(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    ELEMENT_ID        NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS    VARCHAR2(20)      NOT NULL,
    LABEL             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    DESCRIPTION       VARCHAR2(1000),
    FULL_PATH         VARCHAR2(3000),
    ABBREVIATION      VARCHAR2(20),
    SYNONYMS          VARCHAR2(1000),
    EXTERNAL_URL      VARCHAR2(1000),
    UNIT_ID           NUMBER(19, 0),
    CONSTRAINT PK_ASSAY_DESCRIPTOR PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: ASSAY_DOCUMENT
--

CREATE TABLE ASSAY_DOCUMENT(
    Assay_document_ID    NUMBER(19, 0)    NOT NULL,
    ASSAY_ID             NUMBER(19, 0)    NOT NULL,
    Document_Name        VARCHAR2(500)    NOT NULL,
    DOCUMENT_TYPE        VARCHAR2(20)     DEFAULT 'Description' NOT NULL,
    DOCUMENT_CONTENT     CLOB             DEFAULT EMPTY_CLOB(),
    VERSION              NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    Date_Created         TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    Last_Updated         TIMESTAMP(6),
    MODIFIED_BY          VARCHAR2(40),
    CONSTRAINT CK_ASSAY_DOCUMENT_TYPE CHECK (Document_Type IN ('Description', 'Protocol', 'Comments', 'Publication', 'External URL', 'Other')),
    CONSTRAINT PK_ASSAY_DOCUMENT PRIMARY KEY (Assay_document_ID)
)
;



--
-- TABLE: AUDIT_COLUMN_LOG
--

CREATE TABLE AUDIT_COLUMN_LOG(
    AUDIT_ID       NUMBER(19, 0)     NOT NULL,
    "COLUMN_NAME"  VARCHAR2(30)      NOT NULL,
    OLD_VALUE      VARCHAR2(4000),
    CONSTRAINT PK_AUDIT_COLUMN_LOG PRIMARY KEY (AUDIT_ID, "COLUMN_NAME")
)
;



--
-- TABLE: AUDIT_ROW_LOG
--

CREATE TABLE AUDIT_ROW_LOG(
    AUDIT_ID           NUMBER(19, 0)     NOT NULL,
    TABLE_OWNER        VARCHAR2(30)      DEFAULT Lower(USER) NOT NULL,
    "TABLE_NAME"       VARCHAR2(30)      NOT NULL,
    PRIMARY_KEY        VARCHAR2(4000)    NOT NULL,
    "ACTION"           VARCHAR2(20)      NOT NULL,
    AUDIT_TIMESTAMP    DATE              DEFAULT SYSDATE NOT NULL,
    USERNAME           VARCHAR2(40)      NOT NULL,
    CONSTRAINT PK_AUDIT_ROW_LOG PRIMARY KEY (AUDIT_ID)
)
;



--
-- TABLE: AUDIT_SETTING
--

CREATE TABLE AUDIT_SETTING(
    TABLE_OWNER     VARCHAR2(30)    NOT NULL,
    "TABLE_NAME"    VARCHAR2(30)    NOT NULL,
    "COLUMN_NAME"   VARCHAR2(30)    NOT NULL,
    IS_PK           CHAR(1)         DEFAULT 'N' NOT NULL,
    AUDIT_INSERT    CHAR(1)         DEFAULT 'N' NOT NULL,
    AUDIT_UPDATE    CHAR(1)         DEFAULT 'Y' NOT NULL,
    AUDIT_DELETE    CHAR(1)         DEFAULT 'Y' NOT NULL,
    CONSTRAINT PK_AUDIT_SETTING PRIMARY KEY (TABLE_OWNER, "TABLE_NAME", "COLUMN_NAME")
)
;



--
-- TABLE: BARD_TREE
--

CREATE TABLE BARD_TREE(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    ELEMENT_ID        NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS    VARCHAR2(20)      NOT NULL,
    LABEL             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    FULL_PATH         VARCHAR2(3000),
    DESCRIPTION       VARCHAR2(1000),
    ABBREVIATION      VARCHAR2(20),
    SYNONYMS          VARCHAR2(1000),
    EXTERNAL_URL      VARCHAR2(1000),
    UNIT_ID           NUMBER(19, 0),
    CONSTRAINT PK_BARD_TREE PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: Biology_Descriptor_tree
--

CREATE TABLE Biology_Descriptor_tree(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    ELEMENT_ID        NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS    VARCHAR2(20)      NOT NULL,
    LABEL             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    DESCRIPTION       VARCHAR2(1000),
    FULL_PATH         VARCHAR2(3000),
    ABBREVIATION      VARCHAR2(20),
    SYNONYMS          VARCHAR2(1000),
    EXTERNAL_URL      VARCHAR2(1000),
    UNIT_ID           NUMBER(19, 0),
    CONSTRAINT PK_BIOLOGY_DESCRIPTOR PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: CONFIDENCE_LEVEL_FACTOR
--

CREATE TABLE CONFIDENCE_LEVEL_FACTOR(
    CONFIDENCE_LEVEL_FACTOR_ID    NUMBER(19, 0)     NOT NULL,
    FACTOR_NAME                   VARCHAR2(128)     NOT NULL,
    PRECIDENCE                    NUMBER(3, 0),
    WEIGHTING                     NUMBER(3, 0),
    MIN_THRESHOLD                 NUMBER(3, 0),
    MAX_LEVEL                     NUMBER(3, 0),
    DESCRIPTION                   VARCHAR2(1000),
    Score_SQL                     VARCHAR2(4000),
    VERSION                       NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED                  TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    LAST_UPDATED                  TIMESTAMP(6),
    MODIFIED_BY                   VARCHAR2(40),
    CONSTRAINT PK_Confidence_Level_Factor PRIMARY KEY (CONFIDENCE_LEVEL_FACTOR_ID)
)
;



--
-- TABLE: CONFIDENCE_LEVEL_SCORE
--

CREATE TABLE CONFIDENCE_LEVEL_SCORE(
    CONFIDENCE_LEVEL_SCORE_ID     NUMBER(19, 0)    NOT NULL,
    CONFIDENCE_LEVEL_FACTOR_ID    NUMBER(19, 0)    NOT NULL,
    EXPERIMENT_ID                 NUMBER(19, 0)    NOT NULL,
    SCORE                         NUMBER(5, 0),
    VERSION                       NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED                  TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED                  TIMESTAMP(6),
    MODIFIED_BY                   VARCHAR2(40),
    CONSTRAINT PK_Confidence_Level_Score PRIMARY KEY (CONFIDENCE_LEVEL_SCORE_ID)
)
;



--
-- TABLE: DICTIONARY_TREE
--

CREATE TABLE DICTIONARY_TREE(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    ELEMENT_ID        NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS    VARCHAR2(20)      NOT NULL,
    LABEL             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    FULL_PATH         VARCHAR2(3000),
    DESCRIPTION       VARCHAR2(1000),
    ABBREVIATION      VARCHAR2(20),
    SYNONYMS          VARCHAR2(1000),
    EXTERNAL_URL      VARCHAR2(1000),
    UNIT_ID           NUMBER(19, 0),
    CONSTRAINT PK_DICTIONARY_TREE PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: ELEMENT
--

CREATE TABLE ELEMENT(
    ELEMENT_ID              NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS          VARCHAR2(20)      DEFAULT 'Pending' NOT NULL,
    LABEL                   VARCHAR2(128)     NOT NULL,
    UNIT_ID                 NUMBER(19, 0),
    ABBREVIATION            VARCHAR2(20),
    Expected_Value_Type     VARCHAR2(40)      DEFAULT 'none' NOT NULL,
    ADD_CHILD_METHOD        VARCHAR2(20)      DEFAULT 'no' NOT NULL,
    BARD_URI                VARCHAR2(250),
    DESCRIPTION             VARCHAR2(1000),
    SYNONYMS                VARCHAR2(1000),
    EXTERNAL_URL            VARCHAR2(1000),
    CURATION_NOTES          VARCHAR2(1000),
    READY_FOR_EXTRACTION    VARCHAR2(20)      DEFAULT 'Ready' NOT NULL,
    VERSION                 NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created            TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated            TIMESTAMP(6),
    MODIFIED_BY             VARCHAR2(40),
    CONSTRAINT CK_ELEMENT_STATUS CHECK (Element_Status IN ('Pending', 'Published', 'Deprecated', 'Retired')),
    CONSTRAINT CK_ELEMENT_EXTRACTION CHECK (ready_for_extraction IN ('Not Ready', 'Ready', 'Started', 'Complete')),
    CONSTRAINT CK_ELEMENT_EXPECTED_VALUE_TYPE CHECK (Expected_Value_Type in ('numeric', 'element', 'external ontology', 'free text', 'none', '')),
    CONSTRAINT CK_ELEMENT_ADD_CHILD_METHOD CHECK (Add_Child_Method in ('RDM request', 'direct','no')),
    CONSTRAINT PK_ELEMENT PRIMARY KEY (ELEMENT_ID)
)
;



--
-- TABLE: ELEMENT_HIERARCHY
--

CREATE TABLE ELEMENT_HIERARCHY(
    ELEMENT_HIERARCHY_ID    NUMBER(19, 0)    NOT NULL,
    PARENT_ELEMENT_ID       NUMBER(19, 0),
    CHILD_ELEMENT_ID        NUMBER(19, 0)    NOT NULL,
    RELATIONSHIP_TYPE       VARCHAR2(40)     NOT NULL,
    VERSION                 NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED            TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED            TIMESTAMP(6),
    MODIFIED_BY             VARCHAR2(40),
    CONSTRAINT PK_ELEMENT_HIERARCHY PRIMARY KEY (ELEMENT_HIERARCHY_ID)
)
;



--
-- TABLE: ERROR_LOG
--

CREATE TABLE ERROR_LOG(
    ERROR_LOG_ID      NUMBER(19, 0)     NOT NULL,
    ERROR_DATE        DATE              DEFAULT sysdate NOT NULL,
    PROCEDURE_NAME    VARCHAR2(120)     NOT NULL,
    ERR_NUM           NUMBER(19, 0)     NOT NULL,
    ERR_MSG           VARCHAR2(1000),
    ERR_COMMENT       VARCHAR2(4000),
    CONSTRAINT PK_ERROR_LOG PRIMARY KEY (ERROR_LOG_ID)
)
;



--
-- TABLE: EXPERIMENT
--

CREATE TABLE EXPERIMENT(
    EXPERIMENT_ID           NUMBER(19, 0)     NOT NULL,
    EXPERIMENT_NAME         VARCHAR2(1000)    NOT NULL,
    EXPERIMENT_STATUS       VARCHAR2(20)      DEFAULT 'Pending' NOT NULL,
    READY_FOR_EXTRACTION    VARCHAR2(20)      DEFAULT 'Not Ready' NOT NULL,
    ASSAY_ID                NUMBER(19, 0)     NOT NULL,
    RUN_DATE_FROM           DATE,
    RUN_DATE_TO             DATE,
    HOLD_UNTIL_DATE         DATE,
    CONFIDENCE_LEVEL        NUMBER(3, 0)      DEFAULT 1 NOT NULL,
    DESCRIPTION             VARCHAR2(1000),
    VERSION                 NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created            TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated            TIMESTAMP(6),
    MODIFIED_BY             VARCHAR2(40),
    CONSTRAINT CK_EXPERIMENT_STATUS CHECK (Experiment_Status IN ('Pending', 'Approved', 'Rejected', 'Retired')),
    CONSTRAINT CK_EXPERIMENT_EXTRACTION CHECK (ready_for_extraction IN ('Not Ready', 'Ready', 'Started', 'Complete')),
    CONSTRAINT PK_EXPERIMENT PRIMARY KEY (EXPERIMENT_ID)
)
;



COMMENT ON COLUMN EXPERIMENT.HOLD_UNTIL_DATE IS 'can only be set a max of 1 year in the future'
;
--
-- TABLE: EXPERIMENT_FILE
--

CREATE TABLE EXPERIMENT_FILE(
    EXPERIMENT_FILE_ID    NUMBER(19, 0)     NOT NULL,
    EXPERIMENT_ID         NUMBER(19, 0)     NOT NULL,
    SUBMISSION_VERSION    NUMBER(19, 0)     NOT NULL,
    ORIGINAL_FILE         VARCHAR2(1000 CHAR) NOT NULL,
    EXPORT_FILE           VARCHAR2(1000 CHAR),
    VERSION               NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED          TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    LAST_UPDATED          TIMESTAMP(6),
    MODIFIED_BY           VARCHAR2(40),
    CONSTRAINT PK_EXPERIMENT_FILE PRIMARY KEY (EXPERIMENT_FILE_ID)
)
;



--
-- TABLE: EXPRMT_CONTEXT
--

CREATE TABLE EXPRMT_CONTEXT(
    EXPRMT_CONTEXT_ID    NUMBER(19, 0)    NOT NULL,
    EXPERIMENT_ID        NUMBER(19, 0)    NOT NULL,
    CONTEXT_NAME         VARCHAR2(128),
    CONTEXT_GROUP        VARCHAR2(256),
    DISPLAY_ORDER        NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    VERSION              NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED         TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED         TIMESTAMP(6),
    MODIFIED_BY          VARCHAR2(40),
    CONSTRAINT PK_EXPRMT_CONTEXT PRIMARY KEY (EXPRMT_CONTEXT_ID)
)
;



COMMENT ON COLUMN EXPRMT_CONTEXT.CONTEXT_NAME IS 'used as a title for the cards in the UI'
;
--
-- TABLE: EXPRMT_CONTEXT_ITEM
--

CREATE TABLE EXPRMT_CONTEXT_ITEM(
    EXPRMT_CONTEXT_ITEM_ID    NUMBER(19, 0)     NOT NULL,
    EXPRMT_CONTEXT_ID         NUMBER(19, 0)     NOT NULL,
    DISPLAY_ORDER             NUMBER(5, 0)      DEFAULT 0 NOT NULL,
    ATTRIBUTE_ID              NUMBER(19, 0)     NOT NULL,
    VALUE_ID                  NUMBER(19, 0),
    EXT_VALUE_ID              VARCHAR2(60),
    QUALIFIER                 CHAR(2),
    VALUE_NUM                 NUMBER(30, 15),
    VALUE_MIN                 NUMBER(30, 15),
    VALUE_MAX                 NUMBER(30, 15),
    VALUE_DISPLAY             VARCHAR2(500),
    VERSION                   NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED              TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    LAST_UPDATED              TIMESTAMP(6),
    MODIFIED_BY               VARCHAR2(40),
    CONSTRAINT CK_EXPRMT_CNTXT_ITM_QUALFR CHECK (Qualifier IN ('= ', '< ', '<=', '> ', '>=', '<<', '>>', '~ ')),
    CONSTRAINT PK_EXPRMT_CONTEXT_ITEM PRIMARY KEY (EXPRMT_CONTEXT_ITEM_ID)
)
;



COMMENT ON COLUMN EXPRMT_CONTEXT_ITEM.VALUE_DISPLAY IS 'This is not a general text entry field, rather it is an easily displayable text version of the other value columns'
;
--
-- TABLE: EXPRMT_MEASURE
--

CREATE TABLE EXPRMT_MEASURE(
    EXPRMT_MEASURE_ID            NUMBER(19, 0)    NOT NULL,
    PARENT_EXPRMT_MEASURE_ID     NUMBER(19, 0),
    PARENT_CHILD_RELATIONSHIP    VARCHAR2(20),
    EXPERIMENT_ID                NUMBER(19, 0)    NOT NULL,
    MEASURE_ID                   NUMBER(19, 0)    NOT NULL,
    VERSION                      NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED                 TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED                 TIMESTAMP(6),
    MODIFIED_BY                  VARCHAR2(40),
    CONSTRAINT CK_EXPRMT_MEASURE_RELATIONSHIP CHECK (PARENT_CHILD_RELATIONSHIP in ('supported by', 'calculated from')),
    CONSTRAINT CK_EXPRMT_MEASURE_PARENT CHECK ((PARENT_CHILD_RELATIONSHIP IS NOT NULL AND PARENT_EXPRMT_MEASURE_ID IS NOT NULL)
OR
(PARENT_CHILD_RELATIONSHIP IS NULL AND PARENT_EXPRMT_MEASURE_ID IS NULL)),
    CONSTRAINT PK_EXPRMT_MEASURE PRIMARY KEY (EXPRMT_MEASURE_ID)
)
;



--
-- TABLE: EXT_ONTOLOGY_TREE
--

CREATE TABLE EXT_ONTOLOGY_TREE(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    ELEMENT_ID        NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS    VARCHAR2(20)      NOT NULL,
    LABEL             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    FULL_PATH         VARCHAR2(3000),
    DESCRIPTION       VARCHAR2(1000),
    ABBREVIATION      VARCHAR2(20),
    SYNONYMS          VARCHAR2(1000),
    EXTERNAL_URL      VARCHAR2(1000),
    UNIT_ID           NUMBER(19, 0),
    CONSTRAINT PK_EXT_ONTOLOGY_TREE PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: EXTERNAL_REFERENCE
--

CREATE TABLE EXTERNAL_REFERENCE(
    EXTERNAL_REFERENCE_ID    NUMBER(19, 0)    NOT NULL,
    EXTERNAL_SYSTEM_ID       NUMBER(19, 0)    NOT NULL,
    EXPERIMENT_ID            NUMBER(19, 0),
    PROJECT_ID               NUMBER(19, 0),
    EXT_ASSAY_REF            VARCHAR2(128)    NOT NULL,
    VERSION                  NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED             TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED             TIMESTAMP(6),
    MODIFIED_BY              VARCHAR2(40),
    CONSTRAINT CK_PROJECT_EXPERIMENT_NULLS CHECK ((Project_ID is null and experiment_ID is not null)
 or
(Project_ID is not null and experiment_ID is null)),
    CONSTRAINT PK_EXTERNAL_REFERENCE PRIMARY KEY (EXTERNAL_REFERENCE_ID)
)
;



--
-- TABLE: EXTERNAL_SYSTEM
--

CREATE TABLE EXTERNAL_SYSTEM(
    EXTERNAL_SYSTEM_ID    NUMBER(19, 0)     NOT NULL,
    SYSTEM_NAME           VARCHAR2(128)     NOT NULL,
    OWNER                 VARCHAR2(128),
    SYSTEM_URL            VARCHAR2(1000),
    VERSION               NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created          TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated          TIMESTAMP(6),
    MODIFIED_BY           VARCHAR2(40),
    CONSTRAINT PK_EXTERNAL_SYSTEM PRIMARY KEY (EXTERNAL_SYSTEM_ID)
)
;



--
-- TABLE: FACTOR_COMPONENT
--

CREATE TABLE FACTOR_COMPONENT(
    FACTOR_COMPONENT_ID           NUMBER(19, 0)    NOT NULL,
    CONFIDENCE_LEVEL_FACTOR_ID    NUMBER(19, 0)    NOT NULL,
    COMPONENT_NAME                VARCHAR2(128)    NOT NULL,
    COMPONENT_RATING              NUMBER(5, 0),
    VERSION                       NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED                  TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED                  TIMESTAMP(6),
    MODIFIED_BY                   VARCHAR2(40),
    CONSTRAINT PK_Factor_Component PRIMARY KEY (FACTOR_COMPONENT_ID)
)
;



--
-- TABLE: FAVORITE
--

CREATE TABLE FAVORITE(
    FAVORITE_ID      NUMBER(19, 0)     NOT NULL,
    PERSON_ID        NUMBER(19, 0)     NOT NULL,
    FAVORITE_URL     VARCHAR2(1000),
    FAVORITE_TYPE    VARCHAR2(20)      DEFAULT 'Favorite' NOT NULL,
    FAVORITE_NAME    VARCHAR2(255)     NOT NULL,
    DISPLAY_ORDER    NUMBER(5, 0)      DEFAULT 0 NOT NULL,
    VERSION          NUMBER(5, 0)      DEFAULT 0 NOT NULL,
    DATE_CREATED     DATE              DEFAULT sysdate,
    LAST_UPDATED     DATE,
    MODIFIED_BY      VARCHAR2(40),
    CONSTRAINT CK_FAVORITE_TYPE CHECK (Favorite_Type IN ('Favorite', 'Recently Used')),
    CONSTRAINT PK_FAVORITE PRIMARY KEY (FAVORITE_ID)
)
;



--
-- TABLE: IDENTIFIER_MAPPING
--

CREATE TABLE IDENTIFIER_MAPPING(
    "TABLE_NAME"     VARCHAR2(31)     NOT NULL,
    SOURCE_SCHEMA    VARCHAR2(31)     NOT NULL,
    SOURCE_ID        NUMBER(19, 0)    NOT NULL,
    TARGET_ID        NUMBER(19, 0)    NOT NULL,
    CONSTRAINT PK_IDENTIFIER_MAPPING PRIMARY KEY ("TABLE_NAME", SOURCE_SCHEMA, SOURCE_ID)
)
;



--
-- TABLE: Instance_Descriptor_tree
--

CREATE TABLE Instance_Descriptor_tree(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    ELEMENT_ID        NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS    VARCHAR2(20)      NOT NULL,
    LABEL             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    DESCRIPTION       VARCHAR2(1000),
    FULL_PATH         VARCHAR2(3000),
    ABBREVIATION      VARCHAR2(20),
    SYNONYMS          VARCHAR2(1000),
    EXTERNAL_URL      VARCHAR2(1000),
    UNIT_ID           NUMBER(19, 0),
    CONSTRAINT PK_INSTANCE_DESCRIPTOR PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: Laboratory_tree
--

CREATE TABLE Laboratory_tree(
    NODE_ID              NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID       NUMBER(19, 0),
    LABORATORY_ID        NUMBER(19, 0)     NOT NULL,
    LABORATORY_STATUS    VARCHAR2(20)      NOT NULL,
    LABORATORY           VARCHAR2(128)     NOT NULL,
    DESCRIPTION          VARCHAR2(1000),
    CONSTRAINT PK_LABORATORY PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: MEASURE
--

CREATE TABLE MEASURE(
    MEASURE_ID                   NUMBER(19, 0)    NOT NULL,
    ASSAY_ID                     NUMBER(19, 0)    NOT NULL,
    RESULT_TYPE_ID               NUMBER(19, 0)    NOT NULL,
    PARENT_MEASURE_ID            NUMBER(19, 0),
    PARENT_CHILD_RELATIONSHIP    VARCHAR2(20),
    ENTRY_UNIT_ID                NUMBER(19, 0),
    Stats_Modifier_ID            NUMBER(19, 0),
    VERSION                      NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    Date_Created                 TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    Last_Updated                 TIMESTAMP(6),
    MODIFIED_BY                  VARCHAR2(40),
    CONSTRAINT CK_MEASURE_PC_RELATIONSHIP CHECK (Parent_Child_Relationship in('calculated from', 'supported by')),
    CONSTRAINT CK_MEASURE_PARENT CHECK ((PARENT_CHILD_RELATIONSHIP IS NOT NULL AND PARENT_MEASURE_ID IS NOT NULL)
OR
(PARENT_CHILD_RELATIONSHIP IS NULL AND PARENT_MEASURE_ID IS NULL)),
    CONSTRAINT PK_MEASURE PRIMARY KEY (MEASURE_ID)
)
;



--
-- TABLE: MIGRATION_ACTION
--

CREATE TABLE MIGRATION_ACTION(
    ACTION_REF          NUMBER(38, 0)     NOT NULL,
    COMPLETED_ACTION    VARCHAR2(200),
    COUNT_NAME          VARCHAR2(20),
    DESCRIPTION         VARCHAR2(1000),
    COUNT_SQL           VARCHAR2(4000),
    CONSTRAINT PK_MIG_ACTION PRIMARY KEY (ACTION_REF)
)
;



--
-- TABLE: MIGRATION_AID
--

CREATE TABLE MIGRATION_AID(
    AID              VARCHAR2(20)     NOT NULL,
    CENTER           VARCHAR2(250),
    BAO_ANNOTATED    CHAR(1),
    PROBE            VARCHAR2(20),
    DNA_REPAIR       CHAR(1),
    CONSTRAINT PK_AID PRIMARY KEY (AID)
)
;



--
-- TABLE: MIGRATION_DAY
--

CREATE TABLE MIGRATION_DAY(
    DAY_REF           NUMBER(38, 0)    NOT NULL,
    MIGRATION_DATE    DATE,
    "YEAR"            NUMBER           NOT NULL,
    "MONTH"           NUMBER           NOT NULL,
    QUARTER           VARCHAR2(20)     NOT NULL,
    WEEK              NUMBER           NOT NULL,
    DAY_OF_WEEK       VARCHAR2(10),
    CONSTRAINT PK_MIG_DAY PRIMARY KEY (DAY_REF)
)
;



--
-- TABLE: MIGRATION_EVENT
--

CREATE TABLE MIGRATION_EVENT(
    ASSAY_ID         NUMBER(19, 0),
    EXPERIMENT_ID    NUMBER(19, 0),
    PROJECT_ID       NUMBER(19, 0),
    EVENT_COUNT      NUMBER(19, 0),
    PERSON_REF       NUMBER(38, 0),
    ACTION_REF       NUMBER(38, 0),
    DAY_REF          NUMBER(38, 0),
    AID              VARCHAR2(20)     NOT NULL
)
;



--
-- TABLE: MIGRATION_PERSON
--

CREATE TABLE MIGRATION_PERSON(
    PERSON_REF     NUMBER(38, 0)    NOT NULL,
    PERSON_NAME    VARCHAR2(100),
    CONSTRAINT PK_MIG_PERSON PRIMARY KEY (PERSON_REF)
)
;



--
-- TABLE: ONTOLOGY
--

CREATE TABLE ONTOLOGY(
    ONTOLOGY_ID      NUMBER(19, 0)     NOT NULL,
    ONTOLOGY_NAME    VARCHAR2(256)     NOT NULL,
    ABBREVIATION     VARCHAR2(20),
    SYSTEM_URL       VARCHAR2(1000),
    VERSION          NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created     TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated     TIMESTAMP(6),
    MODIFIED_BY      VARCHAR2(40),
    CONSTRAINT PK_ONTOLOGY PRIMARY KEY (ONTOLOGY_ID)
)
;



COMMENT ON TABLE ONTOLOGY IS 'an external ontology or dictionary or other source of reference data'
;
--
-- TABLE: ONTOLOGY_ITEM
--

CREATE TABLE ONTOLOGY_ITEM(
    ONTOLOGY_ITEM_ID    NUMBER(19, 0)    NOT NULL,
    ONTOLOGY_ID         NUMBER(19, 0)    NOT NULL,
    ELEMENT_ID          NUMBER(19, 0),
    ITEM_REFERENCE      VARCHAR2(20),
    VERSION             NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    Date_Created        TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    Last_Updated        TIMESTAMP(6),
    MODIFIED_BY         VARCHAR2(40),
    CONSTRAINT PK_ONTOLOGY_ITEM PRIMARY KEY (ONTOLOGY_ITEM_ID)
)
;



COMMENT ON COLUMN ONTOLOGY_ITEM.ITEM_REFERENCE IS 'Concatenate this with the Ontology.system_URL for a full URI for the item'
;

--
-- TABLE: PERSON
--

CREATE TABLE PERSON(
    PERSON_ID          NUMBER(19, 0)    NOT NULL,
    USERNAME           VARCHAR2(255)    NOT NULL,
    EMAIL_ADDRESS      VARCHAR2(255),
    FULL_NAME          VARCHAR2(255),
    ACCOUNT_EXPIRED    NUMBER(1, 0)     DEFAULT 0 NOT NULL,
    ACCOUNT_LOCKED     NUMBER(1, 0)     DEFAULT 0 NOT NULL,
    ACCOUNT_ENABLED    NUMBER(1, 0)     DEFAULT 1 NOT NULL,
    VERSION            NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED       DATE             DEFAULT sysdate,
    LAST_UPDATED       DATE,
    MODIFIED_BY        VARCHAR2(40),
    CONSTRAINT CK_PERSON_EMAIL CHECK (email_address like '%@%.%'),
    CONSTRAINT PK_PERSON PRIMARY KEY (PERSON_ID)
)
;



--
-- TABLE: PERSON_ROLE
--

CREATE TABLE PERSON_ROLE(
    PERSON_ROLE_ID    NUMBER(19, 0)    NOT NULL,
    ROLE_ID           NUMBER(19, 0)    NOT NULL,
    PERSON_ID         NUMBER(19, 0)    NOT NULL,
    VERSION           NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED      DATE             DEFAULT sysdate,
    LAST_UPDATED      DATE,
    MODIFIED_BY       VARCHAR2(40),
    CONSTRAINT PK_PERSON_ROLE PRIMARY KEY (PERSON_ROLE_ID)
)
;



--
-- TABLE: PRJCT_EXPRMT_CNTXT_ITEM
--

CREATE TABLE PRJCT_EXPRMT_CNTXT_ITEM(
    PRJCT_EXPRMT_CNTXT_ITEM_ID    NUMBER(19, 0)     NOT NULL,
    PRJCT_EXPRMT_CONTEXT_ID       NUMBER(19, 0)     NOT NULL,
    DISPLAY_ORDER                 NUMBER(5, 0)      NOT NULL,
    ATTRIBUTE_ID                  NUMBER(19, 0)     NOT NULL,
    VALUE_ID                      NUMBER(19, 0),
    EXT_VALUE_ID                  VARCHAR2(60),
    QUALIFIER                     CHAR(2),
    VALUE_NUM                     NUMBER(30, 15),
    VALUE_MIN                     NUMBER(30, 15),
    VALUE_MAX                     NUMBER(30, 15),
    VALUE_DISPLAY                 VARCHAR2(500),
    VERSION                       NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED                  TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    LAST_UPDATED                  TIMESTAMP(6),
    MODIFIED_BY                   VARCHAR2(40),
    CONSTRAINT CK_PRJCT_EXPRMT_ITEM_QUALIFIER CHECK (Qualifier IN ('= ', '< ', '<=', '> ', '>=', '<<', '>>', '~ ')),
    CONSTRAINT PK_PRJCT_EXPRMT_CNTXT_ITEM PRIMARY KEY (PRJCT_EXPRMT_CNTXT_ITEM_ID)
)
;



COMMENT ON COLUMN PRJCT_EXPRMT_CNTXT_ITEM.VALUE_DISPLAY IS 'This is not a general text entry field, rather it is an easily displayable text version of the other value columns'
;
--
-- TABLE: PRJCT_EXPRMT_CONTEXT
--

CREATE TABLE PRJCT_EXPRMT_CONTEXT(
    PRJCT_EXPRMT_CONTEXT_ID    NUMBER(19, 0)    NOT NULL,
    PROJECT_EXPERIMENT_ID      NUMBER(19, 0)    NOT NULL,
    CONTEXT_NAME               VARCHAR2(128),
    CONTEXT_GROUP              VARCHAR2(256),
    DISPLAY_ORDER              NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    VERSION                    NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED               TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED               TIMESTAMP(6),
    MODIFIED_BY                VARCHAR2(40),
    CONSTRAINT PK_PRJCT_EXPRMT_CONTEXT PRIMARY KEY (PRJCT_EXPRMT_CONTEXT_ID)
)
;



COMMENT ON COLUMN PRJCT_EXPRMT_CONTEXT.CONTEXT_NAME IS 'used as a title for the cards in the UI'
;
--
-- TABLE: PROJECT
--

CREATE TABLE PROJECT(
    PROJECT_ID              NUMBER(19, 0)     NOT NULL,
    PROJECT_NAME            VARCHAR2(256)     NOT NULL,
    GROUP_TYPE              VARCHAR2(20)      DEFAULT 'Project' NOT NULL,
    DESCRIPTION             VARCHAR2(1000),
    ready_for_extraction    VARCHAR2(20)      DEFAULT 'Not Ready' NOT NULL,
    VERSION                 NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created            TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated            TIMESTAMP(6),
    MODIFIED_BY             VARCHAR2(40),
    PROJECT_STATUS          VARCHAR2(20)      DEFAULT 'Draft' NOT NULL,
    CONSTRAINT CK_PROJECT_TYPE CHECK (GROUP_TYPE in ('Project', 'Probe Report', 'Campaign', 'Panel', 'Study', 'Template')),
    CONSTRAINT CK_PROJECT_EXTRACTION CHECK (ready_for_extraction IN ('Not Ready', 'Ready', 'Started', 'Complete')),
    CONSTRAINT CK_PROJECT_STATUS CHECK (Project_Status IN ('Draft', 'In progress', 'Completed', 'Retired')),
    CONSTRAINT PK_PROJECT PRIMARY KEY (PROJECT_ID)
)
;



--
-- TABLE: PROJECT_CONTEXT
--

CREATE TABLE PROJECT_CONTEXT(
    PROJECT_CONTEXT_ID    NUMBER(19, 0)    NOT NULL,
    PROJECT_ID            NUMBER(19, 0)    NOT NULL,
    CONTEXT_NAME          VARCHAR2(128),
    Context_Group         VARCHAR2(256),
    DISPLAY_ORDER         NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    VERSION               NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED          TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED          TIMESTAMP(6),
    MODIFIED_BY           VARCHAR2(40),
    CONSTRAINT PK_PROJECT_CONTEXT PRIMARY KEY (PROJECT_CONTEXT_ID)
)
;



COMMENT ON COLUMN PROJECT_CONTEXT.CONTEXT_NAME IS 'used as a title for the cards in the UI'
;
--
-- TABLE: Project_Context_Item
--

CREATE TABLE Project_Context_Item(
    project_Context_Item_ID    NUMBER(19, 0)     NOT NULL,
    PROJECT_CONTEXT_ID         NUMBER(19, 0)     NOT NULL,
    ATTRIBUTE_ID               NUMBER(19, 0)     NOT NULL,
    DISPLAY_ORDER              NUMBER(5, 0)      NOT NULL,
    VALUE_ID                   NUMBER(19, 0),
    EXT_VALUE_ID               VARCHAR2(60),
    QUALIFIER                  CHAR(2),
    VALUE_DISPLAY              VARCHAR2(500),
    VALUE_NUM                  NUMBER(30, 15),
    VALUE_MIN                  NUMBER(30, 15),
    VALUE_MAX                  NUMBER(30, 15),
    VERSION                    NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED               TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    LAST_UPDATED               TIMESTAMP(6),
    MODIFIED_BY                VARCHAR2(40),
    CONSTRAINT CK_PRJCT_CNTXT_ITEM_QUALIFIER CHECK (Qualifier IN ('= ', '< ', '<=', '> ', '>=', '<<', '>>', '~ ')),
    CONSTRAINT PK_Project_Context_Item PRIMARY KEY (project_Context_Item_ID)
)
;



COMMENT ON COLUMN Project_Context_Item.VALUE_DISPLAY IS 'This is not a general text entry field, rather it is an easily displayable text version of the other value columns'
;
--
-- TABLE: PROJECT_DOCUMENT
--

CREATE TABLE PROJECT_DOCUMENT(
    PROJECT_DOCUMENT_ID    NUMBER(19, 0)    NOT NULL,
    PROJECT_ID             NUMBER(19, 0)    NOT NULL,
    DOCUMENT_NAME          VARCHAR2(500)    NOT NULL,
    DOCUMENT_TYPE          VARCHAR2(20)     NOT NULL,
    DOCUMENT_CONTENT       CLOB,
    VERSION                NUMBER(38, 0)    NOT NULL,
    DATE_CREATED           TIMESTAMP(6)     NOT NULL,
    LAST_UPDATED           TIMESTAMP(6),
    MODIFIED_BY            VARCHAR2(40),
    CONSTRAINT CK_PROJECT_DOCUMENT_TYPE CHECK (Document_Type IN ('Description', 'Protocol', 'Comments', 'Publication', 'External URL', 'Other')),
    CONSTRAINT PK_PROJECT_DOCUMENT PRIMARY KEY (PROJECT_DOCUMENT_ID)
)
;



--
-- TABLE: PROJECT_EXPERIMENT
--

CREATE TABLE PROJECT_EXPERIMENT(
    PROJECT_EXPERIMENT_ID    NUMBER(19, 0)    NOT NULL,
    EXPERIMENT_ID            NUMBER(19, 0)    NOT NULL,
    PROJECT_ID               NUMBER(19, 0)    NOT NULL,
    STAGE_ID                 NUMBER(19, 0),
    VERSION                  NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED             TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED             TIMESTAMP(6),
    MODIFIED_BY              VARCHAR2(40),
    CONSTRAINT PK_PROJECT_EXPERIMENT PRIMARY KEY (PROJECT_EXPERIMENT_ID)
)
;



--
-- TABLE: Project_Step
--

CREATE TABLE Project_Step(
    Project_Step_ID               NUMBER(19, 0)    NOT NULL,
    VERSION                       NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    NEXT_PROJECT_EXPERIMENT_ID    NUMBER(19, 0)    NOT NULL,
    PREV_PROJECT_EXPERIMENT_ID    NUMBER(19, 0)    NOT NULL,
    Date_Created                  TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    EDGE_NAME                     VARCHAR2(128),
    Last_Updated                  TIMESTAMP(6),
    MODIFIED_BY                   VARCHAR2(40),
    CONSTRAINT PK_Project_Step PRIMARY KEY (Project_Step_ID)
)
;



COMMENT ON TABLE Project_Step IS 'The annotations (context items) for a step show the annotations of the incoming arrowhead on the edge between the experiments and the "follows" experiment.  Thus the annotations can refer to the experiment or the step (aka decision) that instigated the experiment.  Bear in mind that the "follows" experiment can be null, i.e. this the experiment does not have a predecessor.  Primary screens tend to have this characteristic.'
;
--
-- TABLE: RESULT
--

CREATE TABLE RESULT(
    RESULT_ID                    NUMBER(19, 0)     NOT NULL,
    PARENT_RESULT_ID             NUMBER(19, 0),
    Parent_child_relationship    VARCHAR2(20),
    RESULT_STATUS                VARCHAR2(20)      DEFAULT 'Pending' NOT NULL,
    READY_FOR_EXTRACTION         VARCHAR2(20)      DEFAULT 'Not Ready' NOT NULL,
    EXPERIMENT_ID                NUMBER(19, 0)     NOT NULL,
    RESULT_TYPE_ID               NUMBER(19, 0)     NOT NULL,
    STATS_MODIFIER_ID            NUMBER(19, 0),
    SUBSTANCE_ID                 NUMBER(19, 0)     NOT NULL,
    REPLICATE_NO                 NUMBER(5, 0),
    QUALIFIER                    CHAR(2),
    Value_ID                     NUMBER(19, 0),
    VALUE_NUM                    NUMBER(30, 15),
    VALUE_MIN                    NUMBER(30, 15),
    VALUE_MAX                    NUMBER(30, 15),
    VALUE_DISPLAY                VARCHAR2(256),
    VERSION                      NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created                 TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated                 TIMESTAMP(6),
    MODIFIED_BY                  VARCHAR2(40),
    CONSTRAINT CK_RESULT_STATUS CHECK (Result_Status IN ('Pending', 'Approved', 'Rejected', 'Mark for Deletion')),
    CONSTRAINT CK_RESULT_EXTRACTION CHECK (Ready_For_Extraction IN ('Not Ready', 'Ready', 'Started', 'Complete')),
    CONSTRAINT CK_RESULT_QUALIFIER CHECK (Qualifier IN ('= ', '< ', '<=', '> ', '>=', '<<', '>>', '~ ')),
    CONSTRAINT CK_RESULT_HIERARCHY_TYPE CHECK (Parent_child_relationship in('calculated from', 'supported by')),
    CONSTRAINT CK_RESULT_PARENTAGE CHECK ((HIERARCHY_TYPE IS NOT NULL AND PARENT_RESULT_ID IS NOT NULL)
OR
(HIERARCHY_TYPE IS NULL AND PARENT_RESULT_ID IS NULL)),
    CONSTRAINT PK_RESULT PRIMARY KEY (RESULT_ID)
)
;



COMMENT ON COLUMN RESULT.Parent_child_relationship IS 'two types of hierarchy are allowed: parent/child where one result is dependant on or grouped with another; derived from where aresult is used to claculate another (e.g. PI used for IC50).  The hierarchy types are mutually exclusive.'
;
COMMENT ON COLUMN RESULT.SUBSTANCE_ID IS 'Has external reference to the PubChem SID'
;
--
-- TABLE: RESULT_MAP
--

CREATE TABLE RESULT_MAP(
    AID                          NUMBER(19, 0)    NOT NULL,
    TID                          NUMBER(19, 0)    NOT NULL,
    TIDNAME                      VARCHAR2(200),
    PARENTTID                    VARCHAR2(40),
    RELATIONSHIP                 VARCHAR2(10),
    QUALIFIERTID                 NUMBER,
    RESULTTYPE                   VARCHAR2(128),
    STATS_MODIFIER               VARCHAR2(20),
    CONTEXTTID                   NUMBER(19, 0),
    CONTEXTITEM                  VARCHAR2(128),
    CONCENTRATION                FLOAT(20),
    CONCENTRATIONUNIT            VARCHAR2(10),
    DATE_CREATE                  DATE             DEFAULT SYSDATE,
    LAST_UPDATED                 DATE,
    MODIFIED_BY                  VARCHAR2(40),
    PANELNO                      NUMBER,
    ATTRIBUTE1                   VARCHAR2(128),
    VALUE1                       VARCHAR2(128),
    EXCLUDED_POINTS_SERIES_NO    NUMBER,
    ATTRIBUTE2                   VARCHAR2(128),
    VALUE2                       VARCHAR2(128),
    SERIESNO                     NUMBER,
    CONSTRAINT PK_RESULT_MAP PRIMARY KEY (AID, TID)
)
;



--
-- TABLE: Result_type_tree
--

CREATE TABLE Result_type_tree(
    NODE_ID               NUMBER(19, 0)     NOT NULL,
    Parent_node_id        NUMBER(19, 0),
    RESULT_TYPE_ID        NUMBER(19, 0)     NOT NULL,
    RESULT_TYPE_STATUS    VARCHAR2(20)      NOT NULL,
    RESULT_TYPE_NAME      VARCHAR2(128)     NOT NULL,
    IS_LEAF               CHAR(1)           NOT NULL,
    DESCRIPTION           VARCHAR2(1000),
    FULL_PATH             VARCHAR2(3000),
    ABBREVIATION          VARCHAR2(20),
    SYNONYMS              VARCHAR2(1000),
    BASE_UNIT_ID          NUMBER(19, 0),
    CONSTRAINT PK_RESULT_TYPE PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: "ROLE"
--

CREATE TABLE "ROLE"(
    ROLE_ID         NUMBER(19, 0)    NOT NULL,
    AUTHORITY       VARCHAR2(255)    NOT NULL,
    VERSION         NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED    DATE             DEFAULT sysdate,
    LAST_UPDATED    DATE,
    MODIFIED_BY     VARCHAR2(40),
    CONSTRAINT PK_ROLE PRIMARY KEY (ROLE_ID)
)
;



--
-- TABLE: Rslt_Context_Item
--

CREATE TABLE Rslt_Context_Item(
    Rslt_Context_Item_ID    NUMBER(19, 0)     NOT NULL,
    RESULT_ID               NUMBER(19, 0)     NOT NULL,
    ATTRIBUTE_ID            NUMBER(19, 0)     NOT NULL,
    VALUE_ID                NUMBER(19, 0),
    DISPLAY_ORDER           NUMBER(5, 0)      DEFAULT 0 NOT NULL,
    EXT_VALUE_ID            VARCHAR2(60),
    QUALIFIER               CHAR(2),
    VALUE_NUM               NUMBER(30, 15),
    VALUE_MIN               NUMBER(30, 15),
    VALUE_MAX               NUMBER(30, 15),
    VALUE_DISPLAY           VARCHAR2(500),
    VERSION                 NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created            TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated            TIMESTAMP(6),
    MODIFIED_BY             VARCHAR2(40),
    CONSTRAINT CK_RSLT_CONTEXT_ITEM_QULFR CHECK (Qualifier IN ('= ', '< ', '<=', '> ', '>=', '<<', '>>', '~ ')),
    CONSTRAINT PK_RSLT_CONTEXT_ITEM PRIMARY KEY (Rslt_Context_Item_ID)
)
;



COMMENT ON COLUMN Rslt_Context_Item.VALUE_DISPLAY IS 'This is not a general text entry field, rather it is an easily displayable text version of the other value columns'
;
--
-- TABLE: Stage_tree
--

CREATE TABLE Stage_tree(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    STAGE_ID          NUMBER(19, 0)     NOT NULL,
    STAGE_STATUS      VARCHAR2(20)      NOT NULL,
    STAGE             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    DESCRIPTION       VARCHAR2(1000),
    FULL_PATH         VARCHAR2(3000),
    CONSTRAINT PK_STAGE PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: STATEMENT_LOG
--

CREATE TABLE STATEMENT_LOG(
    "TABLE_NAME"   VARCHAR2(63)      NOT NULL,
    IDENTIFIER     NUMBER(19, 0)     NOT NULL,
    ACTION_DATE    DATE              DEFAULT sysdate NOT NULL,
    "ACTION"       VARCHAR2(20)      NOT NULL,
    DATA_CLAUSE    VARCHAR2(1000),
    CONSTRAINT PK_STATEMENT_LOG PRIMARY KEY ("TABLE_NAME", IDENTIFIER, ACTION_DATE, "ACTION")
)
;



--
-- TABLE: STATS_MODIFIER_TREE
--

CREATE TABLE STATS_MODIFIER_TREE(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    ELEMENT_ID        NUMBER(19, 0)     NOT NULL,
    ELEMENT_STATUS    VARCHAR2(20)      NOT NULL,
    LABEL             VARCHAR2(128)     NOT NULL,
    IS_LEAF           CHAR(1)           NOT NULL,
    FULL_PATH         VARCHAR2(3000),
    DESCRIPTION       VARCHAR2(1000),
    ABBREVIATION      VARCHAR2(20),
    SYNONYMS          VARCHAR2(1000),
    EXTERNAL_URL      VARCHAR2(1000),
    UNIT_ID           NUMBER(19, 0),
    CONSTRAINT PK_STATS_MODIFIER PRIMARY KEY (NODE_ID)
)
;



--
-- TABLE: STEP_CONTEXT
--

CREATE TABLE STEP_CONTEXT(
    STEP_CONTEXT_ID    NUMBER(19, 0)    NOT NULL,
    Project_Step_ID    NUMBER(19, 0)    NOT NULL,
    CONTEXT_NAME       VARCHAR2(128),
    Context_Group      VARCHAR2(256),
    DISPLAY_ORDER      NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    VERSION            NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED       TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED       TIMESTAMP(6),
    MODIFIED_BY        VARCHAR2(40),
    CONSTRAINT PK_STEP_CONTEXT PRIMARY KEY (STEP_CONTEXT_ID)
)
;



COMMENT ON COLUMN STEP_CONTEXT.CONTEXT_NAME IS 'used as a title for the cards in the UI'
;
--
-- TABLE: STEP_CONTEXT_ITEM
--

CREATE TABLE STEP_CONTEXT_ITEM(
    STEP_CONTEXT_ITEM_ID    NUMBER(19, 0)     NOT NULL,
    STEP_CONTEXT_ID         NUMBER(19, 0)     NOT NULL,
    DISPLAY_ORDER           NUMBER(5, 0)      NOT NULL,
    ATTRIBUTE_ID            NUMBER(19, 0)     NOT NULL,
    VALUE_ID                NUMBER(19, 0),
    EXT_VALUE_ID            VARCHAR2(60),
    QUALIFIER               CHAR(2),
    VALUE_NUM               NUMBER(30, 15),
    VALUE_MIN               NUMBER(30, 15),
    VALUE_MAX               NUMBER(30, 15),
    VALUE_DISPLAY           VARCHAR2(500),
    VERSION                 NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED            TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    LAST_UPDATED            TIMESTAMP(6),
    MODIFIED_BY             VARCHAR2(40),
    CONSTRAINT CK_STEP_CONTEXT_ITEM_QUALIFIER CHECK (Qualifier IN ('= ', '< ', '<=', '> ', '>=', '<<', '>>', '~ ')),
    CONSTRAINT PK_STEP_CONTEXT_ITEM PRIMARY KEY (STEP_CONTEXT_ITEM_ID)
)
;



COMMENT ON COLUMN STEP_CONTEXT_ITEM.VALUE_DISPLAY IS 'This is not a general text entry field, rather it is an easily displayable text version of the other value columns'
;
--
-- TABLE: SUBSTANCE
--

CREATE TABLE SUBSTANCE(
    SUBSTANCE_ID    NUMBER(19, 0)     NOT NULL,
    SMILES          VARCHAR2(4000),
    VERSION         NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED    TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    LAST_UPDATED    TIMESTAMP(6),
    MODIFIED_BY     VARCHAR2(40),
    CONSTRAINT PK_SUBSTANCE PRIMARY KEY (SUBSTANCE_ID)
)
;



COMMENT ON TABLE SUBSTANCE IS 'Substance is used a CACHE of data from PubChem.  This cache can be removed if we can be assured that availability and capacity (for API queries) of PubChem will support dynamic use.'
;
--
-- TABLE: TEAM
--

CREATE TABLE TEAM(
    TEAM_ID         NUMBER(19, 0)    NOT NULL,
    TEAM_NAME       VARCHAR2(100)    NOT NULL,
    LOCATION        VARCHAR2(255),
    VERSION         NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED    DATE             DEFAULT sysdate,
    LAST_UPDATED    DATE,
    MODIFIED_BY     VARCHAR2(40),
    CONSTRAINT PK_TEAM PRIMARY KEY (TEAM_ID)
)
;



--
-- TABLE: TEAM_MEMBER
--

CREATE TABLE TEAM_MEMBER(
    TEAM_MEMBER_ID       NUMBER(19, 0)    NOT NULL,
    TEAM_ID              NUMBER(19, 0)    NOT NULL,
    PERSON_ROLE_ID       NUMBER(19, 0)    NOT NULL,
    MEMBERSHIP_STATUS    VARCHAR2(20)     DEFAULT 'Active',
    VERSION              NUMBER(5, 0)     DEFAULT 0 NOT NULL,
    DATE_CREATED         DATE             DEFAULT sysdate,
    LAST_UPDATED         DATE,
    MODIFIED_BY          VARCHAR2(40),
    CONSTRAINT CK_TEAM_MEMBER_STATUS CHECK (Membership_Status IN ('Active', 'Suspended', 'Inactive')),
    CONSTRAINT PK_TEAM_MEMBER PRIMARY KEY (TEAM_MEMBER_ID)
)
;



--
-- TABLE: TEMP_CONTEXT_ITEM
--

CREATE GLOBAL TEMPORARY TABLE TEMP_CONTEXT_ITEM(
    ASSAY_ID          NUMBER(19, 0)    NOT NULL,
    ATTRIBUTE_ID      NUMBER(19, 0),
    ATTRIBUTE_TYPE    VARCHAR2(20),
    DISPLAY_ORDER     NUMBER(5, 0),
    VALUE_NUM         FLOAT(20),
    UNIT              VARCHAR2(30),
    VALUE_ID          NUMBER(19, 0),
    EXT_VALUE_ID      VARCHAR2(60),
    VALUE_MIN         NUMBER(19, 0),
    VALUE_MAX         NUMBER(19, 0),
    AID               NUMBER(19, 0)    NOT NULL,
    RESULTTYPE        VARCHAR2(384),
    STATSMODIFIER     VARCHAR2(384),
    CONTEXTITEM       VARCHAR2(384),
    VALUE1            VARCHAR2(384)
)ON COMMIT DELETE ROWS
;



--
-- TABLE: TREE_ROOT
--

CREATE TABLE TREE_ROOT(
    TREE_ROOT_ID         NUMBER(19, 0)    NOT NULL,
    TREE_NAME            VARCHAR2(30)     NOT NULL,
    ELEMENT_ID           NUMBER(19, 0)    NOT NULL,
    RELATIONSHIP_TYPE    VARCHAR2(20),
    VERSION              NUMBER(38, 0)    DEFAULT 0 NOT NULL,
    DATE_CREATED         TIMESTAMP(6)     DEFAULT sysdate NOT NULL,
    LAST_UPDATED         TIMESTAMP(6),
    MODIFIED_BY          VARCHAR2(40),
    CONSTRAINT PK_TREE_ROOT PRIMARY KEY (TREE_ROOT_ID)
)
;



--
-- TABLE: UNIT_CONVERSION
--

CREATE TABLE UNIT_CONVERSION(
    UNIT_CONVERSION_ID    NUMBER(19, 0)     NOT NULL,
    FROM_UNIT_ID          NUMBER(19, 0)     NOT NULL,
    TO_UNIT_ID            NUMBER(19, 0)     NOT NULL,
    MULTIPLIER            NUMBER(30, 15),
    OFFSET                NUMBER(30, 15),
    FORMULA               VARCHAR2(256)     NOT NULL,
    VERSION               NUMBER(38, 0)     DEFAULT 0 NOT NULL,
    Date_Created          TIMESTAMP(6)      DEFAULT sysdate NOT NULL,
    Last_Updated          TIMESTAMP(6),
    MODIFIED_BY           VARCHAR2(40),
    CONSTRAINT CK_UNIT_CONVERSION_MULTIPLIER CHECK ((formula LIKE '%multiplier%' AND multiplier != 1)
          OR (multiplier IS NULL AND formula NOT LIKE '%multiplier%')
          OR multiplier = 1),
    CONSTRAINT CK_UNIT_CONVERSION_OFFSET CHECK ((formula LIKE '%offset%' AND offset != 0)
          OR (offset IS NULL AND formula NOT LIKE '%offset%')
          OR offset = 0),
    CONSTRAINT CK_UNIT_CONVERSION_VALUE CHECK (formula LIKE '%value%'),
    CONSTRAINT PK_UNIT_CONVERSION PRIMARY KEY (UNIT_CONVERSION_ID)
)
;



--
-- TABLE: Unit_tree
--

CREATE TABLE Unit_tree(
    NODE_ID           NUMBER(19, 0)     NOT NULL,
    PARENT_NODE_ID    NUMBER(19, 0),
    UNIT_ID           NUMBER(19, 0)     NOT NULL,
    UNIT              VARCHAR2(128)     NOT NULL,
    ABBREVIATION      VARCHAR2(20),
    DESCRIPTION       VARCHAR2(1000),
    IS_LEAF           CHAR(1)           NOT NULL,
    FULL_PATH         VARCHAR2(3000),
    CONSTRAINT PK_UNIT PRIMARY KEY (NODE_ID)
)
;



--
-- VIEW: ASSAY_ELEMENT
--

CREATE VIEW ASSAY_ELEMENT AS
SELECT El.ELEMENT_ID Element_ID, El.ELEMENT_STATUS Element_Status, El.LABEL Label, El.DESCRIPTION Description, El.ABBREVIATION Abbreviation, El.SYNONYMS Synonyms, El.UNIT_ID Unit_ID, El.BARD_URI BARD_URI, El.EXTERNAL_URL External_URL, El.READY_FOR_EXTRACTION ready_for_extraction, El.VERSION Version, El.Date_Created Date_Created, El.Last_Updated Last_Updated, El.MODIFIED_BY Modified_by, El.Expected_Value_Type, El.ADD_CHILD_METHOD, El.CURATION_NOTES
FROM ELEMENT El
WHERE ELEMENT_ID in (select adt.ELEMENT_ID from Assay_Descriptor_Tree adt)
;

COMMENT ON TABLE ASSAY_ELEMENT IS 'This view shows the unique list of elements used to assemble the assay_descriptor_tree'
;
--
-- VIEW: BIOLOGY_ELEMENT
--

CREATE VIEW BIOLOGY_ELEMENT AS
SELECT El.ELEMENT_ID Element_ID, El.ELEMENT_STATUS Element_Status, El.LABEL Label, El.DESCRIPTION Description, El.ABBREVIATION Abbreviation, El.SYNONYMS Synonyms, El.UNIT_ID Unit_ID, El.BARD_URI BARD_URI, El.EXTERNAL_URL External_URL, El.READY_FOR_EXTRACTION ready_for_extraction, El.VERSION Version, El.Date_Created Date_Created, El.Last_Updated Last_Updated, El.MODIFIED_BY Modified_by, El.Expected_Value_Type, El.ADD_CHILD_METHOD, El.CURATION_NOTES
FROM ELEMENT El
WHERE el.ELEMENT_ID in (select bdt.ELEMENT_ID from Biology_Descriptor_tree bdt)
;

--
-- VIEW: INSTANCE_ELEMENT
--

CREATE VIEW INSTANCE_ELEMENT AS
SELECT El.ELEMENT_ID Element_ID, El.ELEMENT_STATUS Element_Status, El.LABEL Label, El.DESCRIPTION Description, El.ABBREVIATION Abbreviation, El.SYNONYMS Synonyms, El.UNIT_ID Unit_ID, El.BARD_URI BARD_URI, El.EXTERNAL_URL External_URL, El.READY_FOR_EXTRACTION ready_for_extraction, El.VERSION Version, El.Date_Created Date_Created, El.Last_Updated Last_Updated, El.MODIFIED_BY Modified_by, El.Expected_Value_Type, El.ADD_CHILD_METHOD, El.CURATION_NOTES
FROM ELEMENT El
WHERE el.ELEMENT_ID in (select idt.ELEMENT_ID from Instance_Descriptor_tree idt)
;

--
-- VIEW: LABORATORY_ELEMENT
--

CREATE VIEW LABORATORY_ELEMENT
(Element_ID, Element_Status, Label, Description, Abbreviation, Synonyms, Unit_ID, BARD_URI, External_URL, ready_for_extraction, Version, Date_Created, Last_Updated, Modified_by, Expected_Value_Type, Add_Child_Method, CURATION_NOTES) AS
SELECT El.ELEMENT_ID, El.ELEMENT_STATUS, El.LABEL, El.DESCRIPTION, El.ABBREVIATION, El.SYNONYMS, El.UNIT_ID, El.BARD_URI, El.EXTERNAL_URL, El.READY_FOR_EXTRACTION, El.VERSION, El.Date_Created, El.Last_Updated, El.MODIFIED_BY, El.Expected_Value_Type, El.ADD_CHILD_METHOD, El.CURATION_NOTES
FROM ELEMENT El
WHERE ELEMENT_ID in (select LABORATORY_ID from Laboratory_tree)
;

--
-- VIEW: RESULT_TYPE_ELEMENT
--

CREATE VIEW RESULT_TYPE_ELEMENT AS
SELECT El.ELEMENT_ID Element_ID, El.ELEMENT_STATUS Element_Status, El.LABEL Label, El.DESCRIPTION Description, El.ABBREVIATION Abbreviation, El.SYNONYMS Synonyms, El.UNIT_ID Unit_ID, El.BARD_URI BARD_URI, El.EXTERNAL_URL External_URL, El.READY_FOR_EXTRACTION ready_for_extraction, El.VERSION Version, El.Date_Created Date_Created, El.Last_Updated Last_Updated, El.MODIFIED_BY Modified_by, El.Expected_Value_Type, El.ADD_CHILD_METHOD, El.CURATION_NOTES
FROM ELEMENT El
WHERE el.ELEMENT_ID in (select RESULT_TYPE_ID from Result_type_tree)
;

--
-- VIEW: STAGE_ELEMENT
--

CREATE VIEW STAGE_ELEMENT AS
SELECT El.ELEMENT_ID Element_ID, El.ELEMENT_STATUS Element_Status, El.LABEL Label, El.DESCRIPTION Description, El.ABBREVIATION Abbreviation, El.SYNONYMS Synonyms, El.UNIT_ID Unit_ID, El.BARD_URI BARD_URI, El.EXTERNAL_URL External_URL, El.READY_FOR_EXTRACTION ready_for_extraction, El.VERSION Version, El.Date_Created Date_Created, El.Last_Updated Last_Updated, El.MODIFIED_BY Modified_by, El.Expected_Value_Type, El.ADD_CHILD_METHOD, El.CURATION_NOTES
FROM ELEMENT El
WHERE el.ELEMENT_ID in (select ELEMENT_ID from Stage_tree)
;

--
-- VIEW: UNIT_ELEMENT
--

CREATE VIEW UNIT_ELEMENT AS
SELECT El.ELEMENT_ID Element_ID, El.ELEMENT_STATUS Element_Status, El.LABEL Label, El.DESCRIPTION Description, El.ABBREVIATION Abbreviation, El.SYNONYMS Synonyms, El.UNIT_ID Unit_ID, El.BARD_URI BARD_URI, El.EXTERNAL_URL External_URL, El.READY_FOR_EXTRACTION ready_for_extraction, El.VERSION Version, El.Date_Created Date_Created, El.Last_Updated Last_Updated, El.MODIFIED_BY Modified_by, El.Expected_Value_Type, El.ADD_CHILD_METHOD, El.CURATION_NOTES
FROM ELEMENT El
WHERE ELEMENT_ID in (select UNIT_ID from Unit_tree)
;

--
-- INDEX: IDX_ASSAY_NAME_VERSION
--

CREATE INDEX IDX_ASSAY_NAME_VERSION ON ASSAY(ASSAY_NAME, ASSAY_VERSION)
;
--
-- INDEX: FK_ASSAY_TEAM
--

CREATE INDEX FK_ASSAY_TEAM ON ASSAY(DESIGNED_BY)
;
--
-- INDEX: UI_ASSAY_CONTEXT_ORDER
--

CREATE UNIQUE INDEX UI_ASSAY_CONTEXT_ORDER ON Assay_Context(ASSAY_ID, DISPLAY_ORDER)
;
--
-- INDEX: UI_ASSAY_CONTEXT_NAMES
--

CREATE UNIQUE INDEX UI_ASSAY_CONTEXT_NAMES ON Assay_Context(ASSAY_ID, Context_Group, CONTEXT_NAME)
;
--
-- INDEX: FK_ASSAY_CONTEXT_ASSAY
--

CREATE INDEX FK_ASSAY_CONTEXT_ASSAY ON Assay_Context(ASSAY_ID)
;
--
-- INDEX: UI_ASSAY_CONTEXT_ITEM
--

CREATE UNIQUE INDEX UI_ASSAY_CONTEXT_ITEM ON Assay_Context_Item(ASSAY_CONTEXT_ID, ATTRIBUTE_ID, Decode(ATTRIBUTE_TYPE, 'List', VALUE_DISPLAY, 'ANY'))
;
--
-- INDEX: FK_A_CONTEXT_ITEM_A_CONTEXT
--

CREATE INDEX FK_A_CONTEXT_ITEM_A_CONTEXT ON Assay_Context_Item(Assay_Context_ID)
;
--
-- INDEX: FK_A_CONTEXT_ITEM_ATTRIBUTE
--

CREATE BITMAP INDEX FK_A_CONTEXT_ITEM_ATTRIBUTE ON Assay_Context_Item(ATTRIBUTE_ID)
;
--
-- INDEX: FK_A_CONTEXT_ITEM_VALUE
--

CREATE INDEX FK_A_CONTEXT_ITEM_VALUE ON Assay_Context_Item(VALUE_ID)
;
--
-- INDEX: UI_ASSAY_CONTEXT_ITEM_ORDR
--

CREATE UNIQUE INDEX UI_ASSAY_CONTEXT_ITEM_ORDR ON Assay_Context_Item(Assay_Context_ID, DISPLAY_ORDER)
;
--
-- INDEX: FK_ACM_ASSAY_CONTEXT
--

CREATE INDEX FK_ACM_ASSAY_CONTEXT ON ASSAY_CONTEXT_MEASURE(Assay_Context_ID)
;
--
-- INDEX: FK_ACM_MEASURE
--

CREATE INDEX FK_ACM_MEASURE ON ASSAY_CONTEXT_MEASURE(MEASURE_ID)
;
--
-- INDEX: FK_ASSAY_DESCRIPTOR_PARENT_SLF
--

CREATE INDEX FK_ASSAY_DESCRIPTOR_PARENT_SLF ON Assay_Descriptor_Tree(PARENT_NODE_ID)
;
--
-- INDEX: FK_ASSAY_DOCUMENT_ASSAY
--

CREATE INDEX FK_ASSAY_DOCUMENT_ASSAY ON ASSAY_DOCUMENT(ASSAY_ID)
;
--
-- INDEX: FK_AUDIT_COLUMN_AUDIT_ROW
--

CREATE INDEX FK_AUDIT_COLUMN_AUDIT_ROW ON AUDIT_COLUMN_LOG(AUDIT_ID)
;
--
-- INDEX: IDX_AUDIT_ROW_LOG_PRIMARY_KEY
--

CREATE INDEX IDX_AUDIT_ROW_LOG_PRIMARY_KEY ON AUDIT_ROW_LOG(PRIMARY_KEY)
;
--
-- INDEX: IDX_BARD_TREE_ELEMENT_ID
--

CREATE INDEX IDX_BARD_TREE_ELEMENT_ID ON BARD_TREE(ELEMENT_ID)
;
--
-- INDEX: FK_BARD_TREE_PARENT
--

CREATE INDEX FK_BARD_TREE_PARENT ON BARD_TREE(PARENT_NODE_ID)
;
--
-- INDEX: FK_BIOLOGY_DESCRIPTOR_PRNT_SLF
--

CREATE INDEX FK_BIOLOGY_DESCRIPTOR_PRNT_SLF ON Biology_Descriptor_tree(PARENT_NODE_ID)
;
--
-- INDEX: AK_CONFIDENCE_LEVEL_FACTOR
--

CREATE UNIQUE INDEX AK_CONFIDENCE_LEVEL_FACTOR ON CONFIDENCE_LEVEL_FACTOR(FACTOR_NAME)
;
--
-- INDEX: AK_CONFIDENCE_LEVEL_SCORE
--

CREATE UNIQUE INDEX AK_CONFIDENCE_LEVEL_SCORE ON CONFIDENCE_LEVEL_SCORE(EXPERIMENT_ID, CONFIDENCE_LEVEL_FACTOR_ID)
;
--
-- INDEX: FK_CNFDNC_LVL_SCORE_FACTOR
--

CREATE INDEX FK_CNFDNC_LVL_SCORE_FACTOR ON CONFIDENCE_LEVEL_SCORE(CONFIDENCE_LEVEL_FACTOR_ID)
;
--
-- INDEX: FK_CNFDNC_LVL_SCORE_EXPRMT
--

CREATE INDEX FK_CNFDNC_LVL_SCORE_EXPRMT ON CONFIDENCE_LEVEL_SCORE(EXPERIMENT_ID)
;
--
-- INDEX: FK_DICTIONARY_TREE_PARENT
--

CREATE INDEX FK_DICTIONARY_TREE_PARENT ON DICTIONARY_TREE(PARENT_NODE_ID)
;
--
-- INDEX: IDX_ELEMENT_LOWER_LABEL
--

CREATE INDEX IDX_ELEMENT_LOWER_LABEL ON ELEMENT(LOWER("LABEL"))
;
--
-- INDEX: AK_ELEMENT_HIERARCHY
--

CREATE UNIQUE INDEX AK_ELEMENT_HIERARCHY ON ELEMENT_HIERARCHY(CHILD_ELEMENT_ID, PARENT_ELEMENT_ID, RELATIONSHIP_TYPE)
;
--
-- INDEX: FK_E_HIERARCHY_PARENT_ELEM_ID
--

CREATE INDEX FK_E_HIERARCHY_PARENT_ELEM_ID ON ELEMENT_HIERARCHY(PARENT_ELEMENT_ID)
;
--
-- INDEX: FK_E_HIERARCHY_CHILD_ELEM_ID
--

CREATE INDEX FK_E_HIERARCHY_CHILD_ELEM_ID ON ELEMENT_HIERARCHY(CHILD_ELEMENT_ID)
;
--
-- INDEX: FK_EXPERIMENT_ASSAY
--

CREATE INDEX FK_EXPERIMENT_ASSAY ON EXPERIMENT(ASSAY_ID)
;
--
-- INDEX: FK_EXPERIMENT_FILE
--

CREATE INDEX FK_EXPERIMENT_FILE ON EXPERIMENT_FILE(EXPERIMENT_ID)
;
--
-- INDEX: UI_EXPRMT_CONTEXT_ORDER
--

CREATE UNIQUE INDEX UI_EXPRMT_CONTEXT_ORDER ON EXPRMT_CONTEXT(EXPERIMENT_ID, DISPLAY_ORDER)
;
--
-- INDEX: UI_EXPRMT_CONTEXT_NAMES
--

CREATE UNIQUE INDEX UI_EXPRMT_CONTEXT_NAMES ON EXPRMT_CONTEXT(EXPERIMENT_ID, CONTEXT_GROUP, CONTEXT_NAME)
;
--
-- INDEX: FK_EXPRMT_CONTEXT_EXPRMT
--

CREATE INDEX FK_EXPRMT_CONTEXT_EXPRMT ON EXPRMT_CONTEXT(EXPERIMENT_ID)
;
--
-- INDEX: FK_E_CONTEXT_ITEM_EXPRMT_CNTXT
--

CREATE INDEX FK_E_CONTEXT_ITEM_EXPRMT_CNTXT ON EXPRMT_CONTEXT_ITEM(EXPRMT_CONTEXT_ID)
;
--
-- INDEX: FK_E_CONTEXT_ITEM_ATTRIBUTE
--

CREATE INDEX FK_E_CONTEXT_ITEM_ATTRIBUTE ON EXPRMT_CONTEXT_ITEM(ATTRIBUTE_ID)
;
--
-- INDEX: FK_E_CONTEXT_ITEM_VALUE
--

CREATE INDEX FK_E_CONTEXT_ITEM_VALUE ON EXPRMT_CONTEXT_ITEM(VALUE_ID)
;
--
-- INDEX: UI_EXPRMT_CONTEXT_ITEM_ORDR
--

CREATE INDEX UI_EXPRMT_CONTEXT_ITEM_ORDR ON EXPRMT_CONTEXT_ITEM(EXPRMT_CONTEXT_ID, DISPLAY_ORDER)
;
--
-- INDEX: FK_EXPRMT_MEASURE_PARENT
--

CREATE INDEX FK_EXPRMT_MEASURE_PARENT ON EXPRMT_MEASURE(PARENT_CHILD_RELATIONSHIP)
;
--
-- INDEX: FK_EXPRMT_MEASURE_EXPRMT
--

CREATE INDEX FK_EXPRMT_MEASURE_EXPRMT ON EXPRMT_MEASURE(EXPERIMENT_ID)
;
--
-- INDEX: FK_EXPRMT_MEASURE_MEASURE
--

CREATE INDEX FK_EXPRMT_MEASURE_MEASURE ON EXPRMT_MEASURE(MEASURE_ID)
;
--
-- INDEX: IDX_EXT_ONTOLOGY_TREE_ELMNT_ID
--

CREATE INDEX IDX_EXT_ONTOLOGY_TREE_ELMNT_ID ON EXT_ONTOLOGY_TREE(ELEMENT_ID)
;
--
-- INDEX: IDX_EXT_ONTOLOGY_TREE_LABEL
--

CREATE INDEX IDX_EXT_ONTOLOGY_TREE_LABEL ON EXT_ONTOLOGY_TREE(LABEL)
;
--
-- INDEX: FK_EXT_ONTOLOGY_TREE_PARENT
--

CREATE INDEX FK_EXT_ONTOLOGY_TREE_PARENT ON EXT_ONTOLOGY_TREE(PARENT_NODE_ID)
;
--
-- INDEX: FK_EXT_REFERENCE_EXPERIMENT
--

CREATE INDEX FK_EXT_REFERENCE_EXPERIMENT ON EXTERNAL_REFERENCE(EXPERIMENT_ID)
;
--
-- INDEX: FK_EXT_REFERENCE_EXT_SYSTEM
--

CREATE INDEX FK_EXT_REFERENCE_EXT_SYSTEM ON EXTERNAL_REFERENCE(EXTERNAL_SYSTEM_ID)
;
--
-- INDEX: FK_EXT_REFERENCE_PROJECT
--

CREATE INDEX FK_EXT_REFERENCE_PROJECT ON EXTERNAL_REFERENCE(PROJECT_ID)
;
--
-- INDEX: AK_EXT_REFERENCE
--

CREATE UNIQUE INDEX AK_EXT_REFERENCE ON EXTERNAL_REFERENCE(EXTERNAL_SYSTEM_ID, EXPERIMENT_ID, PROJECT_ID, EXT_ASSAY_REF)
;
--
-- INDEX: FK_FCTR_CMPNNT_LEVEL_FACTOR
--

CREATE INDEX FK_FCTR_CMPNNT_LEVEL_FACTOR ON FACTOR_COMPONENT(CONFIDENCE_LEVEL_FACTOR_ID)
;
--
-- INDEX: AK_FAVORITE
--

CREATE UNIQUE INDEX AK_FAVORITE ON FAVORITE(PERSON_ID, FAVORITE_NAME)
;
--
-- INDEX: FK_FAVORITE_PERSON
--

CREATE INDEX FK_FAVORITE_PERSON ON FAVORITE(PERSON_ID)
;
--
-- INDEX: IDX_IDENTIFIER_MAPPING_TARGET
--

CREATE INDEX IDX_IDENTIFIER_MAPPING_TARGET ON IDENTIFIER_MAPPING(TARGET_ID, "TABLE_NAME")
;
--
-- INDEX: FK_INSTANCE_DESCRIPTR_PRNT_SLF
--

CREATE INDEX FK_INSTANCE_DESCRIPTR_PRNT_SLF ON Instance_Descriptor_tree(PARENT_NODE_ID)
;
--
-- INDEX: FK_MEASURE_RESULT_TYPE
--

CREATE INDEX FK_MEASURE_RESULT_TYPE ON MEASURE(RESULT_TYPE_ID)
;
--
-- INDEX: FK_MEASURE_ASSAY
--

CREATE INDEX FK_MEASURE_ASSAY ON MEASURE(ASSAY_ID)
;
--
-- INDEX: FK_MEASURE_PARENT_MEASURE_ID
--

CREATE INDEX FK_MEASURE_PARENT_MEASURE_ID ON MEASURE(PARENT_MEASURE_ID)
;
--
-- INDEX: AK_MEASURE
--

CREATE UNIQUE INDEX AK_MEASURE ON MEASURE(ASSAY_ID, RESULT_TYPE_ID, Stats_Modifier_ID, PARENT_MEASURE_ID)
;
--
-- INDEX: FK_MEASURE_STATS_MODIFIER
--

CREATE INDEX FK_MEASURE_STATS_MODIFIER ON MEASURE(Stats_Modifier_ID)
;
--
-- INDEX: IDX_MIG_ACTION
--

CREATE INDEX IDX_MIG_ACTION ON MIGRATION_ACTION(COMPLETED_ACTION)
;
--
-- INDEX: IDX_MIG_COUNT_NAME
--

CREATE INDEX IDX_MIG_COUNT_NAME ON MIGRATION_ACTION(COUNT_NAME)
;
--
-- INDEX: IDX_AID_CATEGORY
--

CREATE INDEX IDX_AID_CATEGORY ON MIGRATION_AID(BAO_ANNOTATED)
;
--
-- INDEX: IDX_AID_CENTER
--

CREATE INDEX IDX_AID_CENTER ON MIGRATION_AID(CENTER)
;
--
-- INDEX: IDX_MIG_YEAR
--

CREATE INDEX IDX_MIG_YEAR ON MIGRATION_DAY("YEAR")
;
--
-- INDEX: IDX_MIG_DATE
--

CREATE INDEX IDX_MIG_DATE ON MIGRATION_DAY(MIGRATION_DATE)
;
--
-- INDEX: IDX_MIG_MONTH
--

CREATE INDEX IDX_MIG_MONTH ON MIGRATION_DAY("MONTH")
;
--
-- INDEX: IDX_MIG_QUARTER
--

CREATE INDEX IDX_MIG_QUARTER ON MIGRATION_DAY(QUARTER)
;
--
-- INDEX: IDX_MIG_WEEK
--

CREATE INDEX IDX_MIG_WEEK ON MIGRATION_DAY(WEEK)
;
--
-- INDEX: IDX_MIG_DAY_OF_WEEK
--

CREATE INDEX IDX_MIG_DAY_OF_WEEK ON MIGRATION_DAY(DAY_OF_WEEK)
;
--
-- INDEX: IDX_MIG_ASSAY
--

CREATE INDEX IDX_MIG_ASSAY ON MIGRATION_EVENT(ASSAY_ID)
;
--
-- INDEX: IDX_MIG_EXPERIMENT
--

CREATE INDEX IDX_MIG_EXPERIMENT ON MIGRATION_EVENT(EXPERIMENT_ID)
;
--
-- INDEX: IDX_MIG_PROJECT
--

CREATE INDEX IDX_MIG_PROJECT ON MIGRATION_EVENT(PROJECT_ID)
;
--
-- INDEX: FK_EVENT_ACTION
--

CREATE INDEX FK_EVENT_ACTION ON MIGRATION_EVENT(ACTION_REF)
;
--
-- INDEX: FK_EVENT_PERSON
--

CREATE INDEX FK_EVENT_PERSON ON MIGRATION_EVENT(PERSON_REF)
;
--
-- INDEX: FK_EVENT_DAY
--

CREATE INDEX FK_EVENT_DAY ON MIGRATION_EVENT(DAY_REF)
;
--
-- INDEX: IDX_MIG_PERSON
--

CREATE INDEX IDX_MIG_PERSON ON MIGRATION_PERSON(PERSON_NAME)
;
--
-- INDEX: FK_ONTOLOGY_ITEM_ONTOLOGY
--

CREATE INDEX FK_ONTOLOGY_ITEM_ONTOLOGY ON ONTOLOGY_ITEM(ONTOLOGY_ID)
;
--
-- INDEX: FK_ONTOLOGY_ITEM_ELEMENT
--

CREATE INDEX FK_ONTOLOGY_ITEM_ELEMENT ON ONTOLOGY_ITEM(ELEMENT_ID)
;
--
-- INDEX: AK_PERSON
--

CREATE UNIQUE INDEX AK_PERSON ON PERSON(USERNAME)
;
--
-- INDEX: AK_PERSON_ROLE
--

CREATE UNIQUE INDEX AK_PERSON_ROLE ON PERSON_ROLE(ROLE_ID, PERSON_ID)
;
--
-- INDEX: FK_PERSON_ROLE_PERSON
--

CREATE INDEX FK_PERSON_ROLE_PERSON ON PERSON_ROLE(PERSON_ID)
;
--
-- INDEX: FK_PERSON_ROLE_ROLE
--

CREATE INDEX FK_PERSON_ROLE_ROLE ON PERSON_ROLE(ROLE_ID)
;
--
-- INDEX: FK_PRJCT_EXPRMT_CNTXT_ITM_ATTR
--

CREATE INDEX FK_PRJCT_EXPRMT_CNTXT_ITM_ATTR ON PRJCT_EXPRMT_CNTXT_ITEM(ATTRIBUTE_ID)
;
--
-- INDEX: FK_PRJCT_EXPRMT_CNTXT_ITM_VAL
--

CREATE INDEX FK_PRJCT_EXPRMT_CNTXT_ITM_VAL ON PRJCT_EXPRMT_CNTXT_ITEM(VALUE_ID)
;
--
-- INDEX: FK_PRJCT_EXPRMT_CNTXT_ITM_CNTX
--

CREATE INDEX FK_PRJCT_EXPRMT_CNTXT_ITM_CNTX ON PRJCT_EXPRMT_CNTXT_ITEM(PRJCT_EXPRMT_CONTEXT_ID)
;
--
-- INDEX: UI_PRJCT_EXPRMT_CNTXT_ITM_ORDR
--

CREATE UNIQUE INDEX UI_PRJCT_EXPRMT_CNTXT_ITM_ORDR ON PRJCT_EXPRMT_CNTXT_ITEM(PRJCT_EXPRMT_CONTEXT_ID, DISPLAY_ORDER)
;
--
-- INDEX: FK_PRJ_EXPRMT_CNTXT_PRJ_EXPRMT
--

CREATE INDEX FK_PRJ_EXPRMT_CNTXT_PRJ_EXPRMT ON PRJCT_EXPRMT_CONTEXT(PROJECT_EXPERIMENT_ID)
;
--
-- INDEX: UI_PRRJCT_EXPRMT_CNTXT_ORDER
--

CREATE UNIQUE INDEX UI_PRRJCT_EXPRMT_CNTXT_ORDER ON PRJCT_EXPRMT_CONTEXT(PROJECT_EXPERIMENT_ID, DISPLAY_ORDER)
;
--
-- INDEX: UI_PRJCT_EXPRMT_CNTXT_NAMES
--

CREATE UNIQUE INDEX UI_PRJCT_EXPRMT_CNTXT_NAMES ON PRJCT_EXPRMT_CONTEXT(PROJECT_EXPERIMENT_ID, CONTEXT_GROUP, CONTEXT_NAME)
;
--
-- INDEX: FK_PROJECT_CONTEXT_PROJECT
--

CREATE INDEX FK_PROJECT_CONTEXT_PROJECT ON PROJECT_CONTEXT(PROJECT_ID)
;
--
-- INDEX: UI_PROJECT_CONTEXT_ORDER
--

CREATE UNIQUE INDEX UI_PROJECT_CONTEXT_ORDER ON PROJECT_CONTEXT(PROJECT_ID, DISPLAY_ORDER)
;
--
-- INDEX: UI_PROJECT_CONTEXT_NAMES
--

CREATE UNIQUE INDEX UI_PROJECT_CONTEXT_NAMES ON PROJECT_CONTEXT(PROJECT_ID, Context_Group, CONTEXT_NAME)
;
--
-- INDEX: FK_PRJCT_CNTXT_ITEM_ATTRIBUTE
--

CREATE INDEX FK_PRJCT_CNTXT_ITEM_ATTRIBUTE ON Project_Context_Item(ATTRIBUTE_ID)
;
--
-- INDEX: FK_PRJCT_CNTXT_ITEM_VALUE
--

CREATE INDEX FK_PRJCT_CNTXT_ITEM_VALUE ON Project_Context_Item(VALUE_ID)
;
--
-- INDEX: FK_PRJCT_CNTXT_ITEM_PRCT_CNTXT
--

CREATE INDEX FK_PRJCT_CNTXT_ITEM_PRCT_CNTXT ON Project_Context_Item(PROJECT_CONTEXT_ID)
;
--
-- INDEX: UI_PRJCT_CNTXT_ITEM_ORDR
--

CREATE UNIQUE INDEX UI_PRJCT_CNTXT_ITEM_ORDR ON Project_Context_Item(PROJECT_CONTEXT_ID, DISPLAY_ORDER)
;
--
-- INDEX: FK_PROJECT_DOCUMENT_PROJECT
--

CREATE INDEX FK_PROJECT_DOCUMENT_PROJECT ON PROJECT_DOCUMENT(PROJECT_ID)
;
--
-- INDEX: FK_PRJCT_EXPRMT_EXPERIMENT
--

CREATE INDEX FK_PRJCT_EXPRMT_EXPERIMENT ON PROJECT_EXPERIMENT(EXPERIMENT_ID)
;
--
-- INDEX: FK_PRJCT_EXPRMT_PROJECT
--

CREATE INDEX FK_PRJCT_EXPRMT_PROJECT ON PROJECT_EXPERIMENT(PROJECT_ID)
;
--
-- INDEX: FK_PRJCT_EXPRMT_STAGE
--

CREATE INDEX FK_PRJCT_EXPRMT_STAGE ON PROJECT_EXPERIMENT(STAGE_ID)
;
--
-- INDEX: FK_PRJCT_STEP_NXT_PRJCT_EXPRMT
--

CREATE INDEX FK_PRJCT_STEP_NXT_PRJCT_EXPRMT ON Project_Step(NEXT_PROJECT_EXPERIMENT_ID)
;
--
-- INDEX: FK_PRJCT_STEP_PRV_PRJCT_EXPRMT
--

CREATE INDEX FK_PRJCT_STEP_PRV_PRJCT_EXPRMT ON Project_Step(PREV_PROJECT_EXPERIMENT_ID)
;
--
-- INDEX: FK_RESULT_EXPERIMENT
--

CREATE BITMAP INDEX FK_RESULT_EXPERIMENT ON RESULT(EXPERIMENT_ID)
;
--
-- INDEX: FK_RESULT_RESULT_TYPE
--

CREATE BITMAP INDEX FK_RESULT_RESULT_TYPE ON RESULT(RESULT_TYPE_ID)
;
--
-- INDEX: FK_RESULT_STATS_MODIFIER
--

CREATE INDEX FK_RESULT_STATS_MODIFIER ON RESULT(STATS_MODIFIER_ID)
;
--
-- INDEX: IDX_RESULT_MAP_CONTEXTITEM
--

CREATE INDEX IDX_RESULT_MAP_CONTEXTITEM ON RESULT_MAP(CONTEXTITEM)
;
--
-- INDEX: IDX_RESULT_MAP_RESULTTYPE
--

CREATE INDEX IDX_RESULT_MAP_RESULTTYPE ON RESULT_MAP(RESULTTYPE)
;
--
-- INDEX: FK_RESULT_TYPE_PARENT_SELF
--

CREATE INDEX FK_RESULT_TYPE_PARENT_SELF ON Result_type_tree(Parent_node_id)
;
--
-- INDEX: IDX_RESULT_TYPE_TREE_UNIT
--

CREATE INDEX IDX_RESULT_TYPE_TREE_UNIT ON Result_type_tree(RESULT_TYPE_NAME)
;
--
-- INDEX: IDX_RESULT_TYPE_TREE_ELEM_ID
--

CREATE INDEX IDX_RESULT_TYPE_TREE_ELEM_ID ON Result_type_tree(RESULT_TYPE_ID)
;
--
-- INDEX: AK_ROLE
--

CREATE UNIQUE INDEX AK_ROLE ON "ROLE"(AUTHORITY)
;
--
-- INDEX: FK_R_CONTEXT_ITEM_RESULT
--

CREATE INDEX FK_R_CONTEXT_ITEM_RESULT ON Rslt_Context_Item(RESULT_ID)
;
--
-- INDEX: FK_R_CONTEXT_ITEM_ATTRIBUTE
--

CREATE INDEX FK_R_CONTEXT_ITEM_ATTRIBUTE ON Rslt_Context_Item(ATTRIBUTE_ID)
;
--
-- INDEX: FK_R_CONTEXT_ITEM_VALUE
--

CREATE INDEX FK_R_CONTEXT_ITEM_VALUE ON Rslt_Context_Item(VALUE_ID)
;
--
-- INDEX: UI_RSLT_CONTEXT_ITEM_ORDR
--

CREATE UNIQUE INDEX UI_RSLT_CONTEXT_ITEM_ORDR ON Rslt_Context_Item(RESULT_ID, DISPLAY_ORDER)
;
--
-- INDEX: UI_RSLT_CONTEXT_ITEM_ATTR
--

CREATE UNIQUE INDEX UI_RSLT_CONTEXT_ITEM_ATTR ON Rslt_Context_Item(RESULT_ID, ATTRIBUTE_ID)
;
--
-- INDEX: FK_STATS_MODIFIER_PARENT
--

CREATE INDEX FK_STATS_MODIFIER_PARENT ON STATS_MODIFIER_TREE(PARENT_NODE_ID)
;
--
-- INDEX: IDX_STATS_MODIFIER_UNIT
--

CREATE INDEX IDX_STATS_MODIFIER_UNIT ON STATS_MODIFIER_TREE(LABEL)
;
--
-- INDEX: FK_STEP_CONTEXT_PRJCT_STEP
--

CREATE INDEX FK_STEP_CONTEXT_PRJCT_STEP ON STEP_CONTEXT(Project_Step_ID)
;
--
-- INDEX: UI_STEP_CONTEXT_ORDER
--

CREATE UNIQUE INDEX UI_STEP_CONTEXT_ORDER ON STEP_CONTEXT(Project_Step_ID, DISPLAY_ORDER)
;
--
-- INDEX: UI_STEP_CONTEXT_NAMES
--

CREATE UNIQUE INDEX UI_STEP_CONTEXT_NAMES ON STEP_CONTEXT(Project_Step_ID, Context_Group, CONTEXT_NAME)
;
--
-- INDEX: FK_STEP_ITEM_STEP_CONTEXT
--

CREATE INDEX FK_STEP_ITEM_STEP_CONTEXT ON STEP_CONTEXT_ITEM(STEP_CONTEXT_ID)
;
--
-- INDEX: FK_STEP_ITEM_ATTRIBUTE
--

CREATE INDEX FK_STEP_ITEM_ATTRIBUTE ON STEP_CONTEXT_ITEM(ATTRIBUTE_ID)
;
--
-- INDEX: FK_STEP_ITEM_VALUE
--

CREATE INDEX FK_STEP_ITEM_VALUE ON STEP_CONTEXT_ITEM(VALUE_ID)
;
--
-- INDEX: UI_STEP_CONTEXT_ITEM_ORDR
--

CREATE UNIQUE INDEX UI_STEP_CONTEXT_ITEM_ORDR ON STEP_CONTEXT_ITEM(STEP_CONTEXT_ID, DISPLAY_ORDER)
;
--
-- INDEX: AK_TEAM_MEMBER
--

CREATE UNIQUE INDEX AK_TEAM_MEMBER ON TEAM_MEMBER(TEAM_ID, PERSON_ROLE_ID)
;
--
-- INDEX: FK_TEAM_MEMBER_TEAM
--

CREATE INDEX FK_TEAM_MEMBER_TEAM ON TEAM_MEMBER(TEAM_ID)
;
--
-- INDEX: FK_TEAM_MEMBER_PERSON_ROLE
--

CREATE INDEX FK_TEAM_MEMBER_PERSON_ROLE ON TEAM_MEMBER(PERSON_ROLE_ID)
;
--
-- INDEX: AK_TREE_ROOT_NAME
--

CREATE UNIQUE INDEX AK_TREE_ROOT_NAME ON TREE_ROOT(TREE_NAME)
;
--
-- INDEX: FK_TREE_ROOT_ELEMENT
--

CREATE INDEX FK_TREE_ROOT_ELEMENT ON TREE_ROOT(ELEMENT_ID)
;
--
-- INDEX: FK_UNIT_PARENT_SELF
--

CREATE INDEX FK_UNIT_PARENT_SELF ON Unit_tree(PARENT_NODE_ID)
;
--
-- INDEX: IDX_UNIT_TREE_UNIT
--

CREATE INDEX IDX_UNIT_TREE_UNIT ON Unit_tree(UNIT)
;
--
-- TABLE: ELEMENT
--

ALTER TABLE ELEMENT ADD
    CONSTRAINT AK_ELEMENT_LABEL UNIQUE (LABEL)
;

--
-- TABLE: ELEMENT
--

ALTER TABLE ELEMENT ADD
    CONSTRAINT AK_ELEMENT_BARD_URI UNIQUE (BARD_URI)
;

--
-- TABLE: TEAM
--

ALTER TABLE TEAM ADD
    CONSTRAINT AK_TEAM UNIQUE (TEAM_NAME)
;

--
-- TABLE: UNIT_CONVERSION
--

ALTER TABLE UNIT_CONVERSION ADD
    CONSTRAINT AK_UNIT_CONVERSION UNIQUE (FROM_UNIT_ID, TO_UNIT_ID)
;

--
-- TABLE: ASSAY
--

ALTER TABLE ASSAY ADD CONSTRAINT FK_ASSAY_TEAM
    FOREIGN KEY (DESIGNED_BY)
    REFERENCES TEAM(TEAM_NAME)
;


--
-- TABLE: Assay_Context
--

ALTER TABLE Assay_Context ADD CONSTRAINT FK_Assay_Context_Assay
    FOREIGN KEY (ASSAY_ID)
    REFERENCES ASSAY(ASSAY_ID)
;


--
-- TABLE: Assay_Context_Item
--

ALTER TABLE Assay_Context_Item ADD CONSTRAINT FK_A_context_Item_A_Context
    FOREIGN KEY (Assay_Context_ID)
    REFERENCES Assay_Context(Assay_Context_ID)
;

ALTER TABLE Assay_Context_Item ADD CONSTRAINT FK_A_context_item_attribute
    FOREIGN KEY (ATTRIBUTE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE Assay_Context_Item ADD CONSTRAINT FK_A_CONTEXT_ITEM_VALUE
    FOREIGN KEY (VALUE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: ASSAY_CONTEXT_MEASURE
--

ALTER TABLE ASSAY_CONTEXT_MEASURE ADD CONSTRAINT FK_ACM_ASSAY_CONTEXT
    FOREIGN KEY (Assay_Context_ID)
    REFERENCES Assay_Context(Assay_Context_ID) ON DELETE CASCADE
;

ALTER TABLE ASSAY_CONTEXT_MEASURE ADD CONSTRAINT FK_ACM_MEASURE
    FOREIGN KEY (MEASURE_ID)
    REFERENCES MEASURE(MEASURE_ID) ON DELETE CASCADE
;


--
-- TABLE: Assay_Descriptor_Tree
--

ALTER TABLE Assay_Descriptor_Tree ADD CONSTRAINT FK_ASSAY_DESCRIPTOR_PARENT_SLF
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES Assay_Descriptor_Tree(NODE_ID)
;


--
-- TABLE: ASSAY_DOCUMENT
--

ALTER TABLE ASSAY_DOCUMENT ADD CONSTRAINT FK_Assay_document_assay
    FOREIGN KEY (ASSAY_ID)
    REFERENCES ASSAY(ASSAY_ID)
;


--
-- TABLE: AUDIT_COLUMN_LOG
--

ALTER TABLE AUDIT_COLUMN_LOG ADD CONSTRAINT FK_AUDIT_COLUMN_AUDIT_ROW_LOG
    FOREIGN KEY (AUDIT_ID)
    REFERENCES AUDIT_ROW_LOG(AUDIT_ID)
;


--
-- TABLE: BARD_TREE
--

ALTER TABLE BARD_TREE ADD CONSTRAINT FK_BARD_TREE_PARENT
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES BARD_TREE(NODE_ID)
;


--
-- TABLE: Biology_Descriptor_tree
--

ALTER TABLE Biology_Descriptor_tree ADD CONSTRAINT FK_BIOLOGY_DESCRIPTOR_PRNT_SLF
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES Biology_Descriptor_tree(NODE_ID)
;


--
-- TABLE: CONFIDENCE_LEVEL_SCORE
--

ALTER TABLE CONFIDENCE_LEVEL_SCORE ADD CONSTRAINT FK_CNFDNC_LVL_SCORE_EXPRMT
    FOREIGN KEY (EXPERIMENT_ID)
    REFERENCES EXPERIMENT(EXPERIMENT_ID) ON DELETE CASCADE
;

ALTER TABLE CONFIDENCE_LEVEL_SCORE ADD CONSTRAINT FK_CNFDNC_LVL_SCORE_FACTOR
    FOREIGN KEY (CONFIDENCE_LEVEL_FACTOR_ID)
    REFERENCES CONFIDENCE_LEVEL_FACTOR(CONFIDENCE_LEVEL_FACTOR_ID)
;


--
-- TABLE: DICTIONARY_TREE
--

ALTER TABLE DICTIONARY_TREE ADD CONSTRAINT FK_DICTIONARY_TREE_PARENT
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES DICTIONARY_TREE(NODE_ID)
;


--
-- TABLE: ELEMENT
--

ALTER TABLE ELEMENT ADD CONSTRAINT FK_Element_Unit
    FOREIGN KEY (UNIT_ID)
    REFERENCES ELEMENT(ELEMENT_ID)  DEFERRABLE INITIALLY DEFERRED
;


--
-- TABLE: ELEMENT_HIERARCHY
--

ALTER TABLE ELEMENT_HIERARCHY ADD CONSTRAINT FK_E_HIERARCHY_CHILD_ELEM_ID
    FOREIGN KEY (CHILD_ELEMENT_ID)
    REFERENCES ELEMENT(ELEMENT_ID) ON DELETE CASCADE
;

ALTER TABLE ELEMENT_HIERARCHY ADD CONSTRAINT FK_E_HIERARCHY_PARENT_ELEM_ID
    FOREIGN KEY (PARENT_ELEMENT_ID)
    REFERENCES ELEMENT(ELEMENT_ID) ON DELETE CASCADE
;


--
-- TABLE: EXPERIMENT
--

ALTER TABLE EXPERIMENT ADD CONSTRAINT FK_EXPERIMENT_ASSAY
    FOREIGN KEY (ASSAY_ID)
    REFERENCES ASSAY(ASSAY_ID)
;


--
-- TABLE: EXPERIMENT_FILE
--

ALTER TABLE EXPERIMENT_FILE ADD CONSTRAINT FK_EXPERIMENT_FILE
    FOREIGN KEY (EXPERIMENT_ID)
    REFERENCES EXPERIMENT(EXPERIMENT_ID)
;


--
-- TABLE: EXPRMT_CONTEXT
--

ALTER TABLE EXPRMT_CONTEXT ADD CONSTRAINT FK_E_CNTXT_EXPERIMENT
    FOREIGN KEY (EXPERIMENT_ID)
    REFERENCES EXPERIMENT(EXPERIMENT_ID)
;


--
-- TABLE: EXPRMT_CONTEXT_ITEM
--

ALTER TABLE EXPRMT_CONTEXT_ITEM ADD CONSTRAINT FK_E_CNTXT_ITM_ATTRIBUTE
    FOREIGN KEY (ATTRIBUTE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE EXPRMT_CONTEXT_ITEM ADD CONSTRAINT FK_E_CNTXT_ITM_EXPRMT_CNTXT
    FOREIGN KEY (EXPRMT_CONTEXT_ID)
    REFERENCES EXPRMT_CONTEXT(EXPRMT_CONTEXT_ID)
;

ALTER TABLE EXPRMT_CONTEXT_ITEM ADD CONSTRAINT FK_E_CNTXT_ITM_VALUE
    FOREIGN KEY (VALUE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: EXPRMT_MEASURE
--

ALTER TABLE EXPRMT_MEASURE ADD CONSTRAINT FK_EXPRMT_MEASURE_EXPRMT
    FOREIGN KEY (EXPERIMENT_ID)
    REFERENCES EXPERIMENT(EXPERIMENT_ID)
;

ALTER TABLE EXPRMT_MEASURE ADD CONSTRAINT FK_EXPRMT_MEASURE_MEASURE
    FOREIGN KEY (MEASURE_ID)
    REFERENCES MEASURE(MEASURE_ID)
;

ALTER TABLE EXPRMT_MEASURE ADD CONSTRAINT FK_EXPRMT_MEASURE_PARENT
    FOREIGN KEY (PARENT_EXPRMT_MEASURE_ID)
    REFERENCES EXPRMT_MEASURE(EXPRMT_MEASURE_ID)  DEFERRABLE INITIALLY DEFERRED
;


--
-- TABLE: EXT_ONTOLOGY_TREE
--

ALTER TABLE EXT_ONTOLOGY_TREE ADD CONSTRAINT FK_EXT_ONTOLOGY_TREE_PARENT
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES EXT_ONTOLOGY_TREE(NODE_ID)
;


--
-- TABLE: EXTERNAL_REFERENCE
--

ALTER TABLE EXTERNAL_REFERENCE ADD CONSTRAINT FK_EXT_REFERENCE_EXPERIMENT
    FOREIGN KEY (EXPERIMENT_ID)
    REFERENCES EXPERIMENT(EXPERIMENT_ID)
;

ALTER TABLE EXTERNAL_REFERENCE ADD CONSTRAINT FK_EXT_REFERENCE_EXT_SYSTEM
    FOREIGN KEY (EXTERNAL_SYSTEM_ID)
    REFERENCES EXTERNAL_SYSTEM(EXTERNAL_SYSTEM_ID)
;

ALTER TABLE EXTERNAL_REFERENCE ADD CONSTRAINT FK_EXT_REFERENCE_PROJECT
    FOREIGN KEY (PROJECT_ID)
    REFERENCES PROJECT(PROJECT_ID)
;


--
-- TABLE: FACTOR_COMPONENT
--

ALTER TABLE FACTOR_COMPONENT ADD CONSTRAINT FK_FCTR_CMPNNT_LEVEL_FACTOR
    FOREIGN KEY (CONFIDENCE_LEVEL_FACTOR_ID)
    REFERENCES CONFIDENCE_LEVEL_FACTOR(CONFIDENCE_LEVEL_FACTOR_ID)
;


--
-- TABLE: FAVORITE
--

ALTER TABLE FAVORITE ADD CONSTRAINT FK_FAVORITE_PERSON
    FOREIGN KEY (PERSON_ID)
    REFERENCES PERSON(PERSON_ID)
;


--
-- TABLE: Instance_Descriptor_tree
--

ALTER TABLE Instance_Descriptor_tree ADD CONSTRAINT FK_INSTANCE_DESCRIPTR_PRNT_SLF
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES Instance_Descriptor_tree(NODE_ID)
;


--
-- TABLE: Laboratory_tree
--

ALTER TABLE Laboratory_tree ADD CONSTRAINT FK_LABORATORY_PARENT_NODE_ID
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES Laboratory_tree(NODE_ID)
;


--
-- TABLE: MEASURE
--

ALTER TABLE MEASURE ADD CONSTRAINT FK_MEASURE_ASSAY
    FOREIGN KEY (ASSAY_ID)
    REFERENCES ASSAY(ASSAY_ID)
;

ALTER TABLE MEASURE ADD CONSTRAINT FK_Measure_Element_Unit
    FOREIGN KEY (ENTRY_UNIT_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE MEASURE ADD CONSTRAINT FK_MEASURE_PARENT_MEASURE_ID
    FOREIGN KEY (PARENT_MEASURE_ID)
    REFERENCES MEASURE(MEASURE_ID)  DEFERRABLE INITIALLY DEFERRED
;

ALTER TABLE MEASURE ADD CONSTRAINT FK_MEASURE_RESULT_TYPE
    FOREIGN KEY (RESULT_TYPE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE MEASURE ADD CONSTRAINT FK_MEASURE_STATS_MODIFIER
    FOREIGN KEY (Stats_Modifier_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: MIGRATION_EVENT
--

ALTER TABLE MIGRATION_EVENT ADD CONSTRAINT FK_EVENT_ACTION
    FOREIGN KEY (ACTION_REF)
    REFERENCES MIGRATION_ACTION(ACTION_REF)
;

ALTER TABLE MIGRATION_EVENT ADD CONSTRAINT FK_EVENT_DAY
    FOREIGN KEY (DAY_REF)
    REFERENCES MIGRATION_DAY(DAY_REF)
;

ALTER TABLE MIGRATION_EVENT ADD CONSTRAINT FK_EVENT_PERSON
    FOREIGN KEY (PERSON_REF)
    REFERENCES MIGRATION_PERSON(PERSON_REF)
;


--
-- TABLE: ONTOLOGY_ITEM
--

ALTER TABLE ONTOLOGY_ITEM ADD CONSTRAINT FK_ONTOLOGY_ITEM_ELEMENT
    FOREIGN KEY (ELEMENT_ID)
    REFERENCES ELEMENT(ELEMENT_ID) ON DELETE CASCADE
;

ALTER TABLE ONTOLOGY_ITEM ADD CONSTRAINT FK_ONTOLOGY_ITEM_ONTOLOGY
    FOREIGN KEY (ONTOLOGY_ID)
    REFERENCES ONTOLOGY(ONTOLOGY_ID)
;


--
-- TABLE: PERSON_ROLE
--

ALTER TABLE PERSON_ROLE ADD CONSTRAINT FK_PERSON_ROLE_PERSON
    FOREIGN KEY (PERSON_ID)
    REFERENCES PERSON(PERSON_ID)
;

ALTER TABLE PERSON_ROLE ADD CONSTRAINT FK_PERSON_ROLE_ROLE
    FOREIGN KEY (ROLE_ID)
    REFERENCES "ROLE"(ROLE_ID)
;


--
-- TABLE: PRJCT_EXPRMT_CNTXT_ITEM
--

ALTER TABLE PRJCT_EXPRMT_CNTXT_ITEM ADD CONSTRAINT FK_PRJ_EXPT_CNTXT_ITM_ATTR
    FOREIGN KEY (ATTRIBUTE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE PRJCT_EXPRMT_CNTXT_ITEM ADD CONSTRAINT FK_PRJ_EXPT_CNTXT_ITM_PRJ_EXPT
    FOREIGN KEY (PRJCT_EXPRMT_CONTEXT_ID)
    REFERENCES PRJCT_EXPRMT_CONTEXT(PRJCT_EXPRMT_CONTEXT_ID)
;

ALTER TABLE PRJCT_EXPRMT_CNTXT_ITEM ADD CONSTRAINT FK_PRJ_EXPT_CNTXT_ITM_VAL
    FOREIGN KEY (VALUE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: PRJCT_EXPRMT_CONTEXT
--

ALTER TABLE PRJCT_EXPRMT_CONTEXT ADD CONSTRAINT FK_PRJ_EXPT_CNTXT_PRJ_EXPRMT
    FOREIGN KEY (PROJECT_EXPERIMENT_ID)
    REFERENCES PROJECT_EXPERIMENT(PROJECT_EXPERIMENT_ID)
;


--
-- TABLE: PROJECT_CONTEXT
--

ALTER TABLE PROJECT_CONTEXT ADD CONSTRAINT FK_PRJCT_CNTXT_PROJECT
    FOREIGN KEY (PROJECT_ID)
    REFERENCES PROJECT(PROJECT_ID)
;


--
-- TABLE: Project_Context_Item
--

ALTER TABLE Project_Context_Item ADD CONSTRAINT FK_PRJCT_CNTXT_ITEM_ATTRIBUTE
    FOREIGN KEY (ATTRIBUTE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE Project_Context_Item ADD CONSTRAINT FK_PRJCT_CNTXT_ITEM_VALUE
    FOREIGN KEY (VALUE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE Project_Context_Item ADD CONSTRAINT FK_PRJCT_CNTXT_ITM_PRJCT_CNTXT
    FOREIGN KEY (PROJECT_CONTEXT_ID)
    REFERENCES PROJECT_CONTEXT(PROJECT_CONTEXT_ID)
;


--
-- TABLE: PROJECT_DOCUMENT
--

ALTER TABLE PROJECT_DOCUMENT ADD CONSTRAINT FK_PROJECT_DOCUMENT_PROJECT
    FOREIGN KEY (PROJECT_ID)
    REFERENCES PROJECT(PROJECT_ID)
;


--
-- TABLE: PROJECT_EXPERIMENT
--

ALTER TABLE PROJECT_EXPERIMENT ADD CONSTRAINT FK_PRJCT_EXPRMT_EXPERIMENT
    FOREIGN KEY (EXPERIMENT_ID)
    REFERENCES EXPERIMENT(EXPERIMENT_ID)
;

ALTER TABLE PROJECT_EXPERIMENT ADD CONSTRAINT FK_PRJCT_EXPRMT_PROJECT
    FOREIGN KEY (PROJECT_ID)
    REFERENCES PROJECT(PROJECT_ID)
;

ALTER TABLE PROJECT_EXPERIMENT ADD CONSTRAINT FK_PRJCT_EXPRMT_STAGE
    FOREIGN KEY (STAGE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: Project_Step
--

ALTER TABLE Project_Step ADD CONSTRAINT FK_PRJCT_STEP_NXT_PRJCT_EXPRMT
    FOREIGN KEY (NEXT_PROJECT_EXPERIMENT_ID)
    REFERENCES PROJECT_EXPERIMENT(PROJECT_EXPERIMENT_ID)
;

ALTER TABLE Project_Step ADD CONSTRAINT FK_PRJCT_STEP_PRV_PRJCT_EXPRMT
    FOREIGN KEY (PREV_PROJECT_EXPERIMENT_ID)
    REFERENCES PROJECT_EXPERIMENT(PROJECT_EXPERIMENT_ID)
;


--
-- TABLE: RESULT
--

ALTER TABLE RESULT ADD CONSTRAINT FK_RESULT_ELEMENT_VALUE
    FOREIGN KEY (Value_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE RESULT ADD CONSTRAINT FK_RESULT_EXPERIMENT
    FOREIGN KEY (EXPERIMENT_ID)
    REFERENCES EXPERIMENT(EXPERIMENT_ID)
;

ALTER TABLE RESULT ADD CONSTRAINT FK_RESULT_PARENT_RESULT
    FOREIGN KEY (PARENT_RESULT_ID)
    REFERENCES RESULT(RESULT_ID)
;

ALTER TABLE RESULT ADD CONSTRAINT FK_RESULT_RESULT_TYPE
    FOREIGN KEY (RESULT_TYPE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE RESULT ADD CONSTRAINT FK_RESULT_STATS_MODIFIER
    FOREIGN KEY (STATS_MODIFIER_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: Result_type_tree
--

ALTER TABLE Result_type_tree ADD CONSTRAINT FK_Result_Type_Parent_Self
    FOREIGN KEY (Parent_node_id)
    REFERENCES Result_type_tree(NODE_ID)
;


--
-- TABLE: Rslt_Context_Item
--

ALTER TABLE Rslt_Context_Item ADD CONSTRAINT FK_R_CONTEXT_ITEM_ATTRIBUTE
    FOREIGN KEY (ATTRIBUTE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE Rslt_Context_Item ADD CONSTRAINT FK_R_CONTEXT_ITEM_RESULT
    FOREIGN KEY (RESULT_ID)
    REFERENCES RESULT(RESULT_ID) ON DELETE CASCADE
;

ALTER TABLE Rslt_Context_Item ADD CONSTRAINT FK_R_CONTEXT_ITEM_VALUE
    FOREIGN KEY (VALUE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: Stage_tree
--

ALTER TABLE Stage_tree ADD CONSTRAINT FK_STAGE_PARENT_NODE_ID
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES Stage_tree(NODE_ID)
;


--
-- TABLE: STATS_MODIFIER_TREE
--

ALTER TABLE STATS_MODIFIER_TREE ADD CONSTRAINT FK_STATS_MODIFIER_PARENT
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES STATS_MODIFIER_TREE(NODE_ID)
;


--
-- TABLE: STEP_CONTEXT
--

ALTER TABLE STEP_CONTEXT ADD CONSTRAINT FK_STEP_CNTXT_STEP
    FOREIGN KEY (Project_Step_ID)
    REFERENCES Project_Step(Project_Step_ID)
;


--
-- TABLE: STEP_CONTEXT_ITEM
--

ALTER TABLE STEP_CONTEXT_ITEM ADD CONSTRAINT FK_STEP_CNTXT_ITEM_ATTR
    FOREIGN KEY (VALUE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE STEP_CONTEXT_ITEM ADD CONSTRAINT FK_STEP_CNTXT_ITEM_VALUE
    FOREIGN KEY (ATTRIBUTE_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;

ALTER TABLE STEP_CONTEXT_ITEM ADD CONSTRAINT FK_STEP_CNTXT_ITM_STEP_CNTXT
    FOREIGN KEY (STEP_CONTEXT_ID)
    REFERENCES STEP_CONTEXT(STEP_CONTEXT_ID)
;


--
-- TABLE: TEAM_MEMBER
--

ALTER TABLE TEAM_MEMBER ADD CONSTRAINT FK_TEAM_MEMBER_MEMBER_ROLE
    FOREIGN KEY (PERSON_ROLE_ID)
    REFERENCES PERSON_ROLE(PERSON_ROLE_ID)
;

ALTER TABLE TEAM_MEMBER ADD CONSTRAINT FK_TEAM_MEMBER_TEAM
    FOREIGN KEY (TEAM_ID)
    REFERENCES TEAM(TEAM_ID)
;


--
-- TABLE: TREE_ROOT
--

ALTER TABLE TREE_ROOT ADD CONSTRAINT FK_TREE_ROOT_ELEMENT
    FOREIGN KEY (ELEMENT_ID)
    REFERENCES ELEMENT(ELEMENT_ID)
;


--
-- TABLE: UNIT_CONVERSION
--

ALTER TABLE UNIT_CONVERSION ADD CONSTRAINT FK_UNIT_CONVERSN_FRM_UNT_ELMNT
    FOREIGN KEY (FROM_UNIT_ID)
    REFERENCES ELEMENT(ELEMENT_ID) ON DELETE CASCADE
;

ALTER TABLE UNIT_CONVERSION ADD CONSTRAINT FK_UNIT_CONVERSN_TO_UNT_ELMNT
    FOREIGN KEY (TO_UNIT_ID)
    REFERENCES ELEMENT(ELEMENT_ID) ON DELETE CASCADE
;


--
-- TABLE: Unit_tree
--

ALTER TABLE Unit_tree ADD CONSTRAINT FK_UNIT_PARENT_SELF
    FOREIGN KEY (PARENT_NODE_ID)
    REFERENCES Unit_tree(NODE_ID)
;


--
-- PROCEDURE: MAKE_PROJECTS
--

CREATE OR REPLACE PROCEDURE make_projects ( av_aid IN VARCHAR2 DEFAULT null)
AS
    CURSOR cur_project
    IS
    SELECT er_p.ext_assay_ref ext_assay_ref,
          er_p.external_reference_id proj_external_reference_id,
          er_p.project_id project_id,
          er_e.external_reference_id expt_external_reference_id,
          er_e.experiment_id experiment_id,
          e.assay_id assay_id
      FROM external_reference er_p,
          external_reference er_e,
          experiment e
      WHERE er_p.ext_assay_ref = er_e.ext_assay_ref
        AND er_p.project_id IS NOT NULL
        AND e.experiment_id = er_e.experiment_id
--        AND er_p.ext_assay_ref NOT IN ('aid=1393','aid=1400','aid=1401','aid=1464','aid=1842','aid=1844','aid=2248')
--        and er_p.ext_assay_ref NOT IN ('aid=1074','aid=1384','aid=1393','aid=1395','aid=1400','aid=1401','aid=1464',
--            'aid=1472','aid=1473','aid=1474','aid=1475','aid=1482','aid=1484','aid=1485','aid=1504','aid=1579','aid=1623',
--            'aid=1653','aid=1693','aid=1742','aid=1772','aid=1818','aid=1828','aid=1842','aid=1844','aid=1908','aid=1989',
--            'aid=1997','aid=2095','aid=2114','aid=2248','aid=2266','aid=2276','aid=2281','aid=2301','aid=2310','aid=2342',
--            'aid=2389','aid=2407','aid=2512','aid=2593','aid=2663','aid=488872','aid=488883','aid=488887','aid=504480',
--            'aid=588854')
      AND (er_p.ext_assay_REF = 'aid=' || REPLACE(Lower(av_aid), 'aid=', '')
           OR av_aid IS NULL);

   CURSOR cur_context_item (cn_assay_id NUMBER)
    IS
    SELECT assay_context_item_id,
          ASSAY_CONTEXT_ID,
          DISPLAY_ORDER,
          ATTRIBUTE_ID,
          VALUE_ID,
          EXT_VALUE_ID,
          QUALIFIER,
          VALUE_DISPLAY,
          VALUE_NUM,
          VALUE_MIN,
          VALUE_MAX,
          VERSION,
          DATE_CREATED,
          LAST_UPDATED,
          MODIFIED_BY
    FROM assay_context_item aci
    WHERE EXISTS (SELECT 1
          FROM assay_context ac
          WHERE ac.assay_context_id = aci.assay_context_id
            AND ac.assay_id = cn_assay_id);


    ln_project_id   NUMBER;
    ln_project_context_item_id    NUMBER;
    ln_project_context_id   NUMBER;

BEGIN
      FOR lr_project IN cur_project
      LOOP
          UPDATE project
          SET PROJECT_NAME = (SELECT assay_name
                        FROM assay WHERE assay_id = lr_project.assay_id),
            GROUP_TYPE = 'Project',
            DESCRIPTION = (SELECT assay_name
                        FROM assay WHERE assay_id = lr_project.assay_id),
            MODIFIED_BY = (SELECT Nvl(modified_by, 'southern')
                        FROM assay WHERE assay_id = lr_project.assay_id)
          WHERE project_id = lr_project.project_id;

          -- insert the project_documents
          DELETE FROM project_document
          WHERE project_id = lr_project.project_id;

          INSERT INTO project_document
              (project_document_id,
              project_id,
              document_name,
              document_type,
              document_content,
              version,
              date_created,
              last_updated,
              modified_by)
          SELECT project_document_id_seq.nextval,
              lr_project.project_id,
              document_name,
              document_type,
              document_content,
              version,
              date_created,
              SYSDATE last_updated,
              modified_by
          FROM assay_document
          WHERE assay_id = lr_project.assay_id;

          -- don't do anything with project_experiments as we're about to delete the experiments!

          -- transfer the assay_context_items to the project_context_items
          -- referencing the project (not the step)
--          DELETE FROM project_context_item
--          WHERE project_context_id IN (
--              SELECT project_context_id
--              FROM project_context
--              WHERE project_id = lr_project.project_id)
--           AND modified_by = 'southern';

--          delete FROM project_context pc
--           WHERE project_id = lr_project.project_id
--             AND NOT EXISTS (SELECT 1
--                FROM project_context_item pci
--                WHERE pci.project_context_id = pc.project_context_id);

          FOR lr_context_item IN cur_context_item (lr_project.assay_id)
          LOOP

               UPDATE project_context_item  pci
               SET value_display = lr_context_item.value_display
               WHERE EXISTS (SELECT 1
                  FROM project_context pc
                  WHERE pc.project_context_id = pci.project_context_id
                    AND pc.project_id = lr_project.project_id)
               AND attribute_id = lr_context_item.attribute_id
               AND (value_id = lr_context_item.value_id
                    OR
                    ext_value_id = lr_context_item.ext_value_id
                    OR (value_id IS NULL AND
                        ext_value_id IS NULL AND
                        lr_context_item.value_id IS NULL AND
                        lr_context_item.ext_value_id IS NULL));

              Dbms_Output.put_line ('update ' || To_Char(lr_context_item.assay_context_item_id) || ' rowcount=' || To_Char(SQL%ROWCOUNT));
               IF SQL%ROWCOUNT = 0
               THEN
                  -- create a new context and insert the context_item
                  SELECT project_context_id_seq.nextval
                  INTO ln_project_context_id
                  FROM dual;

                  INSERT INTO project_context pc
                      (PROJECT_CONTEXT_ID,
                      PROJECT_ID,
                      CONTEXT_NAME,
                      CONTEXT_GROUP,
                      DISPLAY_ORDER,
                      VERSION,
                      DATE_CREATED,
                      LAST_UPDATED,
                      MODIFIED_BY)
                  VALUES (ln_project_context_id,
                      lr_project.PROJECT_ID,
                      'New context',
                      '',
                      0,
                      0,
                      SYSDATE,
                      NULL,
                      'southern');

                  INSERT INTO project_context_item
                      (project_context_item_id,
                      display_order,
                      project_context_id,
                      attribute_id,
                      value_id,
                      ext_value_id,
                      qualifier,
                      value_display,
                      value_num,
                      value_min,
                      value_max,
                      version,
                      date_created,
                      last_updated,
                      modified_by)
                  SELECT project_context_item_id_seq.nextval,
                      lr_context_item.display_order,
                      ln_project_context_id,
                      lr_context_item.attribute_id,
                      lr_context_item.value_id,
                      lr_context_item.ext_value_id,
                      lr_context_item.qualifier,
                      lr_context_item.value_display,
                      lr_context_item.value_num,
                      lr_context_item.value_min,
                      lr_context_item.value_max,
                      lr_context_item.version + 1,
                      lr_context_item.date_created,
                      SYSDATE,
                      Nvl(lr_context_item.modified_by, 'southern')
                  FROM assay_context_item
                  WHERE assay_context_item_id = lr_context_item.assay_context_item_id;

               END IF;


           END LOOP;

         --  AND now the deletions
        Dbms_Output.put_line ('deletion for ' || lr_project.ext_assay_ref);

        IF lr_project.ext_assay_ref IN ('aid=1074','aid=1384','aid=1393','aid=1395','aid=1400','aid=1401','aid=1464',
            'aid=1472','aid=1473','aid=1474','aid=1475','aid=1482','aid=1484','aid=1485','aid=1504','aid=1579','aid=1623',
            'aid=1653','aid=1693','aid=1742','aid=1772','aid=1818','aid=1828','aid=1842','aid=1844','aid=1908','aid=1989',
            'aid=1997','aid=2095','aid=2114','aid=2248','aid=2266','aid=2276','aid=2281','aid=2301','aid=2310','aid=2342',
            'aid=2389','aid=2407','aid=2512','aid=2593','aid=2663','aid=488872','aid=488883','aid=488887','aid=504480',
            'aid=588854')
        THEN
            -- make a connection between this experiment and the project (through they're really the same thing)
            INSERT INTO project_experiment
                (PROJECT_EXPERIMENT_ID,
                EXPERIMENT_ID,
                PROJECT_ID,
                STAGE_ID,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            SELECT PROJECT_EXPERIMENT_ID_SEQ.nextval,
                lr_project.EXPERIMENT_ID,
                lr_project.PROJECT_ID,
                575 STAGE_ID,    --summary assay
                0 VERSION,
                SYSDATE DATE_CREATED,
                NULL LAST_UPDATED,
                'southern'  MODIFIED_BY
            FROM dual
            WHERE NOT EXISTS (SELECT 1
                    FROM project_experiment pe
                    WHERE pe.project_id = lr_project.project_id
                      AND pe.experiment_id = lr_project.experiment_id);

        ELSE
             -- check for relatives of experiment
            -- delete the experiment
             -- remap the external reference
            DELETE FROM external_reference
            WHERE external_reference_id = lr_project.expt_external_reference_id;

            -- delete the contexts
            DELETE FROM exprmt_context_item
            WHERE exprmt_context_id IN
                (SELECT exprmt_context_id
                FROM exprmt_context
                WHERE experiment_id = lr_project.experiment_id);

            DELETE FROM exprmt_context
            WHERE experiment_id = lr_project.experiment_id;

            DELETE FROM exprmt_measure
            WHERE experiment_id = lr_project.experiment_id;

            DELETE FROM experiment
            WHERE experiment_id = lr_project.experiment_id;

            -- delete the assay_documents
            DELETE FROM assay_document
            WHERE assay_id = lr_project.assay_id;

            -- delete the contexts
            DELETE FROM assay_context_item
            WHERE assay_context_id IN
                (SELECT assay_context_id
                FROM assay_context
                WHERE assay_id = lr_project.assay_id);

            DELETE FROM assay_context_measure
            WHERE assay_context_id IN
                (SELECT assay_context_id
                FROM assay_context
                WHERE assay_id = lr_project.assay_id);

            DELETE FROM measure
            WHERE assay_id = lr_project.assay_id;

            DELETE FROM assay_context
            WHERE assay_id = lr_project.assay_id;

            delete FROM assay
            WHERE assay_id = lr_project.assay_id;
        END IF;

    END LOOP;

END;
/

--
-- PROCEDURE: RESET_SEQUENCES
--

CREATE OR REPLACE PROCEDURE RESET_SEQUENCES
AUTHID CURRENT_USER
AS
    cursor cur_sequence
    is
    select sequence_name
    from user_sequences
    WHERE sequence_name LIKE '%_ID_SEQ';

    lv_max_sql  varchar2(1000);
    lv_drop_sql varchar2(1000);
    lv_create_sql   varchar2(1000);
    lv_grant_sql    varchar2(1000);
    lv_table_name   varchar2(50);
    lv_primary_key  varchar2(50);
    ln_max_id   number;

begin
    for rec_sequence in cur_sequence
    loop
--        IF rec_sequence.sequence_name = 'PRJCT_EXPRMT_CNTXT_ITEM_ID_SEQ'
--        THEN
--            lv_table_name := 'PRJCT_EXPRMT_CONTEXT_ITEM';
--            lv_primary_key :=  'PRJCT_EXPRMT_CONTEXT_ITEM_ID';
--        ELSE
            lv_table_name := replace(rec_sequence.sequence_name, '_ID_SEQ', null);
            lv_primary_key := replace(rec_sequence.sequence_name, '_SEQ', null);
--        END IF;

        lv_max_sql := 'select nvl(max(' || lv_primary_key || '), 0) from ' || lv_table_name;
        begin
            --dbms_output.put_line(lv_max_sql);
            EXECUTE IMMEDIATE lv_max_sql INTO ln_max_ID;

            lv_drop_sql := 'drop sequence ' || rec_sequence.sequence_name;
            --dbms_output.put_line(lv_drop_sql);
            EXECUTE IMMEDIATE lv_drop_sql;

            lv_create_sql := 'create sequence ' || rec_sequence.sequence_name
                    || ' start with ' || to_char(ln_max_id + 1)
                    || ' increment by 1 nominvalue';
            IF rec_sequence.sequence_name in ('RESULT_ID_SEQ', 'RESULT_HIERARCHY_ID_SEQ', 'RSLT_CONTEXT_ITEM_ID_SEQ')
            THEN
                lv_create_sql := lv_create_sql || ' maxvalue 999999999999999999 cache 10000';
            ELSE
                lv_create_sql := lv_create_sql || ' maxvalue 9999999999 cache 20';
            END IF;
                lv_create_sql := lv_create_sql || ' nocycle noorder';
            --dbms_output.put_line(lv_create_sql);

            lv_grant_sql := 'grant select on ' || rec_sequence.sequence_name
                    || ' to schatwin';
            --dbms_output.put_line(lv_grant_sql);
            EXECUTE IMMEDIATE lv_create_sql;
            EXECUTE IMMEDIATE lv_grant_sql;

        exception
            when others
            then
                null;   --dbms_output.put_line (to_char(sqlcode) || ', ' || sqlerrm);

        end;

    end loop;

    if cur_sequence%isopen
    then
        close cur_sequence;
    end if;

end;
/

--
-- PROCEDURE: RESULT_ID_UPDATE
--

CREATE OR REPLACE procedure result_id_update
    (ani_start_number_id number)
as
    cursor cur_result
    is
    select result_id
    from temp_result
    where result_id >= ani_start_number_id
    ORDER BY result_id;


    ln_result_id    number(19);
    li_counter  BINARY_INTEGER := 0;
begin

    -- disable the constraints
    --execute immediate 'alter table result_context_item DISABLE constraint FK_RESULT_CONTEXT_ITEM_RESULT';
    --execute immediate 'alter table result_hiearchy DISABLE constraint FK_RESULT_HIERARCHY_RESULT';
    --execute immediate 'alter table result_hiearchy DISABLE constraint FK_RESULT_HIERARCHY_RSLT_PRNT';
    -- do your stuff here ---------------------------------

    for lr_result in cur_result
    loop
        select result_id_seq.nextval
        into ln_result_id
        from dual;

        update temp_result
        set result_id = ln_result_id
        where result_id = lr_result.result_id;

        insert into identifier_mapping
            (table_name,
            source_schema,
            source_id,
            target_id)
        values
            ('RESULT',
            'southern',
            lr_result.result_id,
            ln_result_id);

        update temp_result_context_item
        set result_id = ln_result_id
        where result_id = lr_result.result_id;

        update temp_result_hierarchy
        set result_id = ln_result_id
        where result_id = lr_result.result_id;

        update temp_result_hierarchy
        set parent_result_id = ln_result_id
        where parent_result_id = lr_result.result_id;

        li_counter := li_counter + 1;
        IF li_counter > 100000
        THEN
            COMMIT;
            li_counter := 0;
        END IF;
    end loop;

    -- count the rows for commits
    commit;
    --------------------------------------------------------
    --execute immediate 'alter table result_context_item ENABLE constraint FK_RESULT_CONTEXT_ITEM_RESULT';
    --execute immediate 'alter table result_hiearchy ENABLE constraint FK_RESULT_HIERARCHY_RESULT';
    --execute immediate 'alter table result_hiearchy ENABLE constraint FK_RESULT_HIERARCHY_RSLT_PRNT';
end;
/

--
-- PROCEDURE: UPDATE_ACTIVITY_THRESHOLD
--

CREATE OR REPLACE PROCEDURE DATA_MIG.Update_activity_threshold (ani_assay_id IN NUMBER default NULL)
as
    CURSOR cur_aci
    IS
    selECT e.experiment_id,
          ac.assay_id,
          ac.assay_context_id,
          ac.display_order ac_display_order,
          ac.context_name,
          ac.context_group,
          aci.assay_context_item_id,
          aci.DISPLAY_ORDER aci_display_order,
          aci.ATTRIBUTE_ID,
          aci.QUALIFIER,
          aci.VALUE_ID,
          aci.EXT_VALUE_ID,
          aci.VALUE_DISPLAY,
          aci.VALUE_NUM,
          aci.VALUE_MIN,
          aci.VALUE_MAX,
          aci.VERSION,
          aci.DATE_CREATED,
          aci.LAST_UPDATED,
          aci.MODIFIED_BY
    FROM assay_context_item  aci,
    assay_context ac,
    experiment e
    WHERE e.assay_id = ac.assay_id
      AND ac.assay_context_id = aci.assay_context_id
      AND attribute_id = 589
      AND (e.assay_id = ani_assay_id OR ani_assay_id IS NULL)
    ORDER BY ac.assay_id, ac.display_order, aci.display_order;

    CURSOR cur_prjct_exprmt (cn_experiment_id NUMBER)
    IS
    SELECT project_experiment_id
    FROM project_experiment
    WHERE experiment_id = cn_experiment_id;

    CURSOR cur_context_name (cn_experiment_id NUMBER,
                             cv_context_name VARCHAR2)
    IS
    SELECT exprmt_context_id
    FROM exprmt_context
    WHERE experiment_id = cn_experiment_id
      AND context_name = cv_context_name;

    CURSOR cur_proj_context_name (cn_project_experiment_id NUMBER,
                             cv_context_name VARCHAR2)
    IS
    SELECT prjct_exprmt_context_id
    FROM prjct_exprmt_context
    WHERE project_experiment_id = cn_project_experiment_id
      AND context_name = cv_context_name;

    CURSOR cur_result_type (cn_assay_id NUMBER)
    IS
    SELECT result_type_id, stats_modifier_id
      FROM measure m,
      element rt,
      element sm
      WHERE m.assay_id = cn_assay_id
        AND parent_measure_id IS NULL
        AND rt.element_id = m.result_type_id
        AND (rt.label NOT LIKE 'Pub%' and rt.label NOT LIKE '%score%' and rt.label NOT LIKE '%escence%')
        AND sm.element_id (+) = m.stats_modifier_id
        AND (sm.label = 'mean' OR sm.element_id IS NULL)
      ORDER BY sm.label, rt.label  ;

    ln_experiment_context_id NUMBER;
    ln_result_type_id NUMBER;
    ln_stats_modifier_id NUMBER;
    ln_prjct_experiment_context_id NUMBER;


BEGIN
    FOR lr_aci IN cur_aci
    LOOP
        --reset the variables to ensure they are nulled.  fetch does not alter the value if the fetch fails
        ln_experiment_context_id := null;
        ln_result_type_id  := null;
        ln_stats_modifier_id  := null;

        -- create an experiment context and a project_exp context
        OPEN cur_context_name (lr_aci.experiment_id, lr_aci.context_name);
        FETCH cur_context_name INTO ln_experiment_context_id;
        CLOSE cur_context_name;

        IF ln_experiment_context_id IS NULL
        THEN
            SELECT exprmt_context_id_seq.NEXTVAL
            INTO ln_experiment_context_id
            FROM dual;

            INSERT INTO exprmt_context
                (EXPRMT_CONTEXT_ID,
                EXPERIMENT_ID,
                CONTEXT_NAME,
                CONTEXT_GROUP,
                DISPLAY_ORDER,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            VALUES
                (ln_experiment_context_id,
                lr_aci.experiment_id,
                lr_aci.context_name,
                'Project management> experiment',
                0,
                lr_aci.version,
                lr_aci.date_created,
                lr_aci.last_updated,
                lr_aci.modified_by);

        END IF;

        -- create a row for the activity threshold
        INSERT INTO exprmt_context_item
            (EXPRMT_CONTEXT_ITEM_ID,
            EXPRMT_CONTEXT_ID,
            DISPLAY_ORDER,
            ATTRIBUTE_ID,
            VALUE_ID,
            EXT_VALUE_ID,
            QUALIFIER,
            VALUE_NUM,
            VALUE_MIN,
            VALUE_MAX,
            VALUE_DISPLAY,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY)
        VALUES
            (exprmt_context_item_id_seq.nextval,
            ln_experiment_context_id,
            0,
            lr_aci.attribute_id,
            lr_aci.value_id,
            lr_aci.ext_value_id,
            lr_aci.qualifier,
            lr_aci.value_num,
            lr_aci.value_min,
            lr_aci.value_max,
            lr_aci.value_display,
            lr_aci.version,
            lr_aci.date_created,
            lr_aci.last_updated,
            lr_aci.modified_by);

        -- find the associated result type
        -- using 1. has no parent, 2. is not PubChem, 3. prefer stats modi
        OPEN cur_result_type (lr_aci.assay_id);
        FETCH cur_result_type INTO ln_result_type_id, ln_stats_modifier_id;
        CLOSE cur_result_type;

        IF ln_result_type_id IS NOT NULL
        THEN
            -- create another row(s) for the result type
            INSERT INTO exprmt_context_item
                (EXPRMT_CONTEXT_ITEM_ID,
                EXPRMT_CONTEXT_ID,
                DISPLAY_ORDER,
                ATTRIBUTE_ID,
                VALUE_ID,
                VALUE_DISPLAY,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            SELECT exprmt_context_item_id_seq.nextval,
                ln_experiment_context_id,
                1,
                1328,           -- result type
                element_id,
                label ,
                0,
                sysdate,
                null,
                lr_aci.modified_by
            fROM element WHERE element_id = ln_result_type_id;

            IF ln_stats_modifier_id IS NOT NULL
            THEN
                -- create another row(s) for the result type
                INSERT INTO exprmt_context_item
                    (EXPRMT_CONTEXT_ITEM_ID,
                    EXPRMT_CONTEXT_ID,
                    DISPLAY_ORDER,
                    ATTRIBUTE_ID,
                    VALUE_ID,
                    VALUE_DISPLAY,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                SELECT exprmt_context_item_id_seq.nextval,
                    ln_experiment_context_id,
                    2,
                    592,   -- endpoint statistic
                    element_id,
                    label ,
                    0,
                    sysdate,
                    null,
                    lr_aci.modified_by
                fROM element WHERE element_id = ln_stats_modifier_id;

            END IF;

        END IF;

        -- also IN the prjct_experiment context
        -- now go get all the project_experiments that this guy is in
        FOR lr_pe IN cur_prjct_exprmt(lr_aci.experiment_id)
        LOOP
            ln_prjct_experiment_context_id := null;
            -- create an experiment context and a project_exp context
            OPEN cur_proj_context_name (lr_pe.project_experiment_id, lr_aci.context_name);
            FETCH cur_proj_context_name INTO ln_prjct_experiment_context_id;
            CLOSE cur_proj_context_name;

            IF ln_prjct_experiment_context_id IS NULL
            THEN
                SELECT prjct_exprmt_context_id_seq.NEXTVAL
                INTO ln_prjct_experiment_context_id
                FROM dual;

                INSERT INTO prjct_exprmt_context
                    (PRJCT_EXPRMT_CONTEXT_ID,
                    PROJECT_EXPERIMENT_ID,
                    CONTEXT_NAME,
                    CONTEXT_GROUP,
                    DISPLAY_ORDER,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                VALUES
                    (ln_prjct_experiment_context_id,
                    lr_pe.project_experiment_id,
                    lr_aci.context_name,
                    'Project management> experiment',
                    0,
                    lr_aci.version,
                    lr_aci.date_created,
                    lr_aci.last_updated,
                    lr_aci.modified_by);

            END IF;

            INSERT INTO prjct_exprmt_cntxt_item
                (PRJCT_EXPRMT_CNTXT_ITEM_ID,
                PRJCT_EXPRMT_CONTEXT_ID,
                DISPLAY_ORDER,
                ATTRIBUTE_ID,
                VALUE_ID,
                EXT_VALUE_ID,
                QUALIFIER,
                VALUE_NUM,
                VALUE_MIN,
                VALUE_MAX,
                VALUE_DISPLAY,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            VALUES
                (prjct_exprmt_cntxt_item_id_seq.nextval,
                ln_prjct_experiment_context_id,
                0,
                lr_aci.attribute_id,
                lr_aci.value_id,
                lr_aci.ext_value_id,
                lr_aci.qualifier,
                lr_aci.value_num,
                lr_aci.value_min,
                lr_aci.value_max,
                lr_aci.value_display,
                lr_aci.version,
                lr_aci.date_created,
                lr_aci.last_updated,
                lr_aci.modified_by);

            IF ln_result_type_id IS NOT NULL
            THEN
                -- create another row(s) for the result type
                INSERT INTO prjct_exprmt_cntxt_item
                    (PRJCT_EXPRMT_CNTXT_ITEM_ID,
                    PRJCT_EXPRMT_CONTEXT_ID,
                    DISPLAY_ORDER,
                    ATTRIBUTE_ID,
                    VALUE_ID,
                    VALUE_DISPLAY,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                SELECT prjct_exprmt_cntxt_item_id_seq.nextval,
                    ln_prjct_experiment_context_id,
                    1,
                    1328,           -- result type
                    element_id,
                    label ,
                    0,
                    sysdate,
                    null,
                    lr_aci.modified_by
                fROM element WHERE element_id = ln_result_type_id;

                IF ln_stats_modifier_id IS NOT NULL
                THEN
                    -- create another row(s) for the result type
                    INSERT INTO prjct_exprmt_cntxt_item
                        (PRJCT_EXPRMT_CNTXT_ITEM_ID,
                        PRJCT_EXPRMT_CONTEXT_ID,
                        DISPLAY_ORDER,
                        ATTRIBUTE_ID,
                        VALUE_ID,
                        VALUE_DISPLAY,
                        VERSION,
                        DATE_CREATED,
                        LAST_UPDATED,
                        MODIFIED_BY)
                    SELECT prjct_exprmt_cntxt_item_id_seq.nextval,
                        ln_prjct_experiment_context_id,
                        2,
                        592,   -- endpoint statistic
                        element_id,
                        label ,
                        0,
                        sysdate,
                        null,
                        lr_aci.modified_by
                    fROM element WHERE element_id = ln_stats_modifier_id;

                END IF;
            END IF;
        END LOOP;

        -- and convert assay context item to free
        UPDATE assay_context_item
        SET value_num = NULL,
            qualifier = NULL,
            value_display = NULL,
            attribute_type = 'Free'
        WHERE assay_context_item_id = lr_aci.assay_context_item_id;



    END LOOP;

END;
/

--
-- PACKAGE: AUDITING
--

CREATE OR REPLACE PACKAGE auditing
AS
    TYPE r_column IS RECORD (column_name VARCHAR2(30),
                            old_value   VARCHAR2(4000),
                            new_value   VARCHAR2(4000));

    TYPE t_columns iS TABLE OF r_column
        INDEX BY binary_integer;

    TYPE r_trail IS REF CURSOR;

    PROCEDURE Save_audit (avi_table_owner IN VARCHAR2,
                          avi_table_name  IN VARCHAR2,
                          avi_username  IN VARCHAR2,
                          avi_action IN VARCHAR2,
                          avi_primary_key IN VARCHAR2,
                          ati_columns IN t_columns);

    PROCEDURE show_audit_trail (avi_table_name IN VARCHAR2,
                                avi_primary_key IN VARCHAR2,
                                avo_sql OUT VARCHAR2,
                                adi_from_date IN DATE DEFAULT null,
                                adi_to_date IN DATE DEFAULT NULL);

    PROCEDURE show_audit_trail (avi_table_name IN VARCHAR2,
                                avi_primary_key IN VARCHAR2,
                                aco_audit_trail OUT r_trail,
                                adi_from_date IN DATE DEFAULT null,
                                adi_to_date IN DATE DEFAULT NULL);

END auditing;
/
CREATE OR REPLACE PACKAGE BODY auditing
AS

    CR  CHAR(2) := Chr(13) || Chr(10);
---------------------------------------------------------------------------------------
-- operating procedures
---------------------------------------------------------------------------------------
    FUNCTION convert_data_type_string (avi_column_name IN varchar2,
                                       avi_data_type IN varchar2)
        RETURN VARCHAR2
    AS
        lv_string VARCHAR2(100) := NULL;

    BEGIN
        IF avi_data_type IN ('CHAR', 'VARCHAR2')
        then
            lv_string :=  avi_column_name;
        ELSIF avi_data_type IN ('NUMBER', 'INTEGER', 'FLOAT')
        THEN
            lv_string := 'TO_CHAR(' || avi_column_name || ')';
        ELSIF avi_data_type IN ('CLOB')
        THEN
            lv_string := 'TO_CHAR(SUBSTR(' || avi_column_name || ',1,4000))';
        ELSIF avi_data_type IN ('DATE', 'TIMESTAMP(6)')
        THEN
            lv_string := 'TO_CHAR(' || avi_column_name || ', ''MM/DD/YYYY HH:MI:SS'')';
        ELSE
            lv_string := null;
        END IF;

        RETURN lv_string;

    END convert_data_type_string;

    function save_audit_row (avi_table_owner IN VARCHAR2,
                            avi_table_name IN varchar2,
                            avi_primary_key IN VARCHAR2,
                            avi_action in VARCHAR2,
                            avi_username IN VARCHAR2)
            RETURN NUMBER
    AS
        ln_audit_id NUMBER;

    BEGIN
        SELECT audit_id_seq.NEXTVAL
        INTO ln_audit_id
        FROM dual;

        INSERT INTO audit_row_log
            (audit_id,
             table_owner,
             table_name,
             primary_key,
             action,
             username,
             audit_timestamp)
        VALUES
            (ln_audit_id,
             avi_table_owner,
             avi_table_name,
             avi_primary_key,
             avi_action,
             avi_username,
             sysdate);

        RETURN ln_audit_id;
    END save_audit_row;

    PROCEDURE save_audit_column (ani_audit_id NUMBER,
                                avi_column_name IN VARCHAR2,
                                avi_old_value IN VARCHAR2,
                                avi_new_value IN VARCHAR2)
    AS


    BEGIN
        INSERT INTO audit_column_log
            (audit_id,
             column_name,
             old_value)
        VALUES
            (ani_audit_id,
             avi_column_name,
             Nvl(avi_old_value, 'NULL'));

    END save_audit_column;

-- public facing one
    PROCEDURE Save_audit (avi_table_owner IN VARCHAR2,
                          avi_table_name  IN VARCHAR2,
                          avi_username  IN VARCHAR2,
                          avi_action IN VARCHAR2,
                          avi_primary_key IN VARCHAR2,
                          ati_columns IN t_columns)
    as
        ln_audit_id NUMBER;

    BEGIN
        ln_audit_id := save_audit_row (avi_table_owner,
                                      avi_table_name,
                                      avi_primary_key,
                                      avi_action,
                                      avi_username);

        FOR i IN 1..ati_columns.last
        LOOP
            Dbms_Output.put_line( ' ' || To_Char(i) || 'col:' ||ati_columns(i).column_name ||' old:' || ati_columns(i).old_value);
            save_audit_column (ln_audit_id,
                               ati_columns(i).column_name,
                               ati_columns(i).old_value,
                               ati_columns(i).new_value);
             Dbms_Output.put_line(To_Char(ln_audit_id) );
        END LOOP;
    END save_audit;

    PROCEDURE show_audit_trail (avi_table_name IN VARCHAR2,
                                avi_primary_key IN VARCHAR2,
                                avo_sql OUT varchar2,
                                adi_from_date IN DATE DEFAULT null,
                                adi_to_date IN DATE DEFAULT NULL)
    AS
          lv_sql  VARCHAR2(32767);
          lv_column_text  VARCHAR2(1000);
          lv_table_name VARCHAR2(50);
          lv_owner VARCHAR2(50);
          lv_where VARCHAR2(1000);
          ln_period_pos BINARY_INTEGER;
          lv_key_value  varchar2(1000);
          lv_compound_key VARCHAR2(4000);
          ln_comma BINARY_INTEGER;
          lv_pk_columns VARCHAR2(1000);
          lv_all_pk_col_text VARCHAR2(5000);
          lv_all_col_text VARCHAR2(10000);

          CURSOR cur_col (cv_table_name IN VARCHAR2,
                          cv_table_owner IN VARCHAR2)
          IS
          SELECT column_name,
              data_type,
              (SELECT is_pk
                  FROM audit_setting a
                  WHERE a.table_owner = ac.owner
                    AND a.table_name = ac.table_name
                    AND a.column_name = ac.column_name) is_pk
          FROM all_tab_columns ac
          WHERE ac.owner = cv_table_owner
            AND ac.table_name = cv_table_name
          ORDER BY column_id;
    BEGIN
        -- split the incoming tablename into owner and table
        ln_period_pos := InStr(avi_table_name, '.');
        IF ln_period_pos = 0
        THEN
            lv_owner := USER;
            lv_table_name := Upper(avi_table_name);
        ELSE
            lv_owner := Upper(SubStr(avi_table_name, 1, ln_period_pos -1));
            lv_table_name := Upper(SubStr(avi_table_name, ln_period_pos + 1));
        END IF;

        -- assemble the 1st part of the union - the current entry
        lv_sql := 'SELECT user username,' || CR
              || '    ''Current'' action,'  || CR
              || '    sysdate audit_timestamp';
        lv_compound_key := avi_primary_key;
        FOR lr_col IN cur_col (lv_table_name, lv_owner)
        LOOP
            IF lr_col.is_pk = 'Y'
            THEN
                IF AVI_PRIMARY_KEY IS NOT NULL
                THEN
                    -- strip out the comma separated value of the primary key columns
                    ln_comma := InStr( lv_compound_key,',');
                    IF ln_comma = 0
                    THEN
                        lv_key_value := lv_compound_key;
                    ELSE
                        lv_key_value := SubStr(lv_compound_key, 1, ln_comma -1);
                        lv_compound_key := SubStr(lv_compound_key, ln_comma + 2);
                    END IF;
                    IF lv_where IS NULL
                    THEN
                        lv_where := 'where ' || lr_col.column_name || ' = ''' || lv_key_value || '''' || CR;
                    ELSE
                        lv_where := lv_where || '  and ' || lr_col.column_name || ' = ''' || lv_key_value || '''' || CR;
                    END IF;
                END IF;
                lv_pk_columns := lv_pk_columns || lr_col.column_name || ', ' ;
                lv_all_pk_col_text := lv_all_pk_col_text || convert_data_type_string(lr_col.column_name, lr_col.data_type) || ' || '', '' || ';
            ELSE
                lv_column_text := convert_data_type_string (lr_col.column_name, lr_col.data_type) || ' ' || lr_col.column_name;
                lv_all_col_text := lv_all_col_text || ',' || CR || '    ' || lv_column_text;
            END IF;
        END LOOP;
        lv_sql := lv_sql || ',' || CR || '    ' || substr(lv_all_pk_col_text, 1, Length(lv_all_pk_col_text)-12) || ' primary_key';
        lv_sql := lv_sql || lv_all_col_text;

        -- now the rest of the 1st clause
        lv_sql := lv_sql || CR || 'from ' || avi_table_name || CR
                         || lv_where || CR
                         || 'union all' || CR
                         || 'SELECT  arl.username,'|| CR
                         || '    arl.action,' || CR
                         || '    arl.audit_timestamp,' || CR
                         || '    arl.primary_key';

        FOR lr_col IN cur_col( lv_table_name, lv_owner)
        LOOP
             IF Nvl(lr_col.is_pk, 'N') = 'N'
             THEN
                IF lr_col.data_type like '_LOB'
                THEN
                    lv_column_text := '''<not audited>''';
                    lv_sql := lv_sql || ',' || CR || lv_column_text;

                ELSE
                    lv_column_text := 'listagg(Decode(acl.column_name, ''' || lr_col.column_name || ''', acl.old_value), '''') WITHIN GROUP( ORDER BY acl.old_value)';
                    lv_sql := lv_sql || ',' || CR || lv_column_text;
                END IF;
             END IF;
        END LOOP;

        -- and the final part
        lv_sql := lv_sql || CR || 'FROM AUDIT_COLUMN_LOG acl,' || CR
                  || '    audit_row_log arl' || CR
                  || 'WHERE arl.audit_id = acl.audit_id' || CR
                  || 'AND arl.table_owner = ''' || lv_owner || '''' || CR
                  || 'AND arl.table_name = ''' || lv_table_name || '''' || CR;
        IF AVI_PRIMARY_KEY IS NOT NULL
        THEN
            lv_sql := lv_sql || 'AND arl.primary_key = ''' || avi_primary_key || '''' || CR;
        END IF;
        lv_sql := lv_sql || 'GROUP BY  arl.username, arl.action, arl.audit_timestamp, arl.primary_key' || CR
                  || 'ORDER BY primary_key, audit_timestamp desc';

        --Dbms_Output.put_line(lv_sql);

        avo_sql := lv_sql;

    END show_audit_trail;

    ------------------------------------------------------------------------------
    -- overloaded version which returns a cursor that the applicaiton can walk thru
    PROCEDURE show_audit_trail (avi_table_name IN VARCHAR2,
                            avi_primary_key IN VARCHAR2,
                            aco_audit_trail OUT r_trail,
                            adi_from_date IN DATE DEFAULT null,
                            adi_to_date IN DATE DEFAULT NULL)
     AS
          lv_sql  VARCHAR2(32767);

     BEGIN
          show_audit_trail (avi_table_name,
                            avi_primary_key,
                            lv_sql,
                            adi_from_date,
                            adi_to_date);

          OPEN aco_audit_trail FOR lv_sql;

     END show_audit_trail;    -- version 2 with a cursor

END auditing;
/

--
-- PACKAGE: AUDITING_INIT
--

CREATE OR REPLACE PACKAGE auditing_init
AUTHID CURRENT_USER
AS

    PROCEDURE make_triggers(avi_table_name IN VARCHAR2 DEFAULT NULL);

END auditing_init;
/
CREATE OR REPLACE PACKAGE BODY DATA_MIG.auditing_init
AS
    CR  CHAR(2) := Chr(13) || Chr(10);
    prefix  VARCHAR2(10) := 'ADT_';
---------------------------------------------------------------------------------------
-- setup procedures
---------------------------------------------------------------------------------------
--   There are some rules to follow:
--   1. No Primary Key means no auditing - no triggers are created
--   2. Tables with a lot of columns (about 300?) make triggers with too much code,
--      Oracle has a limit of 32767 chars for trigger code - no triggers are created
--   3. Auditing triggers on tables named AUDIT..., TEMP..., or ...LOG are prohibited
--      you can get into circular triggering logic without these prohibitions
--   4. CLOBs and BLOBs are not audited - only columns that can convert to a string < 4000 long are allowed
--
--
--
--
--
    PROCEDURE delete_audit_trigger (avi_table_name IN VARCHAR2 DEFAULT null)
    AS
        CURSOR cur_trigger
        IS
        SELECT trigger_name
        FROM user_triggers
        WHERE TRIGGER_NAME LIKE prefix || '%'
          AND (table_name = avi_table_name OR avi_table_name IS NULL);

        lv_sql  VARCHAR2(1000);

    BEGIN
        FOR lr_trigger IN cur_trigger
        LOOP
            lv_sql := 'drop trigger ' || lr_trigger.trigger_name;

            EXECUTE IMMEDIATE lv_sql;

        END LOOP;

    END delete_audit_trigger;

    FUNCTION convert_data_type_string (avi_column_name IN varchar2,
                                       avi_data_type IN varchar2)
        RETURN VARCHAR2
    AS
        lv_string VARCHAR2(100) := NULL;

    BEGIN
        IF avi_data_type IN ('CHAR', 'VARCHAR2')
        then
            lv_string :=  avi_column_name;
        ELSIF avi_data_type IN ('NUMBER', 'INTEGER', 'FLOAT')
        THEN
            lv_string := 'TO_CHAR(' || avi_column_name || ')';
        ELSIF avi_data_type IN ('DATE', 'TIMESTAMP(6)')
        THEN
            lv_string := 'TO_CHAR(' || avi_column_name || ', ''MM/DD/YYYY HH:MI:SS'')';
        ELSE
            lv_string := null;
        END IF;

        RETURN lv_string;

    END convert_data_type_string;

    function write_trigger_code (avi_table_name IN VARCHAR2,
                                  avi_type  IN VARCHAR2)
        RETURN varchar2
    AS
        lv_sql varchar2(32767);
        lv_primary_key VARCHAR2(100) := NULL;
        lv_all_PK VARCHAR2(5000) := NULL;
        lv_col  VARCHAR2(1000) := NULL;
        --lv_all_cols VARCHAR2(10000) := NULL;

        CURSOR cur_row (cv_table_name IN VARCHAR2,
                        cv_crud IN VARCHAR2)
        IS
        SELECT a.table_owner,
            a.table_name,
            listagg(a.column_name, ',') within GROUP (ORDER BY a.column_name) col_list
        FROM cols,
            audit_setting a
        WHERE a.table_owner = USER
          AND a.table_name = cols.table_name
          AND a.table_name = cv_table_name
          AND a.column_name = cols.column_name
          AND Decode(cv_crud, 'IS_PK', a.is_pk, 'INSERT',a.audit_insert,'UPDATE',a.audit_update, 'DELETE',a.audit_delete) = 'Y'
        group BY a.table_owner, a.table_name;

        TYPE r_row IS RECORD (table_owner audit_setting.table_owner%TYPE,
                       table_name audit_setting.table_name%TYPE,
                       col_list VARCHAR2(4000));
        lr_row r_row;

        CURSOR cur_pk (cn_table_name IN VARCHAR2)
        IS
        SELECT a.table_owner,
            a.table_name,
            a.column_name,
            cols.data_type
        FROM cols,
            audit_setting a
        WHERE a.table_owner = USER
          AND a.table_name = cols.table_name
          AND a.table_name = cn_table_name
          AND a.column_name = cols.column_name
          AND a.is_pk = 'Y'
        ORDER BY a.table_name, cols.column_id;

        CURSOR cur_column (cn_table_name IN VARCHAR2,
                           cn_crud IN varchar2)
        IS
        SELECT a.table_owner,
            a.table_name,
            a.column_name,
            cols.data_type
        FROM cols,
            audit_setting a
        WHERE a.table_owner = USER
          AND a.table_name = cols.table_name
          AND a.table_name = cn_table_name
          AND a.column_name = cols.column_name
          AND Decode(cn_crud, 'IS_PK', a.is_pk, 'INSERT',a.audit_insert,'UPDATE',a.audit_update, 'DELETE',a.audit_delete) = 'Y'
        ORDER BY a.table_name, cols.column_name;

        lv_trigger_name VARCHAR2(100);

    BEGIN
        --------------------------------------------------------------
        -- setup the header
        OPEN cur_row(avi_table_name, avi_type);
        FETCH CUR_row INTO lr_row;
        lv_trigger_name := SubStr( prefix || SubStr(avi_type, 1, 3) || '_' || avi_table_name, 1, 30);
        lv_sql := 'CREATE OR REPLACE TRIGGER ' || lv_trigger_name || CR
                  || 'BEFORE ' || avi_type || cr;
        IF avi_type = 'UPDATE'
        THEN
            lv_sql := lv_sql || '    OF ' || lr_row.col_list || CR;
        END IF;
        lv_sql := lv_sql || '    ON ' || avi_table_name || cr
                  || '    FOR EACH ROW' || CR || CR
                  || 'DECLARE' || cr
                  || '    lt_columns  auditing.t_columns;' || cr
                  || '    lv_table_owner VARCHAR2(30) := ''' || USER || ''';' || cr
                  || '    lv_table_name VARCHAR2(30) := ''' || avi_table_name || ''';' || cr
                  || '    lv_username VARCHAR2(30);' || cr
                  || '    lv_primary_key  VARCHAR2(1000);' || cr
                  || '    lv_action VARCHAR2(30) := ''' || avi_type || ''';' || cr
                  || '    i BINARY_INTEGER := 0;' || cr || CR
                  || 'BEGIN' || cr
                  || '    lv_username := bard_context.get_username;' || cr
                  || '    IF lv_username IS NULL' || cr
                  || '    THEN' || cr
                  || '        Raise_Application_Error(-20900, ''' || avi_table_name || ' ' || lower(avi_type) || ' refused.  Username not specified. '');' || cr
                  || '    END IF;' || CR || CR;
        CLOSE cur_row;
        --dbms_Output.put_line(lv_sql);
        --------------------------------------------------------------
        -- setup the primary key
        FOR lr_pk IN cur_pk(avi_table_name)
        LOOP
            lv_primary_key := convert_data_type_string (':old.' || lr_pk.column_name, lr_pk.data_type);

            IF lv_primary_key IS NOT NULL
            THEN
                IF lv_all_PK IS NULL
                THEN
                    lv_all_pk := '    lv_primary_key := ' || lv_primary_key || ';' || CR;
                ELSE
                    lv_all_pk := '    lv_primary_key := lv_primary_key || '', '' || ' || lv_primary_key || ';' || CR;
                END IF;
            END IF;
        END LOOP;

        -- if there's no primary key we can't audit the table
        IF lv_all_pk IS NULL
        THEN
            RETURN NULL;
        END IF;

        lv_sql := lv_sql || lv_all_pk || CR;
        --dbms_Output.put_line(lv_sql);

        --------------------------------------------------------------
        -- setup the columns
        FOR lr_col IN cur_column (avi_table_name, avi_type)
        LOOP
            Dbms_Output.PUT_LINE( substr(avi_type, 1, 3) || ' ' ||lr_col.TABLE_name || '.' || lr_col.column_name || ': ' || Length(lv_sql));
            IF Length(lv_sql) + 892 < 32767    -- 892 is the maximum length of the next piece and the end section
            THEN
                IF avi_type = 'UPDATE' THEN
                    lv_col := '    IF :new.' || lr_col.column_name || ' != :old.' || lr_col.column_name || CR
                          || '      OR (:new.' || lr_col.column_name || ' IS NULL AND :old.' || lr_col.column_name || ' IS NOT NULL)' || CR
                          || '      OR (:new.' || lr_col.column_name || ' IS NOT NULL AND :old.' || lr_col.column_name || ' IS NULL)' || CR
                          || '    THEN' || CR
                          || '       i := i + 1;' || CR
                          || '       lt_columns(i).column_name := ''' || lr_col.column_name || ''';' || CR
                          || '       lt_columns(i).old_value := ' || convert_data_type_string(':old.' || lr_col.column_name, lr_col.data_type) || ';' || CR
                          || '       lt_columns(i).new_value := ' || convert_data_type_string(':new.' || lr_col.column_name, lr_col.data_type) || ';' || CR
                          || '    END IF;' || CR;
                ELSIF AVI_TYPE = 'DELETE'
                THEN
                     lv_col := '       i := i + 1;' || CR
                          || '       lt_columns(i).column_name := ''' || lr_col.column_name || ''';' || CR
                          || '       lt_columns(i).old_value := ' || convert_data_type_string(':old.' || lr_col.column_name, lr_col.data_type) || ';' || CR ;
                ELSIF AVI_TYPE = 'INSERT'
                THEN
                     lv_col := '       i := i + 1;' || CR
                          || '       lt_columns(i).column_name := ''' || lr_col.column_name || ''';' || CR
                          || '       lt_columns(i).new_value := ' || convert_data_type_string(':new.' || lr_col.column_name, lr_col.data_type) || ';' || CR ;
                END IF;

                lv_sql := lv_sql || lv_col;
            ELSE
                lv_sql := NULL;
                EXIT;
            END IF;
        END LOOP;
        --dbms_Output.put_line(lv_sql);


        --------------------------------------------------------------
        -- setup the footer
        IF lv_sql IS NOT NULL
        then
            lv_sql := lv_sql || CR || '    if i > 0 then' || CR
                        || '    auditing.save_audit(lv_table_owner,' || CR
                        || '                        lv_table_name,' || CR
                        || '                        lv_username,' || CR
                        || '                        lv_action,' || CR
                        || '                        lv_primary_key,' || CR
                        || '                        lt_columns);' || CR
                        || '    end if;' || CR || CR
                        || 'END;';
            --dbms_Output.put_line(lv_sql);
        END IF;

        RETURN lv_sql;
    EXCEPTION
      WHEN OTHERS THEN
        IF cur_column%ISOPEN THEN
            CLOSE cur_column;
        END IF;
        IF cur_row%ISOPEN THEN
            CLOSE cur_row;
        END IF;
        IF cur_pk%ISOPEN THEN
            CLOSE cur_pk;
        END IF;
        RAISE;
    END write_trigger_code;

-- public facing one

    PROCEDURE make_triggers(avi_table_name IN VARCHAR2 DEFAULT NULL)
    AS

        lv_sql varchar2(32767) := null;

        CURSOR cur_table
        IS
        SELECT table_name,
            Sum(Decode(audit_insert, 'Y',1,0)) insert_count,
            Sum(Decode(audit_update, 'Y',1,0)) update_count,
            Sum(Decode(audit_delete, 'Y',1,0)) delete_count
        FROM audit_setting
        WHERE (audit_insert = 'Y' OR audit_update = 'Y' OR audit_delete = 'Y')
          AND is_pk = 'N'
          AND (table_name = avi_table_name OR avi_table_name IS NULL)
        GROUP BY table_name;

    BEGIN
        -- first delete the old triggers
        --dbms_Output.put_line('delete ' || avi_table_name);

        delete_audit_trigger (avi_table_name);

        -- loop thru creating new triggers
        FOR lr_table IN cur_table
        LOOP
            IF lr_table.insert_count > 0
            THEN
            --dbms_Output.put_line('insert trigger for ' || lr_table.table_name);
                lv_sql := write_trigger_code(lr_table.table_name, 'INSERT');
                IF lv_sql IS NOT NULL
                THEN
                    EXECUTE IMMEDIATE lv_sql;
                END IF;
            END IF;
            lv_sql := NULL;

            IF lr_table.update_count > 0
            THEN
            --dbms_Output.put_line('UPDATE trigger for ' || lr_table.table_name);
                lv_sql := write_trigger_code(lr_table.table_name, 'UPDATE');
                --dbms_Output.Put_line('UPD SQL: ' || lv_sql);
                IF lv_sql IS NOT NULL
                THEN
                   --dbms_Output.Put_line('Execute immediate UPD SQL:');
                   EXECUTE IMMEDIATE lv_sql;
                   --dbms_Output.Put_line('After Execute immediate UPD SQL:');

                END IF;
            END IF;
            lv_sql := NULL;
            IF lr_table.delete_count > 0
            THEN
            --dbms_Output.put_line('DELETE trigger for ' || lr_table.table_name);
                lv_sql := write_trigger_code(lr_table.table_name, 'DELETE');
                --dbms_Output.Put_line('del SQL: ' || lv_sql);
                IF lv_sql IS NOT NULL
                THEN
                    EXECUTE IMMEDIATE lv_sql;
                END IF;
            END IF;

        END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        IF cur_table%ISOPEN THEN
            CLOSE cur_table;
        END IF;
        RAISE;
    END make_triggers;


END auditing_init;
/

--
-- PACKAGE: AUDITING_SETUP
--

CREATE OR REPLACE PACKAGE auditing_setup
AUTHID CURRENT_USER
AS

    PROCEDURE setup_tables;

    PROCEDURE update_settings( avi_table_name IN VARCHAR2 DEFAULT NULL,
                               avi_Increment VARCHAR2 DEFAULT 'Increment');

END auditing_setup;
/
CREATE OR REPLACE PACKAGE BODY auditing_setup
AS

---------------------------------------------------------------------------------------
-- public facing one
    PROCEDURE setup_tables
    AS
        lv_sql  VARCHAR2(10000);
        ln_table_exists INTEGER := 0;

    BEGIN
      -----------------------------------------------------------
      -- audit_row_log
      SELECT Count(*) INTO ln_table_exists
      FROM tabs
      WHERE table_name = 'AUDIT_ROW_LOG';

      IF ln_table_exists = 0
      THEN
          lv_sql := 'CREATE TABLE audit_row_log
  (audit_id NUMBER (19,0) NOT NULL,
  table_owner VARCHAR2(30) DEFAULT Lower(USER) NOT NULL,
  table_name varchar2(30) NOT NULL,
  primary_key VARCHAR2(4000) NOT NULL,
  action VARCHAR2(20) NOT NULL,
  audit_timestamp DATE DEFAULT SYSDATE  NOT NULL,
  username  VARCHAR2(30) NOT NULL,
  constraint pk_audit_row_log PRIMARY KEY (audit_id)
  )';
          EXECUTE IMMEDIATE lv_sql;
      END IF;

      SELECT Count(*) INTO ln_table_exists
      FROM user_sequences
      WHERE sequence_name = 'AUDIT_ID_SEQ';

      IF ln_table_exists = 0
      THEN
          lv_sql := 'CREATE SEQUENCE audit_id_seq
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    MAXVALUE 9999999999
    NOCYCLE
    CACHE 200
    NOORDER';
          EXECUTE IMMEDIATE lv_sql;
      END IF;
      SELECT Count(*) INTO ln_table_exists
      FROM user_indexes
      WHERE index_name = 'IDX_AUDIT_ROW_LOG_PRIMARY_KEY';

      IF ln_table_exists = 0
      THEN
          LV_SQL := 'CREATE INDEX idx_audit_row_log_primary_key ON audit_row_log(primary_key)';
          EXECUTE IMMEDIATE lv_sql;
      END IF;
      -----------------------------------------------------------
      -- audit_column_log
      SELECT Count(*) INTO ln_table_exists
      FROM tabs
      WHERE table_name = 'AUDIT_COLUMN_LOG';

      IF ln_table_exists < 1
      THEN
          lv_sql := 'CREATE TABLE audit_column_log
    (audit_id NUMBER (19,0) NOT NULL,
    column_name VARCHAR2(30) NOT NULL,
    old_value VARCHAR2(4000),
    CONSTRAINT pk_audit_column_log PRIMARY KEY (audit_id, column_name),
    CONSTRAINT fk_audit_column_audit_row_log FOREIGN KEY (audit_id)
        REFERENCES audit_row_log (audit_id)
    )';

          EXECUTE IMMEDIATE lv_sql;
          -- Add the foreign key index
          LV_SQL := 'CREATE INDEX fk_audit_column_audit_row ON audit_column_log(audit_id)';
          EXECUTE IMMEDIATE lv_sql;

      END IF;

      -----------------------------------------------------------
      -- audit_setting
      SELECT Count(*) INTO ln_table_exists
      FROM tabs
      WHERE table_name = 'AUDIT_SETTING';

      IF ln_table_exists < 1
      THEN
          lv_sql := 'CREATE TABLE audit_setting
    (table_owner  VARCHAR2(30) NOT NULL,
     table_name VARCHAR2(30) NOT NULL,
     column_name VARCHAR2(30) NOT NULL,
     is_pk  CHAR(1) DEFAULT ''N'' NOT NULL,
     audit_insert CHAR(1) DEFAULT ''N'' NOT NULL,
     audit_update CHAR(1) DEFAULT ''Y'' NOT NULL,
     audit_delete CHAR(1) DEFAULT ''Y'' NOT NULL,
     constraint pk_audit_setting PRIMARY KEY (table_owner, table_name, column_name)
     )';

          EXECUTE IMMEDIATE lv_sql;

          update_settings('', 'Refresh');

      end IF;
    END setup_tables;

    proCEDURE update_settings(avi_table_name VARCHAR2 DEFAULT NULL,
                              avi_Increment VARCHAR2 DEFAULT 'Increment')
    AS
        lv_sql    VARCHAR2(10000);

    BEGIN
        IF avi_increment = 'Refresh'
        THEN
            lv_sql := 'delete from audit_setting';
        ELSE
            lv_sql := 'delete from audit_setting where table_name = ''' || avi_table_name || '''';
        END IF;
        EXECUTE IMMEDIATE lv_sql;

        -- Populate with default value
        -- do not track PK, LOB, any columns that are unchanging (date_created)
        -- edit to suit the schema and important tables you want to track
        LV_SQL := 'INSERT INTO AUDIT_SETTING
SELECT user,
    cols.TABLE_NAME,
    cols.COLUMN_NAME,
    Decode(ac.constraint_name, NULL, ''N'', ''Y'') IS_PK,
    ''N'' AUDIT_INSERT,
    Decode(ac.constraint_name, NULL, Decode (DATA_TYPE, ''CLOB'', ''N'', Decode(cols.COLUMN_NAME, ''VERSION'', ''N'', ''Y'')),''N'') AUDIT_UPDATE,
    Decode(ac.constraint_name, NULL, Decode (DATA_TYPE, ''CLOB'', ''N'', ''Y''), ''N'') AUDIT_DELETE
FROM cols
left OUTER JOIN (user_constraints ac
                JOIN user_ind_columns aic
                ON aic.index_name = ac.index_name
                   AND AC.CONSTRAINT_TYPE = ''P'')
          ON ac.owner = USER
             AND ac.table_name = cols.table_name
             AND aic.column_name = cols.column_name
WHERE table_name in (select table_name from tabs)
  AND TABLE_NAME NOT LIKE ''AUDIT%''
  AND TABLE_NAME NOT LIKE ''%0%''
  AND TABLE_NAME NOT LIKE ''TEMP%''
  AND TABLE_NAME NOT LIKE ''DATA%''
  AND TABLE_NAME NOT LIKE ''%LOG''';
      IF avi_table_name IS NOT NULL
      THEN
          lv_sql := lv_sql || ' and table_name = ''' || Upper(avi_table_name) || '''';
      END IF;
      lv_sql := lv_sql || '  AND NOT EXISTS (SELECT 1
      FROM audit_setting a
      WHERE a.table_owner = USER
        AND a.table_name = cols.table_name
        AND a.column_name = cols.column_name)
ORDER BY table_name, column_name';
          EXECUTE IMMEDIATE lv_sql;

          EXECUTE IMMEDIATE 'Commit';
    END update_settings;

END auditing_setup;
/

--
-- PACKAGE: BARD_CONTEXT
--

CREATE OR REPLACE package bard_context is
--
-- This package contains procedures that handle the application context.
--
-- Install this package in the PBS schema.
--

-- We are not using the application context more, because there are mulitple
-- PBS schemas in the same Oracle instances.  They cannot use the same
-- global database context.

--C_CONTEXT_NAME    constant varchar2(30) := 'CTX_PBS_SECURITY';

procedure set_username(i_username varchar2);

--
-- Removes the username from the context.
--
procedure clear_username;
--
-- Removes the username from the context.
--
function clear_username return varchar2;

--
-- Returns the username set in the context, always in lowercase. Or null if not set.
--
function  get_username return varchar2;

end;
/
CREATE OR REPLACE package body bard_context is

--
-- package scope variables
--

v_username         varchar2(100) := null;

--
-- Forward declarations
--

procedure set_username(i_username varchar2) is

	i	integer;

begin

	i := instr(i_username, '@');
	if i = 0 then
		v_username := i_username;
	else
		v_username :=  substr(i_username, 1, i-1);	-- handle email address
	end if;

end;

procedure clear_username is
begin

	v_username := null;

end;

function clear_username return varchar2 is
  old_username varchar2(100);

begin
  old_username := v_username;
	clear_username();
  return concat(lower(old_username), ' was cleared from the context');
end;

function get_username return varchar2 is
begin

	return lower(v_username);

end;

end;
/

--
-- PACKAGE: CONFIDENCE_LEVEL_UTIL
--

CREATE OR REPLACE PACKAGE confidence_level_util
AUTHID current_user
AS
     --TYPE r_score IS RECORD (score NUMBER);

     TYPE t_score IS TABLE OF number
          index BY BINARY_INTEGER;

     TYPE t_factor IS TABLE OF confidence_level_factor%rowtype
          index BY BINARY_INTEGER;

    PROCEDURE calc_confidence_level (ani_experiment_id  IN NUMBER DEFAULT NULL);

    FUNCTION  get_confidence_score (ani_experiment_id IN NUMBER,
                                    avi_sql     IN VARCHAR2)
              RETURN NUMBER;

    FUNCTION overall_score (ati_scores IN t_score,
                            ati_factors IN  t_factor)
              RETURN NUMBER;

    PROCEDURE save_confidence_level( ani_experiment_id  IN  NUMBER,
                                     ani_confidence_level IN  NUMBER);

    PROCEDURE save_confidence_score (ani_score  IN  number,
                                     ani_experiment_id  IN  number,
                                     ani_factor_id IN NUMBER);

    FUNCTION normalize_score (ani_score IN number,
                           ari_factor IN confidence_level_factor%rowtype)
              RETURN NUMBER;

END confidence_level_util;
/
CREATE OR REPLACE PACKAGE BODY DATA_MIG.confidence_level_util

AS
-------------------------------------------------------------------------
-- private procedures for internal use in this package
    procedure log_error
        (an_errnum   in  number,
         av_errmsg  in varchar2,
         av_location    in varchar2,
         av_comment in varchar2 default null)
    as
    begin
        insert into error_log
           ( ERROR_LOG_ID,
             ERROR_DATE,
             procedure_name,
             ERR_NUM,
             ERR_MSG,
             ERR_COMMENT
           ) values (
             ERROR_LOG_ID_SEQ.NEXTVAL,
             sysdate,
             av_location,
             an_errnum,
             av_errmsg,
             av_comment
           );


    EXCEPTION
        -- no errors are allowed to disturb the force
        when others
        then
            null;
    end log_error;

-------------------------------------------------------------------------------------------------
-- public procedures and functions
    PROCEDURE calc_confidence_level (ani_experiment_id  IN NUMBER DEFAULT NULL)
    AS
        CURSOR cur_experiment
        IS
        SELECT experiment_id, assay_id
          FROM experiment
          WHERE (experiment_id = ani_experiment_id
             OR ani_experiment_id IS NULL);

        CURSOR cur_factor
        IS
        SELECT *
          FROM confidence_level_factor
         WHERE score_SQL IS NOT null
         ORDER BY precidence, confidence_level_factor_id;

        lt_factor t_factor;
        lt_score t_score;
        ln_weighted_score NUMBER;

    BEGIN
        -- beware of limits here - if this table gets really big say 1000+ rows, you need to limit the fetch
        -- dbms_Output.put_line('opening factor cursor');
        OPEN cur_factor;
        FETCH cur_factor BULK COLLECT INTO lt_factor;
        CLOSE cur_factor;
        -- dbms_Output.put_line('got ALL factors');

        IF lt_factor.last IS NULL
        THEN return;
        END IF;

        -- dbms_Output.put_line('start experiment loop ' || To_Char(ani_experiment_id));
        FOR lr_experiment IN cur_experiment
        LOOP
            FOR i IN lt_factor.first ..lt_factor.last
            LOOP
                lt_score(i) := get_confidence_score (lr_experiment.experiment_id, lt_factor(i).score_sql);
                lt_score(i) := normalize_score( lt_score(i), lt_factor(i));

                save_confidence_score (lt_score(i), lr_experiment.experiment_id, lt_factor(i).confidence_level_factor_id);
            END LOOP;

            ln_weighted_score := overall_score (lt_score, lt_factor);

            save_confidence_level (lr_experiment.experiment_id, ln_weighted_score);

       END LOOP;

    EXCEPTION
    WHEN OTHERS THEN
        IF cur_factor%ISOPEN THEN CLOSE cur_factor; END if;
        IF cur_experiment%ISOPEN THEN CLOSE cur_experiment; END if;
        RAISE;
    END calc_confidence_level;

    FUNCTION  get_confidence_score (ani_experiment_id IN NUMBER,
                                    avi_sql     IN VARCHAR2)
              RETURN NUMBER
    AS
        ln_score  NUMBER;
        TYPE t_cursor IS REF CURSOR;
        cur_score t_cursor;

    BEGIN
        -- Open a cursor with the SQL using the experiment_id as a parameter
        -- The SQL must be
        --    1. a single row return (e.g. max, sum, count)
        --    2. a single numeric column return
        --    3. use only one parameter - experiment_id
        -- dbms_Output.put_line(avi_sql);

        OPEN cur_score FOR avi_sql USING ani_experiment_id;
        FETCH cur_score INTO ln_score;
        CLOSE cur_score;

        -- make sure we return something if the cursor has an empty set response
        RETURN Nvl(ln_score, 0);

    EXCEPTION
    WHEN OTHERS THEN
        log_error (sqlcode, 'Score_SQL failed', 'get_confidence_score',
            'experiment_id= ' || To_Char(ani_experiment_id)
            || ', Score_SQL= '|| avi_sql
            || ', SQLERRM= ' || SQLERRM );

        RETURN 0;

    END get_confidence_score;

    FUNCTION overall_score (ati_scores IN t_score,
                            ati_factors IN  t_factor)
              RETURN NUMBER
    AS
        ln_weighted_score  NUMBER := 0;
        ln_factor_score    NUMBER;
    BEGIN
        -- first remove the threshold from the number
        -- then proportion to a 100 point scale using the max level (note some scores may go over 100 points!)
        --
        -- if the score is above the measure necessary for precidence, then
        --   go on a calculate the other scores - THIS NEEDS SOME MORE THOUGHT.  **********  <<--
        -- and finally multiply by the weighting

        -- then sum them and proportion the number into a 1..5 range
        -- none of the input scores is allowed to be null.
        FOR i IN ati_factors.first ..ati_factors.last
        LOOP
            -- in this first implementation lets ignore precidence
            --    when we do need precidence:
            --    take all the first precidence numbers and average them
            --    if the average is over 50%, then use the second factors
            --    and so on...   MAYBE !!
            ln_factor_score := ati_scores(i) * ati_factors(i).weighting ;
            ln_weighted_score := ln_weighted_score + ln_factor_score;
        END LOOP;

        -- create the average
        ln_weighted_score := ln_weighted_score / ati_factors.last;

        -- and bucket this into a 1 - 5 integer score
        ln_weighted_score := Round(ln_weighted_score / 100 , 0);
        IF ln_weighted_score > 5
        THEN
            ln_weighted_score := 5;
        END IF;

        RETURN ln_weighted_score;

    END overall_score;

    FUNCTION normalize_score (ani_score IN number,
                           ari_factor IN confidence_level_factor%rowtype)
              RETURN NUMBER
    AS
        ln_factor_score NUMBER;

    BEGIN
        ln_factor_score := ani_score - Nvl(ari_factor.min_threshold,0);
        IF ln_factor_score < 0
        THEN
            ln_factor_score := 0;
        END IF;

        IF ari_factor.max_level > 0
        THEN
            ln_factor_score := Round(ln_factor_score / ari_factor.max_level * 100, 0);
        ELSE
            ln_factor_score := 0;
        END IF;

        RETURN ln_factor_score;

    END normalize_score;

    PROCEDURE save_confidence_level( ani_experiment_id  IN  NUMBER,
                                     ani_confidence_level IN  NUMBER)
    AS

    BEGIN

        UPDATE experiment
        SET confidence_level = ani_confidence_level
        WHERE experiment_id = ani_experiment_id;

    END save_confidence_level;

    PROCEDURE save_confidence_score (ani_score  IN  number,
                                     ani_experiment_id  IN  number,
                                     ani_factor_id IN NUMBER)
    AS

    BEGIN

        UPDATE confidence_level_score
        SET score = ani_score,
            version = version + 1,
            last_updated = SYSDATE
        WHERE experiment_id = ani_experiment_id
          AND confidence_level_factor_id = ani_factor_id;

        IF SQL%ROWCOUNT = 0
        then
            INSERT INTO confidence_level_score
                (confidence_level_score_id,
                confidence_level_factor_id,
                experiment_id,
                score,
                modified_by
                )
            VALUES
                (confidence_level_score_id_seq.nextval,
                ani_factor_id,
                ani_experiment_id,
                ani_score,
                Nvl(bard_context.get_username, Lower(USER))
                );

        END IF;

    END save_confidence_score;

END confidence_level_util;
/

--
-- PACKAGE: LOAD_DATA
--

CREATE OR REPLACE package DATA_MIG.load_data
as
    procedure reset_sequence;

    procedure Load_reference;

    procedure Load_assay (an_assay_id in number default null);

    procedure Load_assay_with_result (an_assay_id in number default null);

    procedure load_assay (av_assay_set in VARCHAR2,
                          ab_w_results  IN BOOLEAN DEFAULT false);

end load_data;
/
CREATE OR REPLACE package body DATA_MIG.load_data
as
    --------------------------------------------------------------------
    --  This depends on the source and targe schemas being identical (columns in same order in every table)
    --
    --  schatwin 7/2/12 initial version
    --
    --
    --
    --
    ----------------------------------------------------------------------
    procedure reset_sequence
    as
    cursor cur_sequence
    is
    select sequence_name
    from user_sequences
    WHERE sequence_name LIKE '%_ID_SEQ';

    lv_max_sql  varchar2(1000);
    lv_drop_sql varchar2(1000);
    lv_create_sql   varchar2(1000);
    lv_grant_sql    varchar2(1000);
    lv_table_name   varchar2(50);
    lv_primary_key  varchar2(50);
    ln_max_id   number;

begin
    for rec_sequence in cur_sequence
    loop
        lv_table_name := replace(rec_sequence.sequence_name, '_ID_SEQ', null);
        lv_primary_key := replace(rec_sequence.sequence_name, '_SEQ', null);

        lv_max_sql := 'select nvl(max(' || lv_primary_key || '), 0) from ' || lv_table_name;
        begin
            --dbms_output.put_line(lv_max_sql);
            EXECUTE IMMEDIATE lv_max_sql INTO ln_max_ID;

            lv_drop_sql := 'drop sequence ' || rec_sequence.sequence_name;
            --dbms_output.put_line(lv_drop_sql);
            EXECUTE IMMEDIATE lv_drop_sql;

            lv_create_sql := 'create sequence ' || rec_sequence.sequence_name
                    || ' start with ' || to_char(ln_max_id + 1)
                    || ' increment by 1 nominvalue maxvalue 9999999999 nocycle ';
            IF rec_sequence.sequence_name = 'RESULT_ID_SEQ'
            THEN
                lv_create_sql := lv_create_sql || 'cache 10000 noorder';
            ELSE
                lv_create_sql := lv_create_sql || 'cache 20 noorder';
            END IF;
            --dbms_output.put_line(lv_create_sql);

            lv_grant_sql := 'grant select on ' || rec_sequence.sequence_name
                    || ' to schatwin';
            --dbms_output.put_line(lv_grant_sql);
            EXECUTE IMMEDIATE lv_create_sql;
            EXECUTE IMMEDIATE lv_grant_sql;

        exception
            when others
            then
                null;   --dbms_output.put_line (to_char(sqlcode) || ', ' || sqlerrm);

        end;

    end loop;

    if cur_sequence%isopen
    then
        close cur_sequence;
    end if;

END reset_sequence;


    procedure Load_reference
    as
        cursor cur_element
        is
        select element_id from element;

        ln_element_id   number := null;

    begin
        -- load data for all the reference tables (the top level ones in RI)
        -- NOTE we use order SQL statements to make sure the self-referential FKs work OK
        --If any of these contains data skip the whole thing
        open cur_element;
        fetch cur_element into ln_element_id;
        close cur_element;

        if ln_element_id is null
        then

            insert into element
                (ELEMENT_ID,
                ELEMENT_STATUS,
                LABEL,
                DESCRIPTION,
                ABBREVIATION,
                SYNONYMS,
                UNIT_ID,
                BARD_URI,
                EXTERNAL_URL,
                READY_FOR_EXTRACTION,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select ELEMENT_ID,
                ELEMENT_STATUS,
                LABEL,
                DESCRIPTION,
                ABBREVIATION,
                SYNONYMS,
                UNIT_ID,      ----------------- WAIT FOR dATA mIG
                BARD_URI,
                EXTERNAL_URL,
                READY_FOR_EXTRACTION,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.element
            order by nvl(unit_ID, -1);

            insert into element_hierarchy
                (ELEMENT_HIERARCHY_ID,
                PARENT_ELEMENT_ID,
                CHILD_ELEMENT_ID,
                RELATIONSHIP_TYPE,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select ELEMENT_HIERARCHY_ID,
                PARENT_ELEMENT_ID,
                CHILD_ELEMENT_ID,
                RELATIONSHIP_TYPE,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
         from data_mig.element_hierarchy;

            insert into ontology
                (ONTOLOGY_ID,
                ONTOLOGY_NAME,
                ABBREVIATION,
                SYSTEM_URL,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select ONTOLOGY_ID,
                ONTOLOGY_NAME,
                ABBREVIATION,
                SYSTEM_URL,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.ontology;

            insert into tree_root
                (TREE_ROOT_ID,
                TREE_NAME,
                ELEMENT_ID,
                RELATIONSHIP_TYPE,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select TREE_ROOT_ID,
                TREE_NAME,
                ELEMENT_ID,
                RELATIONSHIP_TYPE,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.tree_root;

            insert into external_system
                (EXTERNAL_SYSTEM_ID,
                SYSTEM_NAME,
                OWNER,
                SYSTEM_URL,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select EXTERNAL_SYSTEM_ID,
                SYSTEM_NAME,
                OWNER,
                SYSTEM_URL,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.external_system;
            commit;

            insert into ontology_item
                (ONTOLOGY_ITEM_ID,
                ONTOLOGY_ID,
                ELEMENT_ID,
                ITEM_REFERENCE,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select ONTOLOGY_ITEM_ID,
                ONTOLOGY_ID,
                ELEMENT_ID,
                ITEM_REFERENCE,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.ontology_item;

            insert into unit_conversion
                (UNIT_CONVERSION_ID,
                FROM_UNIT_ID,
                TO_UNIT_ID,
                MULTIPLIER,
                OFFSET,
                FORMULA,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select UNIT_CONVERSION_ID,
                FROM_UNIT_ID,
                TO_UNIT_ID,
                MULTIPLIER,
                OFFSET,
                FORMULA,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.unit_conversion;

            insert into bard_tree (          NODE_ID,
                                             PARENT_NODE_ID,
                                             ELEMENT_ID,
                                             ELEMENT_STATUS,
                                             LABEL,
                                             IS_LEAF,
                                             FULL_PATH,
                                             DESCRIPTION,
                                             ABBREVIATION,
                                             SYNONYMS,
                                             EXTERNAL_URL,
                                             UNIT_ID
            )
              select
                NODE_ID,
                PARENT_NODE_ID,
                ELEMENT_ID,
                ELEMENT_STATUS,
                LABEL,
                IS_LEAF,
                FULL_PATH,
                DESCRIPTION,
                ABBREVIATION,
                SYNONYMS,
                EXTERNAL_URL,
                UNIT_ID
              from data_mig.bard_tree d where not exists ( select 1 from bard_tree s where s.node_id = d.node_id);

            manage_ontology.make_trees;
            commit;

            --reset_sequence;

        end if;


    end load_reference;

    procedure Load_assay_with_result (an_assay_id in number default null)
    as
        cursor cur_assay
        is
        select assay_id from data_mig.assay
        where assay_id = an_assay_id
        or an_assay_id is null;

        cursor cur_experiment (cn_assay_id number)
        is
        select experiment_id
        from data_mig.experiment
        where assay_id = cn_assay_id;

    begin

        load_assay (an_assay_id);

        for rec_assay in cur_assay
        LOOP
             -- insert into assay
             -- insert into assay_document
             -- insert into assay_context
             -- insert into measure
             -- insert into assay_context_item
             -- loop over experiments
                -- insert into experiment
                -- insert into external_reference
                -- insert into project (??)
                -- insert into project_step


            for rec_experiment in cur_experiment(rec_assay.assay_id)
            loop
                insert into result
                    (RESULT_ID,
                    RESULT_STATUS,
                    READY_FOR_EXTRACTION,
                    REPLICATE_NO,
                    VALUE_DISPLAY,
                    VALUE_NUM,
                    VALUE_MIN,
                    VALUE_MAX,
                    QUALIFIER,
                    EXPERIMENT_ID,
                    SUBSTANCE_ID,
                    RESULT_TYPE_ID,
                    STATS_MODIFIER_ID,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select RESULT_ID,
                    RESULT_STATUS,
                    READY_FOR_EXTRACTION,
                    REPLICATE_NO,
                    VALUE_DISPLAY,
                    VALUE_NUM,
                    VALUE_MIN,
                    VALUE_MAX,
                    QUALIFIER,
                    EXPERIMENT_ID,
                    SUBSTANCE_ID,
                    RESULT_TYPE_ID,
                    STATS_MODIFIER_ID,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.result
                where experiment_id = rec_experiment.experiment_id;

                insert into rslt_context_item
                    (RSLT_CONTEXT_ITEM_ID,
                    DISPLAY_ORDER,
                    RESULT_ID,
                    ATTRIBUTE_ID,
                    VALUE_ID,
                    EXT_VALUE_ID,
                    QUALIFIER,
                    VALUE_NUM,
                    VALUE_MIN,
                    VALUE_MAX,
                    VALUE_DISPLAY,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select RSLT_CONTEXT_ITEM_ID,
                    DISPLAY_ORDER,
                    RESULT_ID,
                    ATTRIBUTE_ID,
                    VALUE_ID,
                    EXT_VALUE_ID,
                    QUALIFIER,
                    VALUE_NUM,
                    VALUE_MIN,
                    VALUE_MAX,
                    VALUE_DISPLAY,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.rslt_context_item  rci
                where EXISTS (SELECT 1
                      FROM data_mig.result r
                      WHERE r.result_id = rci.result_id
                        AND r.experiment_id = rec_experiment.experiment_id);

                -- ASSUMES ALL HIERARCHIES EXIST ONLY WITHIN THE CONTEXT OF AN EXPERIMENT
                insert into result_hierarchy
                    (RESULT_HIERARCHY_ID,
                    RESULT_ID,
                    PARENT_RESULT_ID,
                    HIERARCHY_TYPE,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select RESULT_HIERARCHY_ID,
                    RESULT_ID,
                    PARENT_RESULT_ID,
                    HIERARCHY_TYPE,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.result_hierarchy rh
                where EXISTS (SELECT 1
                        FROM data_mig.result r
                        WHERE r.result_id = rh.result_id
                        AND r.experiment_id = rec_experiment.experiment_id);


            end loop;

            commit; -- for each assay

        end loop;

        -- insert into external_reference (for projects)
        -- insert into project_context_item (for both steps and projects)
        -- pick up any projects that have no descendant experiments

        -- loop again to get the project experiments
        -- with predecessors

        -- reset_sequence;

    end load_assay_with_result;

    procedure Load_assay (an_assay_id in number default null)
    as
        cursor cur_assay
        is
        select assay_id from data_mig.assay
        where assay_id = an_assay_id
        or an_assay_id is null;

        cursor cur_experiment (cn_assay_id number)
        is
        select experiment_id
        from data_mig.experiment
        where assay_id = cn_assay_id;

    begin
        if an_assay_id is null
        then
            begin
               load_reference;    -- this could be handled on the fly, but we want them all
            exception
            when others
            then
                null;   --trap the error if reference is already loaded
            end;
        end if;

        for rec_assay in cur_assay
        loop
            insert into assay
                (ASSAY_ID,
                ASSAY_STATUS,
                ASSAY_SHORT_NAME,
                ASSAY_NAME,
                ASSAY_VERSION,
                ASSAY_TYPE,
                DESIGNED_BY,
                READY_FOR_EXTRACTION,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select ASSAY_ID,
                ASSAY_STATUS,
                ASSAY_SHORT_NAME,
                ASSAY_NAME,
                ASSAY_VERSION,
                ASSAY_TYPE,
                DESIGNED_BY,
                READY_FOR_EXTRACTION,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.assay
            where assay_id = rec_assay.assay_id;

            insert into assay_document
                (ASSAY_DOCUMENT_ID,
                ASSAY_ID,
                DOCUMENT_NAME,
                DOCUMENT_TYPE,
                DOCUMENT_CONTENT,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select ASSAY_DOCUMENT_ID,
                ASSAY_ID,
                DOCUMENT_NAME,
                DOCUMENT_TYPE,
                DOCUMENT_CONTENT,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.assay_document
            where assay_id = rec_assay.assay_id;

            insert into assay_context
                (ASSAY_CONTEXT_ID,
                ASSAY_ID,
                CONTEXT_NAME,
                CONTEXT_GROUP,
                DISPLAY_ORDER,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select ASSAY_CONTEXT_ID,
                ASSAY_ID,
                CONTEXT_NAME,
                CONTEXT_GROUP,
                DISPLAY_ORDER,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.assay_context
            where assay_id = rec_assay.assay_id;

            insert into measure
                (MEASURE_ID,
                ASSAY_ID,
                PARENT_MEASURE_ID,
                RESULT_TYPE_ID,
                STATS_MODIFIER_ID,
                ENTRY_UNIT_ID,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select MEASURE_ID,
                ASSAY_ID,
                PARENT_MEASURE_ID,
                RESULT_TYPE_ID,
                STATS_MODIFIER_ID,
                ENTRY_UNIT_ID,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.measure
            where assay_id = rec_assay.assay_id
            connect by prior measure_id = parent_measure_id
            start with (parent_measure_id is NULL
                    OR parent_measure_id = measure_id);

            for rec_experiment in cur_experiment(rec_assay.assay_id)
            loop
                insert into experiment
                    (EXPERIMENT_ID,
                    EXPERIMENT_NAME,
                    EXPERIMENT_STATUS,
                    READY_FOR_EXTRACTION,
                    CONFIDENCE_LEVEL,
                    ASSAY_ID,
                    RUN_DATE_FROM,
                    RUN_DATE_TO,
                    HOLD_UNTIL_DATE,
                    DESCRIPTION,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select EXPERIMENT_ID,
                    EXPERIMENT_NAME,
                    EXPERIMENT_STATUS,
                    READY_FOR_EXTRACTION,
                    CONFIDENCE_LEVEL,
                    ASSAY_ID,
                    RUN_DATE_FROM,
                    RUN_DATE_TO,
                    HOLD_UNTIL_DATE,
                    DESCRIPTION,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.experiment
                where experiment_id = rec_experiment.experiment_id;

                INSERT INTO exprmt_context
                    (exprmt_context_id,
                    experiment_id,
                    context_name,
                    context_group,
                    version,
                    date_created,
                    last_updated,
                    modified_by
                    )
                SELECT exprmt_context_id,
                    experiment_id,
                    context_name,
                    context_group,
                    version,
                    date_created,
                    last_updated,
                    modified_by
                FROM data_mig.exprmt_context
                WHERE experiment_id = rec_experiment.experiment_id;

                INSERT INTO exprmt_measure
                    (exprmt_measure_id,
                    experiment_id,
                    measure_id,
                    parent_exprmt_measure_id,
                    parent_child_relationship,
                    version,
                    date_created,
                    last_updated,
                    modified_by
                    )
                SELECT exprmt_measure_id,
                    experiment_id,
                    measure_id,
                    parent_exprmt_measure_id,
                    parent_child_relationship,
                    version,
                    date_created,
                    last_updated,
                    modified_by
                FROM data_mig.exprmt_measure
                WHERE experiment_id = rec_experiment.experiment_id
                ORDER BY Nvl(parent_exprmt_measure_id, 0);

                insert into project
                    (PROJECT_ID,
                    PROJECT_NAME,
                    GROUP_TYPE,
                    DESCRIPTION,
                    READY_FOR_EXTRACTION,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select PROJECT_ID,
                    PROJECT_NAME,
                    GROUP_TYPE,
                    DESCRIPTION,
                    READY_FOR_EXTRACTION,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.project dp
                where project_id in
                    (select project_id from data_mig.project_experiment
                     where experiment_id = rec_experiment.experiment_id)
                 and not exists (select 1 from project p
                            where p.project_id = dp.project_id);

                insert into project_experiment
                    (PROJECT_EXPERIMENT_ID,
                    PROJECT_ID,
                    EXPERIMENT_ID,
                    STAGE_ID,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select PROJECT_EXPERIMENT_ID,
                    PROJECT_ID,
                    EXPERIMENT_ID,
                    STAGE_ID,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.project_EXPERIMENT pe
                where experiment_id = rec_experiment.experiment_id
                  AND NOT EXISTS (SELECT 1
                          FROM project_EXPERIMENT ps
                          WHERE ps.project_experiment_id = pe.project_experiment_id);

                -- assumes all the external systems have been loaded (see load_reference)
                insert into external_reference
                    (EXTERNAL_REFERENCE_ID,
                    EXTERNAL_SYSTEM_ID,
                    EXPERIMENT_ID,
                    PROJECT_ID,
                    EXT_ASSAY_REF,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select EXTERNAL_REFERENCE_ID,
                    EXTERNAL_SYSTEM_ID,
                    EXPERIMENT_ID,
                    PROJECT_ID,
                    EXT_ASSAY_REF,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.external_reference
                where experiment_id = rec_experiment.experiment_id;


            end loop;   -- for each experiment


            commit; -- for each assay

        end loop;

         IF an_assay_id IS NULL
         then--- insert into project (for all ones not loaded yet)
              insert into project
                  (PROJECT_ID,
                  PROJECT_NAME,
                  GROUP_TYPE,
                  DESCRIPTION,
                  READY_FOR_EXTRACTION,
                  VERSION,
                  DATE_CREATED,
                  LAST_UPDATED,
                  MODIFIED_BY)
              select PROJECT_ID,
                  PROJECT_NAME,
                  GROUP_TYPE,
                  DESCRIPTION,
                  READY_FOR_EXTRACTION,
                  VERSION,
                  DATE_CREATED,
                  LAST_UPDATED,
                  MODIFIED_BY
              from data_mig.project p
              where not exists (select 1
                      from project pp
                      where pp.project_id = p.project_id);

              insert into external_reference
                    (EXTERNAL_REFERENCE_ID,
                    EXTERNAL_SYSTEM_ID,
                    EXPERIMENT_ID,
                    PROJECT_ID,
                    EXT_ASSAY_REF,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY)
                select EXTERNAL_REFERENCE_ID,
                    EXTERNAL_SYSTEM_ID,
                    EXPERIMENT_ID,
                    PROJECT_ID,
                    EXT_ASSAY_REF,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
                from data_mig.external_reference der
                where project_id in
                        (select project_id from project)
                  and not exists (select 1 from external_reference er
                        where er.external_reference_id = der.external_reference_id);

        END IF;

        INSERT INTO project_step
               (project_step_id,
                next_project_experiment_id,
                prev_project_experiment_id,
                edge_name,
                version,
                date_created,
                last_updated,
                modified_by)
        SELECT  project_step_id,
                next_project_experiment_id,
                prev_project_experiment_id,
                edge_name,
                version,
                date_created,
                last_updated,
                modified_by
        FROM data_mig.project_step ps
        WHERE EXISTS (SELECT 1
            FROM project_experiment pe
            WHERE ps.next_project_experiment_id = pe.project_experiment_id)
         AND exists (SELECT 1
            FROM project_experiment pe
            WHERE ps.prev_project_experiment_id = pe.project_experiment_id)
         AND NOT EXISTS (SELECT 1
            from project_step ps2
            WHERE ps2.project_step_id = ps.project_step_id);

        INSERT INTO project_experiment
            SELECT PROJECT_EXPERIMENT_ID ,
                    EXPERIMENT_ID,
                    PROJECT_ID,
                    STAGE_ID,
                    VERSION,
                    DATE_CREATED,
                    LAST_UPDATED,
                    MODIFIED_BY
            FROM data_mig.project_experiment pe
            WHERE EXISTS (select 1 from experiment e
                        where e.experiment_id = pe.experiment_id)
              AND EXISTS (select 1 from project e
                        where e.project_id = pe.project_id)
              AND NOT EXISTS (select 1 from project_experiment e
                        where e.project_experiment_id = pe.project_experiment_id);


        INSERT INTO assay_context_measure
              (assay_context_measure_id,
              assay_context_id,
              measure_id,
              version,
              date_created,
              last_updated,
              modified_by)
        SELECT
              assay_context_measure_id,
              assay_context_id,
              measure_id,
              version,
              date_created,
              last_updated,
              modified_by
        from data_mig.assay_context_measure acm
        where NOT EXISTS (SELECT 1
                FROM assay_context_measure acm2
                WHERE acm2.assay_context_measure_id = acm.assay_context_measure_id)
          AND EXISTS (SELECT 1
                FROM assay_context ac
                WHERE ac.assay_context_id = acm.assay_context_id)
          AND eXISTS (SELECT 1
                FROM measure ac
                WHERE ac.measure_id = acm.measure_id);


        insert into project_document
            (PROJECT_DOCUMENT_ID,
            PROJECT_ID,
            DOCUMENT_NAME,
            DOCUMENT_TYPE,
            DOCUMENT_CONTENT,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY)
        select PROJECT_DOCUMENT_ID,
            PROJECT_ID,
            DOCUMENT_NAME,
            DOCUMENT_TYPE,
            DOCUMENT_CONTENT,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
        from data_mig.project_document dpd
        where EXISTS (SELECT 1
                  FROM project p
                  WHERE p.project_id = dpd.project_id)
          AND NOT EXISTS (SELECT 1
                  FROM project_document pd
                  WHERE pd.project_document_id = dpd.project_document_id);

        -- insert project context
        insert into project_context
            (PROJECT_CONTEXT_ID,
            PROJECT_ID,
            CONTEXT_NAME,
            CONTEXT_GROUP,
            DISPLAY_ORDER,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY)
        select PROJECT_CONTEXT_ID,
            PROJECT_ID,
            CONTEXT_NAME,
            CONTEXT_GROUP,
            DISPLAY_ORDER,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
        from data_mig.project_context dpc
        where EXISTS (SELECT 1
                      FROM project p
                      WHERE p.project_id = dpc.project_id)
          AND NOT EXISTS (SELECT 1
                      FROM project_context pc
                      WHERE pc.project_context_id = dpc.project_context_id);

        insert into project_context_item
            (PROJECT_CONTEXT_ITEM_ID,
            PROJECT_CONTEXT_ID,
            DISPLAY_ORDER,
            ATTRIBUTE_ID,
            VALUE_ID,
            EXT_VALUE_ID,
            QUALIFIER,
            VALUE_DISPLAY,
            VALUE_NUM,
            VALUE_MIN,
            VALUE_MAX,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
            )
        select PROJECT_CONTEXT_ITEM_ID,
            PROJECT_CONTEXT_ID,
            DISPLAY_ORDER,
            ATTRIBUTE_ID,
            VALUE_ID,
            EXT_VALUE_ID,
            QUALIFIER,
            VALUE_DISPLAY,
            VALUE_NUM,
            VALUE_MIN,
            VALUE_MAX,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
        from data_mig.project_context_item dpci
        where NOT EXISTS (SELECT 1
                      FROM project_context_item pci
                      WHERE pci.project_context_item_id = dpci.project_context_item_id)
          AND EXISTS (SELECT 1
                      FROM project_context pc
                      WHERE pc.project_context_id = dpci.project_context_id);

        -- insert prjct_exprmt context
        insert into prjct_exprmt_context
            (prjct_exprmt_CONTEXT_ID,
            PROJECT_EXPERIMENT_ID,
            CONTEXT_NAME,
            CONTEXT_GROUP,
            DISPLAY_ORDER,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY)
        select prjct_exprmt_CONTEXT_ID,
            PROJECT_EXPERIMENT_ID,
            CONTEXT_NAME,
            CONTEXT_GROUP,
            DISPLAY_ORDER,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
        from data_mig.prjct_exprmt_context dpc
        where EXISTS (SELECT 1
                      FROM project_experiment p
                      WHERE p.project_experiment_id = dpc.project_experiment_id)
          AND NOT EXISTS (SELECT 1
                      FROM prjct_exprmt_context pc
                      WHERE pc.prjct_exprmt_CONTEXT_ID = dpc.prjct_exprmt_CONTEXT_ID);

        insert into prjct_exprmt_cntxt_item
            (prjct_exprmt_cntxt_ITEM_ID,
            PRJCT_EXPRMT_CONTEXT_ID,
            DISPLAY_ORDER,
            ATTRIBUTE_ID,
            VALUE_ID,
            EXT_VALUE_ID,
            QUALIFIER,
            VALUE_DISPLAY,
            VALUE_NUM,
            VALUE_MIN,
            VALUE_MAX,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
            )
        select prjct_exprmt_cntxt_ITEM_ID,
            PRJCT_EXPRMT_CONTEXT_ID,
            DISPLAY_ORDER,
            ATTRIBUTE_ID,
            VALUE_ID,
            EXT_VALUE_ID,
            QUALIFIER,
            VALUE_DISPLAY,
            VALUE_NUM,
            VALUE_MIN,
            VALUE_MAX,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
        from data_mig.prjct_exprmt_cntxt_item dpci
        where NOT EXISTS (SELECT 1
                      FROM prjct_exprmt_cntxt_item pci
                      WHERE pci.prjct_exprmt_cntxt_ITEM_ID = dpci.prjct_exprmt_cntxt_ITEM_ID)
          AND EXISTS (SELECT 1
                      FROM prjct_exprmt_context pc
                      WHERE pc.PRJCT_EXPRMT_CONTEXT_ID = dpci.PRJCT_EXPRMT_CONTEXT_ID);

        insert into assay_context_item
            (ASSAY_CONTEXT_ITEM_ID,
            DISPLAY_ORDER,
            ASSAY_CONTEXT_ID,
            ATTRIBUTE_TYPE,
            ATTRIBUTE_ID,
            QUALIFIER,
            VALUE_ID,
            EXT_VALUE_ID,
            VALUE_DISPLAY,
            VALUE_NUM,
            VALUE_MIN,
            VALUE_MAX,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY)
        select ASSAY_CONTEXT_ITEM_ID,
            DISPLAY_ORDER,
            ASSAY_CONTEXT_ID,
            ATTRIBUTE_TYPE,
            ATTRIBUTE_ID,
            QUALIFIER,
            VALUE_ID,
            EXT_VALUE_ID,
            VALUE_DISPLAY,
            VALUE_NUM,
            VALUE_MIN,
            VALUE_MAX,
            VERSION,
            DATE_CREATED,
            LAST_UPDATED,
            MODIFIED_BY
        from data_mig.assay_context_item  aci
        where EXISTS (SELECT 1
                    from assay_context ac
                    where ac.assay_context_id = aci.assay_context_id)
          AND NOT EXISTS (SELECT 1
                    from assay_context_item aci2
                    where aci2.assay_context_Item_id = aci.assay_context_item_id);


        INSERT INTO exprmt_context_Item
              (EXPRMT_CONTEXT_ITEM_ID,
                EXPRMT_CONTEXT_ID,
                DISPLAY_ORDER,
                ATTRIBUTE_ID,
                VALUE_ID,
                EXT_VALUE_ID,
                QUALIFIER,
                VALUE_NUM,
                VALUE_MIN,
                VALUE_MAX,
                VALUE_DISPLAY,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
          SELECT EXPRMT_CONTEXT_ITEM_ID,
                EXPRMT_CONTEXT_ID,
                DISPLAY_ORDER,
                ATTRIBUTE_ID,
                VALUE_ID,
                EXT_VALUE_ID,
                QUALIFIER,
                VALUE_NUM,
                VALUE_MIN,
                VALUE_MAX,
                VALUE_DISPLAY,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
          FROM data_mig.exprmt_CONTEXT_ITEM  eci
          WHERE EXISTS (SELECT 1
                    from exprmt_context ec
                    where eci.exprmt_context_id = eci.exprmt_context_id)
            AND NOT EXISTS (SELECT 1
                    from exprmt_context_item eci2
                    where eci2.exprmt_context_Item_id = eci.exprmt_context_item_id);

          INSERT INTO project_step
              (PROJECT_STEP_ID,
              VERSION,
              NEXT_PROJECT_EXPERIMENT_ID,
              PREV_PROJECT_EXPERIMENT_ID,
              DATE_CREATED,
              EDGE_NAME,
              LAST_UPDATED,
              MODIFIED_BY)
          SELECT PROJECT_STEP_ID,
              VERSION,
              NEXT_PROJECT_EXPERIMENT_ID,
              PREV_PROJECT_EXPERIMENT_ID,
              DATE_CREATED,
              EDGE_NAME,
              LAST_UPDATED,
              MODIFIED_BY
          FROM data_mig.project_step ps
          WHERE NOT EXISTS (SELECT 1
                    FROM project_step ps2
                    WHERE ps2.project_step_id = ps.project_step_id)
            AND EXISTS (SELECT 1
                    FROM project_experiment pe
                    WHERE pe.project_experiment_id = ps.prev_project_experiment_id)
            AND EXISTS (SELECT 1
                    FROM project_experiment pe
                    WHERE pe.project_experiment_id = ps.next_project_experiment_id);

                    -- insert step context
            insert into step_context
                (STEP_CONTEXT_ID,
                PROJECT_STEP_ID,
                CONTEXT_NAME,
                CONTEXT_GROUP,
                DISPLAY_ORDER,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select STEP_CONTEXT_ID,
                PROJECT_STEP_ID,
                CONTEXT_NAME,
                CONTEXT_GROUP,
                DISPLAY_ORDER,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.step_context dpc
            where EXISTS (SELECT 1
                          FROM project_step p
                          WHERE p.project_step_id = dpc.project_step_id)
              AND NOT EXISTS (SELECT 1
                          FROM step_context pc
                          WHERE pc.step_context_id = dpc.step_context_id);

            insert into step_context_item
                (STEP_CONTEXT_ITEM_ID,
                STEP_CONTEXT_ID,
                DISPLAY_ORDER,
                ATTRIBUTE_ID,
                VALUE_ID,
                EXT_VALUE_ID,
                QUALIFIER,
                VALUE_DISPLAY,
                VALUE_NUM,
                VALUE_MIN,
                VALUE_MAX,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY)
            select STEP_CONTEXT_ITEM_ID,
                STEP_CONTEXT_ID,
                DISPLAY_ORDER,
                ATTRIBUTE_ID,
                VALUE_ID,
                EXT_VALUE_ID,
                QUALIFIER,
                VALUE_DISPLAY,
                VALUE_NUM,
                VALUE_MIN,
                VALUE_MAX,
                VERSION,
                DATE_CREATED,
                LAST_UPDATED,
                MODIFIED_BY
            from data_mig.step_context_item dpci
            where NOT EXISTS (SELECT 1
                          FROM step_context_item pci
                          WHERE pci.step_context_item_id = dpci.step_context_item_id)
              AND EXISTS (SELECT 1
                          FROM step_context pc
                          WHERE pc.step_context_id = dpci.step_context_id);


        commit;

    end load_assay;

    procedure load_assay (av_assay_set in varchar2,
                          ab_w_results  IN BOOLEAN DEFAULT false)
    as
    -- this version parses the string into an array and then calls the assay by assay version
        TYPE t_assay_id IS TABLE OF NUMBER(19) INDEX BY BINARY_INTEGER;
        la_assay_ids   t_assay_id;
        lv_number       VARCHAR2(38);
        lv_assay_set    VARCHAR2(4000);
        ln_pos          number;
        lv_range_separator    char(1) := ',';
        i         BINARY_INTEGER;
        ln_limit  binary_integer := 0;

        function is_numeric (lv_string in varchar2) return boolean
        as
            -- watch for null propogation, nulls tanslate to true
            ln_number   number;
        begin
            ln_number := to_number(lv_string);
            return true;

        exception
            when others
            then
                return false;
        end is_numeric;

    BEGIN
        lv_assay_set := av_assay_set;
        WHILE Length(lv_assay_set) >0
        loop
            ln_pos := instr(lv_assay_set, lv_range_separator);
            if ln_pos = 0
            then
                ln_pos := Length(lv_assay_set)+1;
            end if;

            lv_number := trim(substr(lv_assay_set, 1, ln_pos - 1));
            lv_assay_set := trim(substr(lv_assay_set, ln_pos + 1));

            if is_numeric(lv_number)
            then
               ln_limit := ln_limit +1;
               la_assay_ids(ln_limit) := to_number(lv_number);
             END IF;
        END LOOP;

        for i IN 1 .. ln_limit
        loop
            if i = 1
            then
                begin
                    load_reference;    -- this could be handled on the fly, but we want them all
                exception
                when others
                then
                    null;   --trap the error if reference is already loaded
                end;
            end if;

            IF ab_w_results
            THEN
                load_assay_with_result (la_assay_ids(i) );
            ELSE
                load_assay (la_assay_ids(i) );
            END IF;

            commit;

        end loop;

        reset_sequence;

     end load_assay;
end load_data;
/

--
-- PACKAGE: MANAGE_NAMES
--

CREATE OR REPLACE PACKAGE manage_names
AS
    type r_context IS RECORD (context_id assay_context.assay_context_id%type,
                         context_name assay_context.context_name%TYPE,
                         context_group assay_context.context_group%TYPE);

    TYPE t_contexts IS TABLE OF r_context
        index BY BINARY_INTEGER;

    procedure update_assay_short_name (ani_assay_id IN NUMBER  DEFAULT NULL);

    PROCEDURE update_context_name (an_assay_id IN NUMBER DEFAULT NULL);
    PROCEDURE update_context_group (an_assay_id IN NUMBER DEFAULT NULL);

    PROCEDURE update_project_context_name (an_project_id IN NUMBER DEFAULT NULL);
    PROCEDURE update_project_context_group (an_project_id IN NUMBER DEFAULT NULL);

    PROCEDURE update_exprmt_context_name (an_exprmt_id IN NUMBER DEFAULT NULL);
    PROCEDURE update_exprmt_context_group (an_exprmt_id IN NUMBER DEFAULT NULL);

    PROCEDURE update_step_context_name (an_project_step_id IN NUMBER DEFAULT NULL);
    PROCEDURE update_step_context_group (an_project_step_id IN NUMBER DEFAULT NULL);

-----------------------------------------------------------------------------------
-- these should all be private procedures  when in production
-----------------------------------------------------------------------------------
    PROCEDURE make_context_name
          (an_assay_id IN NUMBER,
           ato_contexts OUT t_contexts);

    PROCEDURE make_project_context_name
          (an_project_id IN NUMBER,
           ato_contexts OUT t_contexts);

    PROCEDURE make_exprmt_context_name
          (an_exprmt_id IN NUMBER,
           ato_contexts OUT t_contexts);

    PROCEDURE make_step_context_name
          (an_project_step_id IN NUMBER,
           ato_contexts OUT t_contexts);

END manage_names;
/
CREATE OR REPLACE PACKAGE BODY DATA_MIG.manage_names
AS
       ---------------------------------------------------------------------------------------------------

    FUNCTION add_term (avi_string IN VARCHAR2,
                      avi_term IN VARCHAR2)
            RETURN VARCHAR2
    AS
        lv_return VARCHAR2(1000);
        lv_many_suffix VARCHAR2 (10) := 'et al';
    BEGIN
        IF avi_string IS NULL
        THEN
              lv_return := avi_term;
        ELSIF SubStr(avi_string, - Length(lv_many_suffix)) = lv_many_suffix
        THEN
              lv_return := avi_string;
        ELSIF InStr(avi_string, avi_term) > 0
        THEN
              lv_return := avi_string;
        ELSE
              lv_return := avi_string || ' ' || lv_many_suffix;
        END IF;

        RETURN lv_return;
    END add_term;

    PROCEDURE make_context_name
      (an_assay_id IN NUMBER,
       ato_contexts OUT t_contexts)


    AS
    -------------------------------------------------------------------------------------------------------------
    --   make context name
    --     parameter:  Assay_ID.  if no assay_id is given then all assays in the DB are updated
    --
    --     This uses a set of arbitrary rules that appear to make sense for most cases
    --     1. if there's only 1 item, name the context for the item
    --     2. for components, name for the role or the type in that order
    --     3. for biology (secondary to components) use the cell, protein or other type of macromolcule
    --     4. for experiment contexts, use the most common attribute name (usually the one with the longest list)
    --
    --    schatwin    intial version    12-15-2012
    --    schatwin    exclude Annotation ones   1-21-2013
    --    schatwin    rename Annotation nes with commonest attribute name
    --
    --
    -------------------------------------------------------------------------------------------------------------
        CURSOR cur_assay_context (cn_assay_id IN NUMBER)
        IS
        SELECT grp_attr.assay_id,
          grp_attr.assay_context_id,
          Sum(grp_attr.aci_count) aci_count,
          LISTAGG(grp_attr.ATTRIBUTE || '$# ' || grp_attr.ATTRIBUTE_TYPE, ';') WITHIN GROUP (ORDER BY grp_attr.aci_count desc) attributes
        FROM (SELECT ac.assay_id,
                ac.assay_context_id,
                e.label attribute,
                aci.attribute_type,
                Count(*) aci_count
                FROM assay_context ac,
                    assay_context_item aci,
                    element e
                WHERE aci.assay_context_id = ac.assay_context_id
                  AND e.element_id = aci.attribute_id
                  AND ac.assay_id = cn_assay_id
                GROUP BY ac.assay_id,
                      ac.assay_context_id,
                      e.label,
                      aci.attribute_type) grp_attr
        GROUP BY grp_attr.assay_id,
                grp_attr.assay_context_id;

        lv_context_name  element.label%TYPE;
        lv_context_group  assay_context.context_group%TYPE;
        i   BINARY_INTEGER := 0;

    BEGIN
        -- get a list of assay_contexts with a count of the items
          FOR lr_assay_context IN cur_assay_context (an_assay_id)
          LOOP
              IF lr_assay_context.aci_count = 1
              THEN
    --    if count of items = 1
    --    then set name  = attribute label
                  SELECT label
                  INTO lv_context_name
                  FROM element e,
                      assay_context_item aci
                  WHERE aci.assay_context_id = lr_assay_context.assay_context_id
                    -- we're guaranteed just one from the count(*) in the curosr
                    AND e.element_id = aci.attribute_id;

                  SELECT SubStr(full_path, InStr(full_path, '>') +2, InStr(full_path, '>', 1,3)-InStr(full_path, '>'))
                  INTO lv_context_group
                  FROM bard_tree
                  WHERE label = lv_context_name
                  AND ROWNUM = 1;

                  lv_context_group := Nvl(lv_context_group, 'unclassified>');

            ELSIF lr_assay_context.attributes LIKE '%assay component role%'
            THEN
    --    if group contains 'assay component role'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM assay_context_item
                WHERE assay_context_id = lr_assay_context.assay_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component role')
                  AND ROWNUM = 1;

                  lv_context_group := 'assay protocol> assay component>';

            ELSIF lr_assay_context.attributes LIKE '%assay component type%'
            THEN
    --    if group contains 'assay component type'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM assay_context_item
                WHERE assay_context_id = lr_assay_context.assay_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component type')
                  AND ROWNUM = 1;

                  lv_context_group := 'assay protocol> assay component>';

            ELSIF lr_assay_context.attributes LIKE '%detection%'
            THEN
    --    if group contains 'detection'
    --    then set name = value
                lv_context_name := 'detection method';

                lv_context_group := 'assay protocol> assay readout>';

            ELSIF lr_assay_context.attributes LIKE '%List%'
                OR lr_assay_context.attributes LIKE '%Free%'
                OR lr_assay_context.attributes LIKE '%Range%'
            THEN
    --    if group contains items that are set in the Experiment
    --    then set name to the plural of the the most common attribute
    --    the query makes this the first attribute listed
                  lv_context_name := SubStr(lr_assay_context.attributes, 1, InStr(lr_assay_context.attributes, '$# ' ) - 1) || 's';

                  lv_context_group := 'project management> experiment>';


            ELSIF lr_assay_context.attributes LIKE '%readout%'
            THEN
    --    if group contains 'assay readout'
    --    then set name = value
                lv_context_name := 'assay readout';

                lv_context_group := 'assay protocol> assay readout>';

            ELSIF lr_assay_context.attributes LIKE '%wavelength%'
            THEN
    --    if group contains 'fluorescence/luminescence'
    --    then set name = value
                lv_context_name := 'fluorescence/luminescence';

                lv_context_group := 'assay protocol> assay design>';

            ELSIF lr_assay_context.attributes LIKE '%number%'
            THEN
    --    if group contains 'number'
    --    then set name = value
                lv_context_name := 'result detail';

                lv_context_group := 'project management> experiment>';

            ELSIF lr_assay_context.attributes LIKE '%biolog%'
            THEN
    --    if group contains 'biology/ical'
    --    then set name = value
                lv_context_name := 'biology';

                lv_context_group := 'biology>';

            ELSIF lr_assay_context.attributes LIKE '%protein%'
                OR lr_assay_context.attributes LIKE '%gene%'
                OR lr_assay_context.attributes LIKE '%cell%'
            THEN
    --    if group contains 'protein'
    --    then set name = value
                lv_context_name := 'biological component';
                lv_context_group := 'biology>';

            ELSIF lr_assay_context.attributes LIKE '%assay format%'
                    OR
                  lr_assay_context.attributes LIKE '%assay type%'
            THEN
    --    if group contains 'assay format'
    --    then set name = 'assay protocol'
                lv_context_name := 'assay protocol';
                lv_context_group := 'assay protocol> assay format>';

            ELSE
                --lv_context_name := NULL;
                lv_context_name := 'Type a name here';
                lv_context_group := 'unclassified>';
            END IF;

            IF lv_context_name IS NOT NULL
            THEN
                i := i + 1;
                ato_contexts(i).context_id := lr_assay_context.assay_context_id;
                ato_contexts(i).context_name := lv_context_name;
                ato_contexts(i).context_group := lv_context_group;

--              UPDATE assay_context ac
--              SET context_name = lv_context_name,
--                  context_group = lv_context_group
--              WHERE assay_context_id = lr_assay_context.assay_context_id;

            END IF;

          END LOOP;

          --commit;

    END make_context_name;

    PROCEDURE update_context_name
      (an_assay_id IN NUMBER DEFAULT NULL)

    AS
    -------------------------------------------------------------------------------------------------------------
    --   update context name
    --     parameter:  Assay_ID.  if no assay_id is given then all assays in the DB are updated
    --
    --     This uses loops thru the assays getting names and
    --    applying them to the contexts
    --
    --    schatwin    intial version    12-15-2012
    --    schatwin    exclude Annotation ones   1-21-2013
    --    schatwin    rename Annotation nes with commonest attribute name
    --    schatwin    converted from a procedure to a package   4-17-2013
    --
    -------------------------------------------------------------------------------------------------------------
        CURSOR cur_assay (cn_assay_id IN NUMBER)
        IS
        SELECT DISTINCT assay_id
        FROM assay_context ac
        WHERE ac.assay_id = Nvl(cn_assay_id, ac.assay_id);

        lv_context_name  element.label%TYPE;
        lv_context_group  assay_context.context_group%TYPE;
        lt_contexts       t_contexts;

    BEGIN
        -- get a list of assay_contexts with a count of the items
          FOR lr_assay IN cur_assay (an_assay_id)
          LOOP
             lt_contexts.DELETE;

             make_context_name( lr_assay.assay_id,
                                lt_contexts);

            IF lt_contexts.last IS NOT NULL
            THEN
              FOR i IN lt_contexts.first .. lt_contexts.last
              LOOP
                  UPDATE assay_context ac
                  SET context_name = lt_contexts(i).context_name,
                      context_group = lt_contexts(i).context_group
                  WHERE assay_context_id = lt_contexts(i).context_id;

              END LOOP;
            END IF;

          END LOOP;

          --commit;

    END update_context_name;

    PROCEDURE update_context_group
          (an_assay_id IN NUMBER DEFAULT NULL)
    AS

    -------------------------------------------------------------------------------------------------------------
    --   update context group
    --     parameter:  Assay_ID.  if no assay_id is given then all assays in the DB are updated
    --
    --     This uses loops thru the assays getting names and
    --    applying them to the contexts
    --
    --    schatwin    intial version    12-15-2012
    --    schatwin    exclude Annotation ones   1-21-2013
    --    schatwin    rename Annotation nes with commonest attribute name
    --    schatwin    converted from a procedure to a package   4-17-2013
    --
    -------------------------------------------------------------------------------------------------------------
        CURSOR cur_assay (cn_assay_id IN NUMBER)
        IS
        SELECT DISTINCT assay_id
        FROM assay_context ac
        WHERE ac.assay_id = Nvl(cn_assay_id, ac.assay_id);

        lv_context_name  element.label%TYPE;
        lv_context_group  assay_context.context_group%TYPE;
        lt_contexts       t_contexts;

    BEGIN
        -- get a list of assay_contexts with a count of the items
          FOR lr_assay IN cur_assay (an_assay_id)
          LOOP
             lt_contexts.DELETE;

             make_context_name( lr_assay.assay_id,
                                lt_contexts);

            IF lt_contexts.last IS NOT NULL
            THEN
              FOR i IN lt_contexts.first .. lt_contexts.last
              LOOP
                  UPDATE assay_context ac
                  SET context_group = lt_contexts(i).context_group
                  WHERE assay_context_id = lt_contexts(i).context_id;

              END LOOP;
            END IF;

          END LOOP;
    END update_context_group;

    PROCEDURE make_project_context_name
          (an_project_id IN NUMBER,
           ato_contexts OUT t_contexts)
    as
        CURSOR cur_project_context (cn_project_id IN NUMBER)
        IS
        SELECT ac.project_id,
                ac.project_context_id,
                Count(*) aci_count,
                LISTAGG(e.label, ';') WITHIN GROUP (ORDER BY aci.display_order) attributes
        FROM project_context ac,
              project_context_item aci,
              element e
        WHERE aci.project_context_id = ac.project_context_id
          AND e.element_id = aci.attribute_id
          AND ac.project_id = cn_project_id
        GROUP BY ac.project_id,
                ac.project_context_id;

        lv_context_name  element.label%TYPE;
        lv_context_group  project_context.context_group%TYPE;
        i BINARY_INTEGER  := 0;

    BEGIN
    --    get a list of project_contexts with a count of the items
          FOR lr_project_context IN cur_project_context (an_project_id)
          LOOP
              IF lr_project_context.aci_count = 1
              THEN
    --    if count of items = 1
    --    then set name  = attribute label
                  SELECT label
                  INTO lv_context_name
                  FROM element e,
                      project_context_item aci
                  WHERE aci.project_context_id = lr_project_context.project_context_id
                    -- we're guaranteed just one from the count(*) in the curosr
                    AND e.element_id = aci.attribute_id;

                  SELECT SubStr(full_path, InStr(full_path, '>') +2, InStr(full_path, '>', 1,3)-InStr(full_path, '>'))
                  INTO lv_context_group
                  FROM bard_tree
                  WHERE label = lv_context_name
                  AND ROWNUM = 1;

                  lv_context_group := Nvl(lv_context_group, 'unclassified>');

            ELSIF lr_project_context.attributes LIKE '%assay component role%'
            THEN
    --    if group contains 'assay component role'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM project_context_item
                WHERE project_context_id = lr_project_context.project_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component role')
                  AND ROWNUM = 1;

                  lv_context_group := 'project information> component>';

            ELSIF lr_project_context.attributes LIKE '%assay component type%'
            THEN
    --    if group contains 'assay component type'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM project_context_item
                WHERE project_context_id = lr_project_context.project_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component type')
                  AND ROWNUM = 1;

                  lv_context_group := 'project information> component>';

            ELSIF lr_project_context.attributes LIKE '%detection%'
            THEN
    --    if group contains 'detection'
    --    then set name = value
                lv_context_name := 'detection method';
                lv_context_group := 'project information> readout>';

            ELSIF lr_project_context.attributes LIKE '%readout%'
            THEN
    --    if group contains 'assay readout'
    --    then set name = value
                lv_context_name := 'assay readout';

            ELSIF lr_project_context.attributes LIKE '%wavelength%'
            THEN
    --    if group contains 'fluorescence/luminescence'
    --    then set name = value
                lv_context_name := 'fluorescence/luminescence';
                lv_context_group := 'project information> readout>';

            ELSIF lr_project_context.attributes LIKE '%laboratory%'
                OR lr_project_context.attributes LIKE '%grant%'
            THEN
    --    if group contains 'number'
    --    then set name = value
                lv_context_name := 'project management';
                lv_context_group := 'project information> project management>';

            ELSIF lr_project_context.attributes LIKE '%protein%'
                OR lr_project_context.attributes LIKE '%gene%'
            THEN
    --    if group contains 'number'
    --    then set name = value
                lv_context_name := 'biological component';
                lv_context_group := 'biology>';

            ELSIF lr_project_context.attributes LIKE '%number%'
            THEN
    --    if group contains 'number'
    --    then set name = value
                lv_context_name := 'result detail';
                lv_context_group := 'project management> experiment>';

            ELSIF lr_project_context.attributes LIKE '%biolog%'
            THEN
    --    if group contains 'biology/ical'
    --    then set name = value
                lv_context_name := 'biology';
                lv_context_group := 'biology>';

            ELSIF lr_project_context.attributes LIKE '%assay format%'
                    OR
                  lr_project_context.attributes LIKE '%assay type%'
            THEN
    --    if group contains 'assay format'
    --    then set name = 'assay protocol'
                lv_context_name := 'assay protocol';
                lv_context_group := 'project information> protocol>';

            ELSE
                --lv_context_name := NULL;
                lv_context_name := 'Type a name here';
                lv_context_group := 'unclassified>';
            END IF;

            IF lv_context_name IS NOT NULL
            THEN
                i := i + 1;
                ato_contexts(i).context_name := lv_context_name;
                ato_contexts(i).context_group := lv_context_group;
                ato_contexts(i).context_id := lr_project_context.project_context_id;

            END IF;

          END LOOP;
    END make_project_context_name;

    PROCEDURE update_project_context_name
      (an_project_id IN NUMBER DEFAULT NULL)

    AS
        CURSOR cur_project (cn_project_id IN NUMBER)
        IS
        SELECT DISTINCT ac.project_id
        FROM project_context ac
        WHERE ac.project_id = Nvl(cn_project_id, ac.project_id);

        lt_contexts   t_contexts;

    BEGIN
    --    get a list of project_contexts with a count of the items
          FOR lr_project IN cur_project (an_project_id)
          LOOP
            lt_contexts.DELETE;
            make_project_context_name(lr_project.project_id,
                                      lt_contexts);

            IF lt_contexts.last IS NOT NULL
            THEN
                FOR i IN lt_contexts.first .. lt_contexts.last
                LOOP
                    UPDATE project_context ac
                    SET context_name = lt_contexts(i).context_name,
                        context_group = lt_contexts(i).context_group
                    WHERE project_context_id = lt_contexts(i).context_id;

                END LOOP;


            END IF;

          END LOOP;

          --commit;

    END update_project_context_name;


    PROCEDURE update_project_context_group (an_project_id IN NUMBER DEFAULT NULL)

    AS
        CURSOR cur_project (cn_project_id IN NUMBER)
        IS
        SELECT DISTINCT ac.project_id
        FROM project_context ac
        WHERE ac.project_id = Nvl(cn_project_id, ac.project_id);

        lt_contexts   t_contexts;

    BEGIN
    --    get a list of project_contexts with a count of the items
          FOR lr_project IN cur_project (an_project_id)
          LOOP
            lt_contexts.DELETE;
            make_project_context_name(lr_project.project_id,
                                      lt_contexts);

            IF lt_contexts.last IS NOT NULL
            THEN
                FOR i IN lt_contexts.first .. lt_contexts.last
                LOOP
                    UPDATE project_context ac
                    SET context_group = lt_contexts(i).context_group
                    WHERE project_context_id = lt_contexts(i).context_id;

                END LOOP;


            END IF;

          END LOOP;

          --commit;
     END update_project_context_group;

    PROCEDURE make_exprmt_context_name
          (an_exprmt_id IN NUMBER,
           ato_contexts OUT t_contexts)
     AS
        CURSOR cur_exprmt_context (cn_exprmt_id IN NUMBER)
        IS
        SELECT ac.experiment_id,
                ac.exprmt_context_id,
                Count(*) aci_count,
                LISTAGG(e.label, ';') WITHIN GROUP (ORDER BY aci.display_order) attributes
        FROM exprmt_context ac,
              exprmt_context_item aci,
              element e
        WHERE aci.exprmt_context_id = ac.exprmt_context_id
          AND e.element_id = aci.attribute_id
          AND ac.experiment_id = cn_exprmt_id
         GROUP BY ac.experiment_id,
                ac.exprmt_context_id;

        lv_context_name  exprmt_context.context_name%TYPE;
        lv_context_group  exprmt_context.context_group%TYPE;
        i   BINARY_INTEGER  := 0;

    BEGIN
    --    get a list of exprmt_contexts with a count of the items
          FOR lr_exprmt_context IN cur_exprmt_context (an_exprmt_id)
          LOOP
              IF lr_exprmt_context.aci_count = 1
              THEN
    --    if count of items = 1
    --    then set name  = attribute label
                  SELECT label
                  INTO lv_context_name
                  FROM element e,
                      exprmt_context_item aci
                  WHERE aci.exprmt_context_id = lr_exprmt_context.exprmt_context_id
                    -- we're guaranteed just one from the count(*) in the curosr
                    AND e.element_id = aci.attribute_id;

                  SELECT SubStr(full_path, InStr(full_path, '>') +2, InStr(full_path, '>', 1,3)-InStr(full_path, '>'))
                  INTO lv_context_group
                  FROM bard_tree
                  WHERE label = lv_context_name
                  AND ROWNUM = 1;

                  lv_context_group := Nvl(lv_context_group, 'unclassified>');

            ELSIF lr_exprmt_context.attributes LIKE '%assay component role%'
            THEN
    --    if group contains 'assay component role'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM exprmt_context_item
                WHERE exprmt_context_id = lr_exprmt_context.exprmt_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component role')
                  AND ROWNUM = 1;

                  lv_context_group := 'assay protocol> assay component>';

            ELSIF lr_exprmt_context.attributes LIKE '%assay component type%'
            THEN
    --    if group contains 'assay component type'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM exprmt_context_item
                WHERE exprmt_context_id = lr_exprmt_context.exprmt_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component type')
                  AND ROWNUM = 1;

                  lv_context_group := 'assay protocol> assay component>';

            ELSIF lr_exprmt_context.attributes LIKE '%detection%'
            THEN
    --    if group contains 'detection'
    --    then set name = value
                lv_context_name := 'detection method';

                lv_context_group := 'assay protocol> assay readout>';

            ELSIF lr_exprmt_context.attributes LIKE '%readout%'
            THEN
    --    if group contains 'assay readout'
    --    then set name = value
                lv_context_name := 'assay readout';

                lv_context_group := 'assay protocol> assay readout>';

            ELSIF lr_exprmt_context.attributes LIKE '%wavelength%'
            THEN
    --    if group contains 'fluorescence/luminescence'
    --    then set name = value
                lv_context_name := 'fluorescence/luminescence';

                lv_context_group := 'assay protocol> assay design>';

            ELSIF lr_exprmt_context.attributes LIKE '%number%'
            THEN
    --    if group contains 'number'
    --    then set name = value
                lv_context_name := 'result detail';

                lv_context_group := 'project management> experiment>';

            ELSIF lr_exprmt_context.attributes LIKE '%biolog%'
            THEN
    --    if group contains 'biology/ical'
    --    then set name = value
                lv_context_name := 'biology';

                lv_context_group := 'biology>';

            ELSIF lr_exprmt_context.attributes LIKE '%assay format%'
                    OR
                  lr_exprmt_context.attributes LIKE '%assay type%'
            THEN
    --    if group contains 'assay format'
    --    then set name = 'assay protocol'
                lv_context_name := 'assay protocol';

                lv_context_group := 'biology>';

            ELSE
                --lv_context_name := NULL;
                lv_context_name := 'Type a name here';
                lv_context_group := 'unclassified>';
            END IF;

            IF lv_context_name IS NOT NULL
            THEN
              i := i + 1;
              ato_contexts(i).context_name := lv_context_name;
              ato_contexts(i).context_group := lv_context_group;
              ato_contexts(i).context_id := lr_exprmt_context.exprmt_context_id;

            END IF;

          END LOOP;

     END make_exprmt_context_name;


    PROCEDURE update_exprmt_context_name
      (an_exprmt_id IN NUMBER DEFAULT NULL)

    AS
        CURSOR cur_experiment (cn_exprmt_id IN NUMBER)
        IS
        SELECT DISTINCT ac.experiment_id
        FROM exprmt_context ac
        WHERE ac.experiment_id = cn_exprmt_id;

        lt_contexts  t_contexts;

    BEGIN
    --    get a list of exprmt_contexts with a count of the items
          FOR lr_experiment IN cur_experiment (an_exprmt_id)
          LOOP
             lt_contexts.DELETE;
             make_exprmt_context_name(lr_experiment.experiment_id,
                                      lt_contexts);

             IF lt_contexts.last IS NOT NULL
             THEN
                FOR i IN lt_contexts.first .. lt_contexts.last
                LOOP
                    UPDATE exprmt_context ac
                    SET context_name = lt_contexts(i).context_name,
                        context_group = lt_contexts(i).context_group
                    WHERE exprmt_context_id = lt_contexts(i).context_id;

                END LOOP;

            END IF;

          END LOOP;

          --commit;

    END update_exprmt_context_name;

    PROCEDURE update_exprmt_context_group (an_exprmt_id IN NUMBER DEFAULT NULL)
    AS

        CURSOR cur_experiment (cn_exprmt_id IN NUMBER)
        IS
        SELECT DISTINCT ac.experiment_id
        FROM exprmt_context ac
        WHERE ac.experiment_id = cn_exprmt_id;

        lt_contexts  t_contexts;

    BEGIN
    --    get a list of exprmt_contexts with a count of the items
          FOR lr_experiment IN cur_experiment (an_exprmt_id)
          LOOP
             lt_contexts.DELETE;
             make_exprmt_context_name(lr_experiment.experiment_id,
                                      lt_contexts);

             IF lt_contexts.last IS NOT NULL
             THEN
                FOR i IN lt_contexts.first .. lt_contexts.last
                LOOP
                    UPDATE exprmt_context ac
                    SET context_group = lt_contexts(i).context_group
                    WHERE exprmt_context_id = lt_contexts(i).context_id;

                END LOOP;

            END IF;

          END LOOP;

    END update_exprmt_context_group;

    PROCEDURE make_step_context_name
          (an_project_step_id IN NUMBER,
           ato_contexts OUT t_contexts)
    AS
        CURSOR cur_step_context (cn_step_id IN NUMBER)
        IS
        SELECT ac.project_step_id,
                ac.step_context_id,
                Count(*) aci_count,
                LISTAGG(e.label, ';') WITHIN GROUP (ORDER BY aci.display_order) attributes
        FROM step_context ac,
              step_context_item aci,
              element e
        WHERE aci.step_context_id = ac.step_context_id
          AND e.element_id = aci.attribute_id
          AND ac.project_step_id = cn_step_id
        GROUP BY ac.project_step_id,
                ac.step_context_id;

        lv_context_name  step_context.context_name%TYPE;
        lv_context_group  step_context.context_group%TYPE;
        i   BINARY_INTEGER  := 0;
    BEGIN
    --    get a list of step_contexts with a count of the items
          FOR lr_step_context IN cur_step_context (an_project_step_id)
          LOOP
              IF lr_step_context.aci_count = 1
              THEN
    --    if count of items = 1
    --    then set name  = attribute label
                  SELECT label
                  INTO lv_context_name
                  FROM element e,
                      step_context_item aci
                  WHERE aci.step_context_id = lr_step_context.step_context_id
                    -- we're guaranteed just one from the count(*) in the curosr
                    AND e.element_id = aci.attribute_id;

                  SELECT SubStr(full_path, InStr(full_path, '>') +2, InStr(full_path, '>', 1,3)-InStr(full_path, '>'))
                  INTO lv_context_group
                  FROM bard_tree
                  WHERE label = lv_context_name
                  AND ROWNUM = 1;

                  lv_context_group := Nvl(lv_context_group, 'unclassified>');

            ELSIF lr_step_context.attributes LIKE '%assay component role%'
            THEN
    --    if group contains 'assay component role'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM step_context_item
                WHERE step_context_id = lr_step_context.step_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component role')
                  AND ROWNUM = 1;

                  lv_context_group := 'assay protocol> assay component>';

            ELSIF lr_step_context.attributes LIKE '%assay component type%'
            THEN
    --    if group contains 'assay component type'
    --    then set name = value
                SELECT value_display
                INTO lv_context_name
                FROM step_context_item
                WHERE step_context_id = lr_step_context.step_context_id
                  AND attribute_id =
                        (SELECT element_id
                        FROM element
                        WHERE label = 'assay component type')
                  AND ROWNUM = 1;

                  lv_context_group := 'assay protocol> assay component>';

            ELSIF lr_step_context.attributes LIKE '%detection%'
            THEN
    --    if group contains 'detection'
    --    then set name = value
                lv_context_name := 'detection method';

            ELSIF lr_step_context.attributes LIKE '%readout%'
            THEN
    --    if group contains 'assay readout'
    --    then set name = value
                lv_context_name := 'assay readout';

                lv_context_group := 'assay protocol> assay readout>';

            ELSIF lr_step_context.attributes LIKE '%wavelength%'
            THEN
    --    if group contains 'fluorescence/luminescence'
    --    then set name = value
                lv_context_name := 'fluorescence/luminescence';

                lv_context_group := 'assay protocol> assay readout>';

            ELSIF lr_step_context.attributes LIKE '%number%'
            THEN
    --    if group contains 'number'
    --    then set name = value
                lv_context_name := 'result detail';

                lv_context_group := 'assay protocol> assay readout>';

            ELSIF lr_step_context.attributes LIKE '%biolog%'
            THEN
    --    if group contains 'biology/ical'
    --    then set name = value
                lv_context_name := 'biology';

                lv_context_group := 'biology>';

            ELSIF lr_step_context.attributes LIKE '%assay format%'
                    OR
                  lr_step_context.attributes LIKE '%assay type%'
            THEN
    --    if group contains 'assay format'
    --    then set name = 'assay protocol'
                lv_context_name := 'assay protocol';

               lv_context_group := 'assay protocol> assay format>';

            ELSE
                lv_context_name := 'Type a name here';
                lv_context_group := 'unclassified>';
            END IF;

            IF lv_context_name IS NOT NULL
            THEN
              i := i+ 1;
              ato_contexts(i).context_name := lv_context_name;
              ato_contexts(i).context_group := lv_context_group;
              ato_contexts(i).context_id := lr_step_context.step_context_id;

            END IF;

          END LOOP;
    END make_step_context_name;



    PROCEDURE update_step_context_group (an_project_step_id IN NUMBER DEFAULT NULL)

    AS
        CURSOR cur_step (cn_step_id IN NUMBER)
        IS
        SELECT DISTINCT ac.project_step_id
        FROM step_context ac
        WHERE ac.project_step_id = cn_step_id;

        lt_contexts  t_contexts;

    BEGIN
    --    get a list of step_contexts with a count of the items
          FOR lr_step IN cur_step (an_project_step_id)
          LOOP
            lt_contexts.DELETE;
            make_step_context_name(lr_step.project_step_id,
                                  lt_contexts);

            IF lt_contexts.last IS NOT NULL
            THEN
              FOR i IN lt_contexts.first .. lt_contexts.last
              LOOP
                  UPDATE step_context ac
                  SET context_group = lt_contexts(i).context_group
                  WHERE step_context_id = lt_contexts(i).context_id;
              END LOOP;
            END IF;

          END LOOP;
    END update_step_context_group;


    PROCEDURE update_step_context_name
      (an_project_step_id IN NUMBER DEFAULT NULL)

    AS
        CURSOR cur_step (cn_step_id IN NUMBER)
        IS
        SELECT DISTINCT ac.project_step_id
        FROM step_context ac
        WHERE ac.project_step_id = cn_step_id;

        lt_contexts  t_contexts;

    BEGIN
    --    get a list of step_contexts with a count of the items
          FOR lr_step IN cur_step (an_project_step_id)
          LOOP
            lt_contexts.DELETE;
            make_step_context_name(lr_step.project_step_id,
                                  lt_contexts);

            IF lt_contexts.last IS NOT NULL
            THEN
              FOR i IN lt_contexts.first .. lt_contexts.last
              LOOP
                  UPDATE step_context ac
                  SET context_name = lt_contexts(i).context_name,
                      context_group = lt_contexts(i).context_group
                  WHERE step_context_id = lt_contexts(i).context_id;
              END LOOP;
            END IF;

          END LOOP;

          --commit;

    END update_step_context_name;

    procedure update_assay_short_name
                        (ani_assay_id IN NUMBER  DEFAULT NULL)
                      --RETURN varchar2
    AS
        -- schatwin    11/21/2012   initial version
        -- schatwin    12/17/12     excluded 'Context for...' names
        --
        --
        -----------------------------------------------------------------------------------------
        CURSOR cur_assay (cn_assay_id NUMBER)
        IS
        SELECT assay_id, assay_type
        FROM assay a
        WHERE EXISTS (SELECT 1
            FROM assay_context ac
            WHERE ac.assay_id = a.assay_id)
          AND ( assay_id = cn_assay_id
                OR
                cn_assay_id IS NULL);


        CURSOR cur_assay_context_item (cn_assay_id NUMBER )
        IS
        SELECT ac.assay_id,
          ac.assay_context_id,
          aci.assay_context_item_id,
          ac.display_order group_display_order,
          aci.display_order item_display_order,
          ac.context_name,
          el.label attribute,
          aci.value_display,
          aci.attribute_id,
          aci.value_id,
          aci.ext_value_id
        FROM assay_context_item aci,
            assay_context ac,
            element el
        WHERE aci.assay_context_id = ac.assay_context_id
          AND el.element_id = aci.attribute_id
          AND ac.assay_id = cn_assay_id
          ORDER BY ac.assay_id, ac.display_order, aci.display_order;

        lv_assay_format   VARCHAR2(500);
        lv_assay_type     VARCHAR2(500);
        lv_biology        VARCHAR2(500);
        lv_target         VARCHAR2(500);
        lv_target_gene    VARCHAR2(500);
        lv_biology_gene   VARCHAR2(500);
        lv_detection      VARCHAR2(500);

        lv_short_name     VARCHAR2(4000);

        ln_trim_length    NUMBER;
        ln_assay_format   NUMBER;
        ln_assay_type     NUMBER;
        ln_biology        NUMBER;
        ln_target         NUMBER;
        ln_detection     NUMBER;

    BEGIN
        -- we need assay format, type and biology, target and detection method
        -- this procedure relies on the context names to identify items.
        -- Must use UPDATE_CONTEXT_NAME(an_assay_id) first to standardize the names.
        -- then rollback that transform after we've compiled the short_name to revert
        --     to the user's context_names
        -- use the structure:
        --     <assay format> <assay type> on <biology> with <target> using <detection>
        -- notice that these names may not be unique!!  need advice...

        -- for each assay cycle thru the context items, picking out the ones we need.
        -- if we get multiples, just add ' et al' to keep it short
        -- if we reach the end without finding a value to put in, use some defaults

        -- when we've got all the components of the name, concatenate them into a
        --     readable sentence and abbreviate to fit the 250 char limit

        -- depending on Assay_type we can do different things

        FOR lr_assay IN cur_assay (ani_assay_id)
        LOOP
            update_context_name (lr_assay.assay_id);

            lv_assay_format   := '';
            lv_assay_type     := '';
            lv_biology        := '';
            lv_target         := '';
            lv_target_gene    := '';
            lv_biology_gene   := '';
            lv_detection      := '';
            lv_short_name     := '';

            FOR lr_item IN cur_assay_context_item( lr_assay.assay_id)
            LOOP
              IF lr_item.attribute = 'assay format'
              THEN
                  lv_assay_format := add_term( lv_assay_format, lr_item.value_display);

              ELSIF lr_item.attribute = 'assay type'
              THEN
                  lv_assay_type := add_term( lv_assay_type, lr_item.value_display);

              ELSIF lr_item.attribute in ('gene Entrez GI', 'OMIM term', 'Mesh term')
                    AND lr_item.context_name != 'target'
              THEN
                  lv_biology_gene := add_term( lv_biology_gene, lr_item.value_display);

              ELSIF lr_item.attribute in ('biological process', 'GO biological process term', 'molecular interaction')
              THEN
                  lv_biology := add_term( lv_biology, lr_item.value_display);

              ELSIF lr_item.context_name = 'target'
              THEN
                  IF lr_item.attribute LIKE '%gene%'
                  THEN
                      lv_target_gene := add_term( lv_target_gene, lr_item.value_display);
                  ELSIF lr_item.attribute in ('assay reagent name', 'assay component', 'assay component name')
                    OR
                    lr_item.attribute LIKE ('%cell%')
                    OR
                    lr_item.attribute LIKE ('%protein%')
                  THEN
                      lv_target := add_term( lv_target, lr_item.value_display);
                  END IF;

              ELSIF lr_item.attribute in ('assay method', 'readout type')
                    OR
                    lr_item.attribute LIKE ('%detection%')
              THEN
                  lv_detection := add_term( lv_detection, lr_item.value_display);

              ELSE
                  NULL;
              END IF;


            END LOOP;
            ROLLBACK;   -- to remove the temporary changes to the context_names

            ------------------------------------------------------------------------------
            -- sort outthe preferences for bioogy and target, put in default values
            ----------------------------------------------------------------------------
            lv_assay_format := Nvl( lv_assay_format, 'no format');
            lv_assay_type := Nvl( lv_assay_type, 'no type');
            lv_biology := Nvl( lv_biology, Nvl(lv_biology_gene, 'undefined'));
            IF Length(lv_target_gene) > 0
            THEN
                lv_target := lv_target_gene;
            END IF;
            lv_target := Nvl( lv_target, 'phenotypic');
            lv_detection := Nvl( lv_detection, 'unknown detection');

            -- Now assemble the short_name
            -- first determine lengths and how to distribute the abrbevation (truncating)
            ln_trim_length := Length (lv_assay_format) + Length(lv_assay_type) + Length(lv_biology) + Length(lv_target) + Length(lv_detection) - 220;
            ln_assay_format := Length( lv_assay_format);
            ln_assay_type := Length( lv_assay_type);
            ln_biology := Length( lv_biology);
            ln_target := Length( lv_target);
            ln_detection := Length( lv_detection);
            IF ln_trim_length > 0
            THEN
                IF ln_assay_format > 44
                THEN
                    lv_assay_format := SubStr(lv_assay_format, 1, ln_assay_format - Trunc(ln_trim_length/5));
                END IF;
                IF ln_assay_type > 44
                THEN
                    lv_assay_type := SubStr(lv_assay_type, 1, ln_assay_type - Trunc(ln_trim_length/5));
                END IF;
                IF ln_biology > 44
                THEN
                    lv_biology := SubStr(lv_biology, 1, ln_biology - Trunc(ln_trim_length/5));
                END IF;
                IF ln_detection > 44
                THEN
                    lv_detection := SubStr(lv_detection, 1, ln_detection - Trunc(ln_trim_length/5));
                END IF;
                IF ln_assay_type > 44
                THEN
                    lv_target := SubStr(lv_target, 1, ln_target - Trunc(ln_trim_length/5));
                END IF;
            END IF;

            ----------------------------------------------------------------------------------------
            -- assemble the name
            ----------------------------------------------------------------------------------------
            lv_short_name := lv_target;
            lv_short_name := lv_short_name || '; ' ||lv_assay_format || '; ' || lv_assay_type;
            IF lv_biology != 'undefined'
            THEN
                lv_short_name := lv_short_name || '; on ' || lv_biology;
            END IF;
            IF lv_detection != 'unknown detection'
            THEN
                lv_short_name := lv_short_name || '; using ' || lv_detection;
            END IF;
            --
            ---------------------------------------------------------------------------
            --
            IF Length(lv_short_name) > 250
            THEN
                lv_short_name := SubStr(lv_short_name, 1, 247) || '...';
            END IF;
            -- update the assay record
            UPDATE assay
            SET assay_short_name = lv_short_name
            WHERE assay_id = lr_assay.assay_id;

            commit;    -- MUST do this each assay or the next assay will rollback this good work!

        END LOOP;

    END update_assay_short_name;

END manage_names;
/

--
-- PACKAGE: MANAGE_ONTOLOGY
--

CREATE OR REPLACE package DATA_MIG.manage_ontology
AS
-- SCHATWIN 1_18_13  only need these package constants for special
-- tables where the cols are not the same as BARD_TREE

    pv_tree_result_type varchar2(31) := 'RESULT_TYPE';
    pv_tree_unit varchar2(31) := 'UNIT';
    pv_tree_stage varchar2(31) := 'STAGE';
    pv_tree_laboratory varchar2(31) := 'LABORATORY';

    procedure make_trees (avi_tree_name in varchar2 default null);

    procedure add_element(avi_tree_name in varchar2,
                        ani_parent_element_id in number,
                        avi_element_label in varchar2,
                        avi_element_description in varchar2,
                        avi_element_abbreviation in varchar2,
                        avi_element_synonyms in varchar2);

    procedure swap_element_id (ani_element_id   in  number,
                               ani_new_element_id   in   number,
                               ab_delete_old    in boolean default false);

end manage_ontology;
/
CREATE OR REPLACE package body DATA_MIG.manage_ontology
as
-- forward declaration, needed for the recursion to compile
    procedure walk_down_the_tree(ani_element_id in number,
                                anio_node_id in out number,
                                ani_parent_node_id in number,
                                avi_relationship_type in varchar2,
                                avi_tree_name in varchar2,
                                avi_full_path IN VARCHAR2,
                                ani_recursion_level number,
                                ano_error out number,
                                avo_errmsg out varchar2);
    -- for preventing limitless trees (circular loops)
    pn_recursion_limit CONSTANT  number := 20;  -- change this limit as needed
    pv_path_separator  CONSTANT  CHAR(2) := '> ';
    -- for testing only
    pb_trace boolean := false;     -- true;
    pn_node_id_max number := null; --5; --1000;  -- for testing purposes only,
----------------------------------------------------------------------

    procedure trace(avi_msg in varchar2)
    as
        -- remember to turn on the serveroutput and set the buffer size to the max
        -- set serveroutput on size 1000000;

        lv_msg  varchar2(1000);

    BEGIN
        if pb_trace then
            lv_msg := to_char(sysdate, 'MM-DD HH:MI:SS');
            lv_msg := lv_msg || '. ' || substr(avi_msg, 0, 980);

            dbms_output.put_line(lv_msg);
        end if;

    END TRACE;

    procedure delete_old_tree(avi_tree_name in varchar2,
                            ano_error out number,
                            avo_errmsg out varchar2)
    as
    --
    -- schatwin 8_17_12  added "_tree" to all the materialized view tables
    -- schatwin 1_18_13  generalized by using execute immediate
        lv_sql  VARCHAR2(1000);

    begin
        /*
        if avi_tree_name = pv_tree_assay_descriptor
        then
            delete from assay_descriptor_tree;


        elsif avi_tree_name = pv_tree_biology_descriptor
        then
            delete from biology_descriptor_tree;

        elsif avi_tree_name = pv_tree_instance_descriptor
        then
            delete from instance_descriptor_tree;

        elsif avi_tree_name = pv_tree_result_type
        then
            delete from result_type_tree;

        elsif avi_tree_name = pv_tree_unit
        then
            delete from Unit_tree;

        elsif avi_tree_name = pv_tree_stage
        then
            delete from Stage_tree;

        elsif avi_tree_name = pv_tree_laboratory
        then
            delete from laboratory_tree;

        elsif avi_tree_name = pv_tree_dictionary
        then
            delete from dictionary_tree;

        elsif avi_tree_name = pv_tree_BARD
        then
            delete from BARD_tree;

        elsif avi_tree_name = pv_tree_stats_modifier
        then
            delete from stats_modifier_tree;
        end if;
        */

        lv_sql := 'delete from ' || avi_tree_name || '_TREE';

        EXECUTE IMMEDIATE lv_sql;

        trace('Delete from ' || avi_tree_name || ' '|| to_char(sql%rowcount) || ' rows' );

        commit;

    end delete_old_tree;

    procedure Set_is_leaf_flag (avi_tree_name IN varchar2)

    AS
        lv_sql  VARCHAR2(1000);
        ln_is_leaf    number;

    BEGIN
       /*
       if avi_tree_name = pv_tree_assay_descriptor
        then
            update assay_descriptor_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM assay_descriptor_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_biology_descriptor
        then
            update biology_descriptor_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM biology_descriptor_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_instance_descriptor
        then
            update instance_descriptor_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM instance_descriptor_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_result_type
        then
            update result_type_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM result_type_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_unit
        then
            update unit_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM unit_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_stage
        then
            update stage_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM stage_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_stats_modifier
        then
            update stats_modifier_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM STATS_MODIFIER_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_dictionary
        then
            update dictionary_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM DICTIONARY_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_BARD
        then
            update BARD_tree a
            SET is_leaf = 'Y'
            WHERE NOT EXISTS (SELECT 1
                FROM BARD_tree a2
                WHERE a.node_id = a2.parent_node_id);

        elsif avi_tree_name = pv_tree_laboratory
        THEN
            -- do nothing as there is no is_leaf in this table
            null;
        end if;
        */

        SELECT Count(*)
        INTO ln_is_leaf
        FROM cols
        WHERE table_name = avi_tree_name || '_TREE'
          AND column_name = 'IS_LEAF';

        IF ln_is_leaf > 0
        THEN
            lv_sql := 'update ' || avi_tree_name ||'_TREE a
            SET is_leaf = ''Y''
            WHERE NOT EXISTS (SELECT 1
                FROM ' || avi_tree_name ||'_TREE a2
                WHERE a.node_id = a2.parent_node_id)';

            EXECUTE IMMEDIATE lv_sql;

        END IF;

        trace('update is_leaf in ' || avi_tree_name || ' '|| to_char(sql%rowcount) || ' rows' );


    END Set_is_leaf_flag;

   procedure Save_node (ari_element in element%rowtype,
                                ani_node_id in number,
                                ani_parent_node_id in number,
                                avi_full_path IN VARCHAR2,
                                avi_tree_name in varchar2,
                                ano_error out number,
                                avo_errmsg out varchar2)
    as
    --
    -- schatwin 8_17_12  added "_tree" to all the materialized view tables
    -- schatwin 1_18_13  made generic by using execute immediate
    --                   except for laboratory,stage, unit, result_type which are all special
        lv_sql    VARCHAR2(1000);
    begin
        /*
        if avi_tree_name = pv_tree_assay_descriptor
        then
            insert into assay_descriptor_tree
                (node_id,
                parent_node_id,
                element_id,
                label,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                external_URL,
                unit_id,
                element_status)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                'N',
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.external_URL,
                ari_element.unit_id,
                ari_element.element_status);

        elsif avi_tree_name = pv_tree_biology_descriptor
        then
            insert into biology_descriptor_tree
                (node_id,
                parent_node_id,
                element_id,
                label,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                external_URL,
                unit_id,
                element_status)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                'N',
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.external_URL,
                ari_element.unit_id,
                ari_element.element_status);

        elsif avi_tree_name = pv_tree_instance_descriptor
        then
            insert into instance_descriptor_tree
                (node_id,
                parent_node_id,
                element_id,
                label,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                external_URL,
                unit_id,
                element_status)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                'N',
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.external_URL,
                ari_element.unit_id,
                ari_element.element_status);

        elsif avi_tree_name = pv_tree_dictionary
        then
            insert into dictionary_tree
                (node_id,
                parent_node_id,
                element_id,
                label,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                external_URL,
                unit_id,
                element_status)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                'N',
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.external_URL,
                ari_element.unit_id,
                ari_element.element_status);

        elsif avi_tree_name = pv_tree_BARD
        then
            insert into BARD_tree
                (node_id,
                parent_node_id,
                element_id,
                label,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                external_URL,
                unit_id,
                element_status)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                'N',
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.external_URL,
                ari_element.unit_id,
                ari_element.element_status);

        elsif avi_tree_name = pv_tree_stats_modifier
        then
            insert into stats_modifier_tree
                (node_id,
                parent_node_id,
                element_id,
                label,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                external_URL,
                unit_id,
                element_status)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                'N',
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.external_URL,
                ari_element.unit_id,
                ari_element.element_status);

        elsif avi_tree_name = pv_tree_result_type
        then
            insert into result_type_tree
                (node_id,
                parent_node_id,
                result_type_id,
                result_type_name,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                base_unit_id,
                result_type_status)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                'N',
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.unit_id,
                ari_element.element_status);

        elsif avi_tree_name = pv_tree_unit
        then
            insert into unit_tree
                (node_id,
                parent_node_id,
                unit_id,
                unit,
                description,
                full_path,
                is_leaf)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                Nvl(ari_element.abbreviation,ari_element.label),
                ari_element.description,
                avi_full_path,
                'N');

        elsif avi_tree_name = pv_tree_stage
        then
            insert into stage_tree
                (node_id,
                parent_node_id,
                stage_id,
                stage,
                stage_status,
                description,
                full_path,
                is_leaf)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.element_status,
                ari_element.description,
                avi_full_path,
                'N');

        elsif avi_tree_name = pv_tree_laboratory
        then
            insert into laboratory_tree
                (node_id,
                parent_node_id,
                laboratory_id,
                laboratory,
                laboratory_status,
                description)
                values
                (ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.element_status,
                ari_element.description);


        else
            null;
        end if;
        */

        if avi_tree_name = pv_tree_result_type
        then
            lv_sql := 'insert into ' || avi_tree_name || '_TREE
                (node_id,
                parent_node_id,
                result_type_id,
                result_type_name,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                base_unit_id,
                result_type_status)
                values
                (:ani_node_id,
                :ani_parent_node_id,
                :element_id,
                :label,
                :description,
                :avi_full_path,
                ''N'',
                :abbreviation,
                :synonyms,
                :unit_id,
                :element_status)';

            EXECUTE IMMEDIATE lv_sql
            USING IN ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.unit_id,
                ari_element.element_status;

        elsif avi_tree_name = pv_tree_unit
        then
            lv_sql := 'insert into ' || avi_tree_name || '_TREE
                (node_id,
                parent_node_id,
                unit_id,
                unit,
                abbreviation,
                description,
                full_path,
                is_leaf)
                values
                (:ani_node_id,
                :ani_parent_node_id,
                :element_id,
                :label,
                :abbreviation,
                :description,
                :avi_full_path,
                ''N'')';

            EXECUTE IMMEDIATE lv_sql
            USING IN ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                Nvl(ari_element.abbreviation, ari_element.label),
                ari_element.abbreviation,
                ari_element.label || ': ' || ari_element.description,
                avi_full_path;

        elsif avi_tree_name = pv_tree_stage
        then
            lv_sql := 'insert into ' || avi_tree_name || '_TREE
                (node_id,
                parent_node_id,
                stage_id,
                stage,
                stage_status,
                description,
                full_path,
                is_leaf)
                values
                (:ani_node_id,
                :ani_parent_node_id,
                :element_id,
                :label,
                :element_status,
                :description,
                :avi_full_path,
                ''N'')';

            EXECUTE IMMEDIATE lv_sql
            USING IN ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.element_status,
                ari_element.description,
                avi_full_path;

        elsif avi_tree_name = pv_tree_laboratory
        then
            lv_sql := 'insert into ' || avi_tree_name || '_TREE
                (node_id,
                parent_node_id,
                laboratory_id,
                laboratory,
                laboratory_status,
                description)
                values
                (:ani_node_id,
                :ani_parent_node_id,
                :element_id,
                :label,
                :element_status,
                :description)';

            EXECUTE IMMEDIATE lv_sql
            USING IN ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.element_status,
                ari_element.description;

        else
            lv_sql := 'insert into ' || avi_tree_name || '_TREE
                (node_id,
                parent_node_id,
                element_id,
                label,
                description,
                full_path,
                is_leaf,
                abbreviation,
                synonyms,
                external_URL,
                unit_id,
                element_status)
                values
                (:ani_node_id,
                :ani_parent_node_id,
                :element_id,
                :label,
                :description,
                :avi_full_path,
                ''N'',
                :abbreviation,
                :synonyms,
                :external_URL,
                :unit_id,
                :element_status)';

            EXECUTE IMMEDIATE lv_sql
            USING IN ani_node_id,
                ani_parent_node_id,
                ari_element.element_id,
                ari_element.label,
                ari_element.description,
                avi_full_path,
                ari_element.abbreviation,
                ari_element.synonyms,
                ari_element.external_URL,
                ari_element.unit_id,
                ari_element.element_status;

        end if;


        trace('Saved node ID='|| to_char(ani_node_id)
             || ' in tree=' || avi_tree_name
             || ' parent_ID=' || to_char(ani_parent_node_id)
             || ' Element_ID='  || to_char(ari_element.element_id)
             || ' label= "' || ari_element.label || '".'
             );

    end save_node;

    --- edited schatwin, 6/25/12 --------------------------------------------------
    -- changedwhere clause in cursor in walk_down_the_tree to just use 1st 3 letters of the relationship (property)
    ---
    procedure walk_down_the_tree(ani_element_id in number,
                                anio_node_id in out number,
                                ani_parent_node_id in number,
                                avi_relationship_type in varchar2,
                                avi_tree_name in varchar2,
                                avi_full_path IN VARCHAR2,
                                ani_recursion_level number,
                                ano_error out number,
                                avo_errmsg out varchar2)
    as
    cursor cur_element is
            select e.*
            from element e,
                 element_hierarchy eh
            where e.element_id = eh.child_element_id
              and eh.parent_element_id = ani_element_id
              and avi_relationship_type like '%' || substr(eh.relationship_type, 1, 3) || '%';
--              and avi_relationship_type like '%' || eh.relationship_type || '%';

    ln_node_id number;
    ln_next_parent_node_id number;
    lr_element element%rowtype;
    lv_full_path  VARCHAR2(3000);
    ln_error number;
    lv_errmsg varchar2(1000);
    lb_trace boolean;

    begin
        --  checkout the node_id counting!!  it's wicked
        ln_node_id := anio_node_id;
        IF Length(avi_full_path) = 0
        THEN
            lv_full_path := '';
        ELSE
            lv_full_path := SubStr(avi_full_path || pv_path_separator, 1, 3000);
        END IF;

        if ani_recursion_level <= pn_recursion_limit
        then
            for lr_element in cur_element
            LOOP
                 Save_node(lr_element,
                            ln_node_id,
                            ani_parent_node_id,
                            lv_full_path || lr_element.label,
                            avi_tree_name,
                            ln_error,
                            lv_errmsg);

                ln_next_parent_node_id := ln_node_id;
                ln_node_id := ln_node_id + 1;
                trace('next node, R-level=' || ani_recursion_level
                      || ' node_id=' || to_char(ln_node_id)
                      || ' parent_node_id=' || to_char(ln_next_parent_node_id)
                      || ' tree = ' || avi_tree_name
                      || ' path = ' || lv_full_path
                      );

                walk_down_the_tree(lr_element.element_id,
                                    ln_node_id,
                                    ln_next_parent_node_id,
                                    avi_relationship_type,
                                    avi_tree_name,
                                    lv_full_path || lr_element.label,
                                    ani_recursion_level +1,
                                    ln_error,
                                    lv_errmsg);
                trace( 'returning node_id = '|| to_char(ln_node_id)
                      || ' level = ' || to_char(ani_recursion_level)
                      );

                if ln_node_id > pn_node_id_max then
                    -- for testing only, null returns false in an IF
                    -- thus NULL is unlimited
                    exit;  -- reached a limit, so jump out of the loop
                end if;

            end loop;
        else
            lb_trace := pb_trace;
            pb_trace:= true;
            trace(' recursion limit exceeded '
                  || ' Element_id = ' || to_char(lr_element.element_id)
                  || ' next node, R-level=' || ani_recursion_level
                  || ' node_id=' || to_char(ln_node_id)
                  || ' parent_node_id=' || to_char(ln_next_parent_node_id)
                  || ' tree = ' || avi_tree_name
                  );
            pb_trace := lb_trace;

        end if;

        anio_node_id := ln_node_id;

    end walk_down_the_tree;


     procedure make_trees (avi_tree_name in varchar2 default null)
     --
     -- schatwin
     -- 8/16/12 -- changed the values for the root node in each tree to get them fom the element table
    as
    cursor cur_tree_root
        -- adds the Element as a join to get the label and descriptions (8/16/12)
        -- select only trees that have tables in the DB
        is select tr.*, e.description, e.label
           from tree_root tr,
            element e
           where e.element_id = tr.element_id
             and (tree_name = upper(avi_tree_name)
              or avi_tree_Name is null)
             AND EXISTS (SELECT 1
                  FROM tabs
                  WHERE table_name = tree_name || '_TREE');

    lr_tree_root tree_root%rowtype;
    lr_element element%rowtype;
    ln_node_id number;
    ln_parent_node_id number;
    lv_full_path VARCHAR2(3000);
    ln_error number;
    lv_errmsg varchar2(1000);
    ln_recursion_level number := 1; -- start of the recursion checking

    begin
        for lr_tree_root in cur_tree_root
        loop
            ln_node_id := 1;         -- first "real" node from Element
            ln_parent_node_id := 0;  -- every tree starts with a 0 node

            -- delete the current contents
            delete_old_tree(lr_tree_root.tree_name, ln_error, lv_errmsg);

            -- put in the root row
            lr_element.element_id := lr_tree_root.element_id;
            lr_element.label := lr_tree_root.label; --  was lr_tree_root.tree_name; (8/16/12)
            lr_element.description := nvl(lr_tree_root.description, 'Placeholder til we get a definition'); --  was 'Singular root to ensure tree viewers work'; (8/16/12)
            lr_element.element_status := 'Published';
            lr_element.version := 0;
            lr_element.date_created := sysdate;
            -- all other values are nulls
            lv_full_path := lr_tree_root.label;   -- or maybe just the blank?

            Save_node ( lr_element,
                        ln_parent_Node_id,
                        null,
                        lv_full_path,
                        lr_tree_root.tree_name,
                        ln_error,
                        lv_errmsg);

            -- now loop thru the children, get the next node_id
            walk_down_the_tree(
                        lr_tree_root.element_id,
                        ln_node_id,
                        ln_parent_node_id,
                        lr_tree_root.relationship_type,
                        lr_tree_root.tree_name,
                        lv_full_path,
                        ln_recursion_level,
                        ln_error,
                        lv_errmsg);
            -- return with the Node_ID of the last elment inserted (= count +1)

            -- and set the is_leaf flags
            Set_is_leaf_flag (lr_tree_root.tree_name);

            commit;
        end loop;

    end make_trees;


    procedure add_element(avi_tree_name in varchar2,
                        ani_parent_element_id in number,
                        avi_element_label in varchar2,
                        avi_element_description in varchar2,
                        avi_element_abbreviation in varchar2,
                        avi_element_synonyms in varchar2)
    as
    begin
        -- just stubbed for now

        -- pseudo code:

        -- check that the label doesn't already exist in Element (they're
        --  supposed to be unique)  and return the element_id, tree_name
        --  and node_id if it does.  Do this case-insensitive!

        -- save the new node in the relevant tree table
        -- remember to get the max(node_id) first

        -- add the element to the Element table using the sequence
        -- for the element_id

        -- enter the hierarchy into Element_hierarchy using the element_id
        --  and the parent_element_id with the relationship 'is_a'
        --  this assumes the new item is a leaf node - we cannot handle middle nodes!

        -- and put a reference into the ontology_element table to allow BAO
        --  to find and reference it

        -- and don't forget to commit;

        null;

    end add_element;

    procedure swap_element_id (ani_element_id   in  number,
                               ani_new_element_id   in   number,
                               ab_delete_old    in boolean default false)
    as
    -- tables in this order
    -- result_context_item, attribute, value
    -- result, result_type_id
    -- measure_context_item, attribute, value
    -- measure, result_type_id
    -- project_experiment, stage_id
    -- experiment, laboratory_id
    -- element_hierarchy, parent_element_id, child_element_id
    -- unit_conversion, from_unit, to_unit

    lv_old_label    element.label%type;
    lv_new_label    element.label%type;

    begin
        select label into lv_old_label
        from element
        where element_id = ani_element_id;

        select label into lv_new_label
        from element
        where element_id = ani_new_element_id;

        update tree_root
           set element_id = ani_new_element_id
         where element_id = ani_element_id;

        update ontology_item
           set element_id = ani_new_element_id
         where element_id = ani_element_id;

        update rslt_context_item
           set attribute_id = ani_new_element_id
         where attribute_id = ani_element_id;

        update rslt_context_item
           set value_id = ani_new_element_id,
               value_display = replace(value_display, lv_old_label, lv_new_label)
         where value_id = ani_element_id;

        update exprmt_context_item
           set attribute_id = ani_new_element_id
         where attribute_id = ani_element_id;

        update exprmt_context_item
           set value_id = ani_new_element_id,
               value_display = replace(value_display, lv_old_label, lv_new_label)
         where value_id = ani_element_id;

        update prjct_exprmt_cntxt_item
           set attribute_id = ani_new_element_id
         where attribute_id = ani_element_id;

        update prjct_exprmt_cntxt_item
           set value_id = ani_new_element_id,
               value_display = replace(value_display, lv_old_label, lv_new_label)
         where value_id = ani_element_id;

        update step_context_item
           set attribute_id = ani_new_element_id
         where attribute_id = ani_element_id;

        update step_context_item
           set value_id = ani_new_element_id,
               value_display = replace(value_display, lv_old_label, lv_new_label)
         where value_id = ani_element_id;

        update project_context_item
           set attribute_id = ani_new_element_id
         where attribute_id = ani_element_id;

        update project_context_item
           set value_id = ani_new_element_id,
               value_display = replace(value_display, lv_old_label, lv_new_label)
         where value_id = ani_element_id;

        update result
           set result_type_id = ani_new_element_id
         where result_type_id = ani_element_id;

        update assay_context_item
           set attribute_id = ani_new_element_id
         where attribute_id = ani_element_id;

        update assay_context_item
           set value_id = ani_new_element_id,
               value_display = replace(value_display, lv_old_label, lv_new_label)
         where value_id = ani_element_id;

        update measure m
           set result_type_id = ani_new_element_id
         where result_type_id = ani_element_id;

        update measure m
           set stats_modifier_id = ani_new_element_id
         where stats_modifier_id = ani_element_id;

        update result m
           set result_type_id = ani_new_element_id
         where result_type_id = ani_element_id;

        update result m
           set stats_modifier_id = ani_new_element_id
         where stats_modifier_id = ani_element_id;

        update measure
           set entry_unit_id = ani_new_element_id
         where entry_unit_id = ani_element_id;

        update project_experiment
           set stage_id = ani_new_element_id
         where stage_id = ani_element_id;

        update element
           set unit_id = ani_new_element_id
         where unit_id = ani_element_id;

        update unit_conversion uc
          set uc.from_unit_id = ani_new_element_id
        where uc.from_unit_id = ani_element_id
          and not exists (select 1 from unit_conversion uc2
            where uc2.from_unit_id = ani_new_element_id
            and uc2.to_unit_id = uc.to_unit_id);

        update unit_conversion uc
          set uc.to_unit_id = ani_new_element_id
        where uc.to_unit_id = ani_element_id
          and not exists (select 1 from unit_conversion uc2
            where uc2.to_unit_id = ani_new_element_id
            and uc2.from_unit_id = uc.from_unit_id);

        update unit_conversion uc
              set uc.from_unit_id = ani_new_element_id
            where uc.from_unit_id = ani_element_id
              and not exists (select 1 from unit_conversion uc2
                where uc2.from_unit_id = ani_new_element_id
                and uc2.to_unit_id = uc.to_unit_id);

          -- this IS handled BY the element deletion
--        update element_hierarchy eh
--          set eh.parent_element_id = ani_new_element_id
--        where eh.parent_element_id = ani_element_id
--          and not exists (select 1 from element_hierarchy eh2
--            where eh2.parent_element_id = ani_new_element_id
--            and eh2.child_element_id = eh.child_element_id);

--        update element_hierarchy eh
--          set eh.child_element_id = ani_new_element_id
--        where eh.child_element_id = ani_element_id
--          and not exists (select 1 from element_hierarchy eh2
--            where eh2.child_element_id = ani_new_element_id
--            and eh2.parent_element_id = eh.parent_element_id);

        if ab_delete_old
        then
            delete from element
            where element_id = ani_element_id;

            delete from identifier_mapping
            where target_id = ani_element_id
              and table_name = 'ELEMENT';
        end if;

        commit;

    end swap_element_id;


end manage_ontology;
/

--
-- PACKAGE: MIGRATION_STATS
--

CREATE OR REPLACE package Migration_stats
as

    type r_cursor is ref cursor;

-- primary entry points ----------------------------------------------------------
    PROCEDURE Generate_Migration_stats
        (avi_refresh IN VARCHAR2 DEFAULT 'Increment');

-- internal house-keeping ------------------------------------------------------
    procedure log_error
        (an_errnum   in  number,
         av_errmsg  in varchar2,
         av_location    in varchar2,
         av_comment in varchar2 default null);

    procedure log_statement
        (av_table   IN  varchar2,
         an_identifier  in number,
         av_action      in varchar2,
         av_statement   IN varchar2);

------------------------------------------------------------------------------------

end Migration_stats;
/
CREATE OR REPLACE package body DATA_MIG.Migration_stats
as
    ------package constants and variables
    -- pv_src_schema    varchar2(31) :=  user;
    -- for testing use this.  in general this should be run from the sandbox schema
    pv_src_schema    varchar2(31) :=  'bard_qa';
    --pv_src_schema    varchar2(31) :=  lower(user);
    --type r_cursor is ref cursor;
    pb_logging  boolean := true;
-----------------------------------------------------------------------------------------

    procedure log_error
        (an_errnum   in  number,
         av_errmsg  in varchar2,
         av_location    in varchar2,
         av_comment in varchar2 default null)
    as
    begin
        insert into error_log
           ( ERROR_LOG_ID,
             ERROR_DATE,
             procedure_name,
             ERR_NUM,
             ERR_MSG,
             ERR_COMMENT
           ) values (
             ERROR_LOG_ID_SEQ.NEXTVAL,
             sysdate,
             av_location,
             an_errnum,
             av_errmsg,
             av_comment
           );


    exception
        when others
        then
            null;
    end log_error;

    procedure log_statement
        (av_table   IN  varchar2,
         an_identifier  in number,
         av_action      in varchar2,
         av_statement   IN varchar2)
    as
    begin
        if pb_logging
        then
            insert into statement_log
                ( TABLE_NAME,
                  IDENTIFIER,
                  ACTION_DATE,
                  ACTION,
                  DATA_CLAUSE
                ) values (
                  av_table,
                  an_identifier,
                  sysdate,
                  av_action,
                  substr(av_statement, 1, 1000)
                );
         end if;

    exception
        when others
        then
            null;
    end log_statement;

-------------------------------------------------------------------------------------
-- added 9/5/12 -- schatwin
-- requires the table MIGRATION_ACTION, _EVENT, _DAY, _PERSON
------------------------------------------------------------------------------------
    PROCEDURE Generate_Migration_stats
        (avi_refresh IN VARCHAR2 DEFAULT 'Increment')
    AS
        CURSOR cur_action
        IS
        SELECT action_ref, count_sql
        FROM migration_action
        WHERE count_sql IS NOT NULL;

        --TYPE r_cursor IS REF CURSOR;
        TYPE r_event IS RECORD (aid migration_event.aid%type,
                        assay_id migration_event.assay_id%type,
                        experiment_id migration_event.experiment_id%type,
                        project_id migration_event.project_id%type,
                        event_count migration_event.event_count%type,
                        modified_by migration_person.person_name%type,
                        day_ref migration_event.day_ref%type);

        cur_event   r_cursor;
        lr_event    r_event;
        ln_action_ref NUMBER;
        ln_person_ref  NUMBER;
        lv_count_sql  VARCHAR2(32000);
        le_bad_parameter  EXCEPTION;
        ld_last_end_date  DATE;
        lv_modified_by  VARCHAR2(100) := ' ';

    BEGIN
        --  OUTLINE PSUEDO CODE -----------------------------------
        -- select from migration event to find the largest data so far
        --   hint: use the ref ID as its monotonically increasing with Date
        -- if the refresh is set, truncate the table (using execute immediate)
        --   and set the start date to null
        IF Lower(avi_refresh) = 'refresh'
        THEN
            EXECUTE IMMEDIATE 'truncate table migration_event';
            ld_last_end_date := To_Date('01/01/2000','MM/DD/YYYY');

        ELSIF Lower(avi_refresh) = 'increment'
        THEN
            SELECT migration_date
            INTO ld_last_end_date
            FROM migration_day md,
                (SELECT Max(day_ref) AS max_ref
                FROM migration_event) me
            WHERE md.day_ref = me.max_ref;

        ELSE
            RAISE le_bad_parameter;
        END IF;

        -- populate the migration_aid dimension with any new items
        INSERT INTO migration_aid
            (aid)
        SELECT DISTINCT ext_assay_ref
        FROM external_reference er
        WHERE NOT EXISTS
            (SELECT 1
            FROM migration_aid ma
            WHERE ma.aid = er.ext_assay_ref);

        -- get a cursor for the migration actions.  Each of these contains a SQL statement
        --   designed to extract data form the real tables and make it ready for insertion
        --   into MIGRATION_EVENT
        OPEN cur_action;
        LOOP
            FETCH cur_action INTO ln_action_ref, lv_count_sql;
            EXIT WHEN cur_action%NOTFOUND;
--            Dbms_Output.put_line(To_Char(SYSDATE, 'MI:SS') ||'action_ref = '|| To_Char(ln_action_ref));
            -- Open a cursor with the SQL using the start date as a parameter
            -- fetch into a standard rowtype for M_EVENT
            OPEN cur_event FOR lv_count_sql USING ld_last_end_date;
            LOOP
                FETCH cur_event INTO lr_event;
                EXIT WHEN cur_event%NOTFOUND;
--                Dbms_Output.put_line(To_Char(SYSDATE, 'MI:SS') ||'action_ref = '|| To_Char(ln_action_ref)
--                     || ' modified_by ' || lr_event.modified_by || ', '|| lv_modified_by);
                -- use a join with the dimensions to get the DAY_REF key value on the fly
                -- lookup the person_ref and insert if not found
                IF lr_event.modified_by != lv_modified_by
                then
                    BEGIN
                        SELECT person_ref INTO ln_person_ref
                        FROM migration_person
                        WHERE person_name = lr_event.modified_by;
                    EXCEPTION
                    WHEN No_data_found
                    THEN
--                    Dbms_Output.put_line(To_Char(SYSDATE, 'MI:SS') ||'action_ref = '|| To_Char(ln_action_ref)
--                          || ' new person ' || lr_event.modified_by);
                         SELECT Max(person_ref) + 1
                        INTO ln_person_ref
                        FROM migration_person;

                        INSERT INTO migration_person
                            (person_ref,
                            person_name)
                        VALUES
                            (ln_person_ref,
                            lr_event.modified_by);
                    END;
                    lv_modified_by := lr_event.modified_by;
                END IF;
                -- loop thru the cursor inserting a row at a time into the M_Event table
                -- this is generally efficient enough as its only a few rows when in increment mode
--               Dbms_Output.put_line(To_Char(SYSDATE, 'MI:SS') ||'action_ref = '|| To_Char(ln_action_ref)
--                     || ' insert day_ref = ' || To_Char(lr_event.day_ref) || ', '|| To_Char(ln_person_ref));
                 INSERT INTO migration_event
                        (aid,
                        assay_id,
                        experiment_id,
                        project_id,
                        event_count,
                        person_ref,
                        action_ref,
                        day_ref)
                VALUES (lr_event.aid,
                        lr_event.assay_id,
                        lr_event.experiment_id,
                        lr_event.project_id,
                        lr_event.event_count,
                        ln_person_ref,
                        ln_action_ref,
                        lr_event.day_ref);

            END LOOP;
            -- commit at the end of the loop
            COMMIT;

        END LOOP;

        -- and add the newly minted AID and equivalent items to the dimension table
        INSERT INTO migration_aid
            (aid)
        SELECT DISTINCT (aid)
            FROM migration_event me
        WHERE NOT EXISTS (SELECT 1
            FROM migration_aid ma
            WHERE ma.aid = me.aid);

        Commit;

    EXCEPTION
    WHEN le_bad_parameter THEN
        null;
--    WHEN OTHERS THEN
--        NULL;

    END Generate_Migration_stats;


end Migration_stats;
/

--
-- PACKAGE: RESULT_MAP_UTIL
--

CREATE OR REPLACE PACKAGE DATA_MIG.result_map_util
AS

    -- this type must match the cursor cur_rm_measure
    /*        e.experiment_id,
              e.assay_id,
              el.element_id result_type_id,
              el_sm.element_id stats_modifier_id,
              rm.aid,
              rm.resulttype,
              rm.stats_modifier,
              rm.relationship,
              rm.tid,
              rm.series_nos,
              rm.parent_tids*/
    TYPE r_resulttype IS RECORD (
          EXPERIMENT_ID   experiment.experiment_id%TYPE,
          ASSAY_ID        experiment.assay_id%TYPE,
          RESULT_TYPE_ID  element.element_id%type,
          STATS_MODIFIER_ID element.element_id%type,
          AID             southern.result_map.aid%type,
          RESULTTYPE      southern.result_map.resultType%type,
          STATS_MODIFIER  southern.result_map.stats_modifier%type,
          relationship    southern.result_map.relationship%TYPE,
          TID             southern.result_map.tid%type,
          --entry_unit      southern.result_map.concentrationunit%TYPE,
          entry_unit      VARCHAR2(10),
          SERIES_NOS      varchar2(4000),
          PARENT_TIDS     varchar2(4000)
          );

    --TYPE t_result_Maps IS TABLE OF southern.result_map%rowtype;

    TYPE t_string IS varray (1) OF VARCHAR2(40);

    PROCEDURE transfer_result_map (avi_AID IN VARCHAR2 DEFAULT NULL);

    PROCEDURE save_measure_and_children (ani_recursion_level  IN binary_integer,
                                         ani_parent_measure_id IN NUMBER,
                                         ari_resulttype IN r_resulttype);

END Result_map_util;
/
CREATE OR REPLACE PACKAGE BODY DATA_MIG.result_map_util
as

    pn_max_recursion_level CONSTANT BINARY_INTEGER := 5;

    pv_modified_by CONSTANT VARCHAR2(40) := 'resultmap';

    pb_Reuse_IDs  CONSTANT BOOLEAN := TRUE;

    function get_new_id (avi_sequence_name IN VARCHAR2)
        RETURN NUMBER
    AS
        ln_next_id  NUMBER;
        lv_table_name VARCHAR2(30);
        lv_column_name VARCHAR2(30);
        lv_sql          VARCHAR2(1000);
        lv_sequence_name  VARCHAR2(30);

    BEGIN
        lv_sequence_name := Upper (avi_sequence_name);

        IF lv_sequence_name NOT LIKE '%_ID_SEQ'
        THEN RETURN null;
        END IF;

        lv_table_name := REPLACE (lv_sequence_name, '_ID_SEQ', '');
        lv_column_name := REPLACE (lv_sequence_name, '_SEQ', '');

        IF pb_reuse_IDs
        THEN
            lv_sql := 'select ' || lv_column_name || ' + 1
                        from ' || lv_table_name || ' t1
                        where not exists (select 1
                                  from ' || lv_table_name || ' t2
                                  where t2.' || lv_column_name || ' = t1.' || lv_column_name || ' + 1)
                          and rownum = 1
                          and ' || lv_column_name || ' < (select max('|| lv_column_name || ')
                                      from ' || lv_table_name || ')';

        ELSE
            lv_sql := 'SELECT ' || lv_sequence_name || '.NEXTVAL FROM dual';

        END IF;
        -- Dbms_Output.put_line (lv_sql);
        begin
            EXECUTE IMMEDIATE lv_sql INTO ln_next_id;
        EXCEPTION
            WHEN No_Data_Found       -- means the table is completely empty
            then
                lv_sql := 'SELECT ' || lv_sequence_name || '.NEXTVAL FROM dual';
                EXECUTE IMMEDIATE lv_sql INTO ln_next_id;
            WHEN OTHERS
            THEN
                RAISE;
         END;

        -- dbms_output.put_line (lv_column_name || '= '|| To_Char(ln_next_id));
        RETURN ln_next_id;

    END get_new_id;

    PROCEDURE delete_measure (ani_assay_id IN NUMBER,
                             ani_experiment_id IN number,
                             avi_owner IN varchar2)
    AS

    BEGIN
        -- exrmpt_measure
        -- assay_context_measure
        -- measure
        DELETE from exprmt_measure
        WHERE experiment_id = ani_experiment_id
        AND modified_by = avi_owner;

        DELETE FROM assay_context_measure acm
        WHERE EXISTS (SELECT 1
            FROM measure m
            WHERE m.measure_id = acm.measure_id
              AND m.assay_id = ani_assay_id
              AND m.modified_by = avi_owner);

        DELETE FROM  measure m
        WHERE assay_id = ani_assay_id
          AND modified_by = avi_owner
          AND NOT EXISTS (SELECT 1
              FROM assay_context_measure acm
              WHERE acm.measure_id = m.measure_id)
          AND NOT EXISTS (SELECT 1
              FROM exprmt_measure acm
              WHERE acm.measure_id = m.measure_id);

        -- should there be a check here for the ones that weren't deleted?

        DELETE FROM assay_context_item aci
        WHERE EXISTS (SELECT 1
            FROM assay_context ac
            WHERE ac.assay_context_id = aci.assay_context_id
            AND ac.assay_id = ani_assay_id)
        AND aci.modified_by = avi_owner;

        DELETE FROM assay_context ac
        WHERE  ac.assay_id = ani_assay_id
        AND NOT EXISTS (SELECT 1
            FROM assay_context_item aci
            WHERE aci.assay_context_id = ac.assay_context_id)
        AND NOT EXISTS (SELECT 1
            FROM assay_context_measure acm
            WHERE acm.assay_context_id = ac.assay_context_id);


    END delete_measure;

    function save_measure (ani_parent_measure_id IN NUMBER,
                          ari_measure IN r_resulttype)
        RETURN NUMBER
    AS
        ln_measure_id     NUMBER := null;
        Ln_entry_unit_id  NUMBER;

        CURSOR cur_measure
        IS
        SELECT measure_id
        FROM measure
        WHERE assay_id = ari_measure.assay_id
          AND result_type_id = ari_measure.result_type_id
          AND Nvl(stats_modifier_id, -100) = Nvl(ari_measure.stats_modifier_id, -100)
          AND Nvl(parent_measure_id, -200) = Nvl(ani_parent_measure_id, -200);

    BEGIN
        -- check the arguments
         IF ari_measure.assay_id IS NULL
        OR ari_measure.result_type_id IS NULL
        THEN
            ln_measure_id := -1;
            RETURN ln_measure_id;
        END IF;

       -- try to find an existing measure using the AK
        OPEN cur_measure;
        FETCH cur_measure INTO ln_measure_id;
        CLOSE cur_measure;

        -- if it exists update parent_measure_id and units
            -- and return the measure_id
        -- if not insert a new measure row
        IF ln_measure_id IS NULL
        THEN
            -- find the appropriate entry unit
            IF ari_measure.entry_unit IS NOT NULL
            THEN
                BEGIN
                    -- use unit_tree 'cos this handles abreviations like Result_map does
                    SELECT unit_id
                    INTO ln_entry_unit_id
                    FROM unit_tree
                    WHERE unit = ari_measure.entry_unit;
                EXCEPTION
                WHEN OTHERS THEN
                    ln_entry_unit_id := NULL;
                END;
            END IF;
            -- if we can't use or find the specified one, try the default for the result type
            IF ln_entry_unit_id IS NULL
            THEN
                SELECT unit_id
                INTO ln_entry_unit_id
                FROM element
                WHERE element_id = ari_measure.result_type_id;
            END IF;

            ln_measure_id := get_new_id ('measure_id_seq');

            INSERT INTO measure
                (Measure_id,
                 assay_id,
                 result_type_id,
                 stats_modifier_id,
                 entry_unit_id,
                 parent_measure_id,
                 version,
                 date_created,
                 last_updated,
                 modified_by)
            VALUES
                (ln_Measure_id,
                 ari_measure.assay_id,
                 ari_measure.result_type_id,
                 ari_measure.stats_modifier_id,
                 ln_entry_unit_id,
                 ani_parent_measure_id,
                 0,
                 sysdate,
                 null,
                 pv_modified_by);
--        ELSE
--            UPDATE measure
--            SET entry_unit_id = ln_entry_unit_id
--            WHERE measure_id = ln_measure_id
--            AND Nvl(entry_unit_id, -100) != Nvl(ln_entry_unit_id, -100);

        END IF;

        RETURN ln_measure_id;

    END save_measure;

    procedure log_error (an_errnum    in  number,
                        av_errmsg     in varchar2,
                        av_location   in varchar2,
                        av_comment    in varchar2 default null)
    as
    begin
        insert into error_log
           ( ERROR_LOG_ID,
             ERROR_DATE,
             procedure_name,
             ERR_NUM,
             ERR_MSG,
             ERR_COMMENT
           ) values (
             ERROR_LOG_ID_SEQ.NEXTVAL,
             sysdate,
             av_location,
             an_errnum,
             av_errmsg,
             av_comment
           );


    exception
        when others
        then
            null;
    end log_error;

    PROCEDURE separate_value_unit (avi_value_string IN  varchar2,
                                    avio_value_num IN OUT number,
                                    avio_unit IN OUT varchar2)
    AS
        ln_pos_space  BINARY_INTEGER;
        lv_first_word VARCHAR2(500);
        lv_last_word  VARCHAR2(500);
        ln_number     NUMBER;

    BEGIN
        -- get the number from the first part (if it's not in the first part it's probably not a real number)
        --Dbms_Output.put_line ('separate value_unit. value1 = ' || avi_value_string);
        ln_pos_space := InStr(avi_value_string, ' ');
        IF ln_pos_space > 0
        THEN
            ln_pos_space := ln_pos_space - 1;
        ELSE
            ln_pos_space := Length(avi_value_string);
        END IF;
        lv_first_word := SubStr(avi_value_string, 1, InStr(avi_value_string, ' ') -1 );
        -- test for a number
        begin
            ln_number := To_Number(lv_first_word);
        EXCEPTION
            WHEN OTHERS THEN
                ln_number := NULL;
        END;

        IF ln_number IS NOT NULL
        THEN
            --get the units from the end
            ln_pos_space := InStr(avi_value_string, ' ', -1);
            lv_last_word := SubStr(avi_value_string, ln_pos_space);
            avio_value_num := Nvl(avio_value_num, ln_number);
            avio_unit := Nvl(avio_unit, lv_last_word);
        END IF;

    END separate_value_unit;

    PROCEDURE save_exprmt_context_item_set (ari_resultType  IN  r_resultType)

    AS
        CURSOR cur_matching_context
        IS
        SELECT aci.assay_context_id
        FROM temp_context_item tci,
            assay_context_item aci,
            assay_context ac
        WHERE ac.assay_context_id = aci.assay_context_id
          AND ac.assay_id = tci.assay_id
          AND aci.attribute_id = tci.attribute_id
          AND Nvl(aci.value_id, -100) = Nvl(tci.value_id, -100)
          --AND Nvl(aci.value_num, -99999.999) = Nvl(tci.value_num, -99999.999)
          and Decode(aci.value_id, NULL, Nvl(aci.value_display, '######'),'$$$$$$')
                  = Decode(tci.value_id, NULL, Nvl(tci.value1, '######'),'$$$$$$')
        GROUP BY aci.assay_context_id
        HAVING Count(*) = (SELECT Count(*) FRoM temp_context_item)
          AND Count(*) = (SELECT Count(*) FroM assay_context_item aci2
                                          WHERE aci2.assay_context_id = aci.assay_context_id);

        CURSOR cur_temp_context_item
        IS
        SELECT assay_id,
              attribute_id,
              display_order,
              value_num,
              unit,
              value_id,
              ext_value_id,
              value_min,
              value_max,
              aid,
              resultType,
              statsmodifier,
              contextItem,
              value1,
             Decode ((SELECT Count(*)
                     FROM temp_context_item tci2
                     WHERE tci2.contextItem = tci.contextItem),
                     0,'Free',
                     1,Decode(value1, NULL, 'Free', 'Fixed'),
                     'List') attribute_type
        FROM temp_context_item tci
        ORDER BY display_order;

        ln_assay_context_id NUMBER := null;
        ln_assay_context_item_id NUMBER ;

    BEGIN

        -- clean out the temp table
        DELETE FROM temp_context_item;
        -- get the context_item set from the result_map table
        -- AND save IN a TEMPORARY table
        -- need special care to find a set of 'List' type items
            -- look for the attribute without the value
            -- insert items with values with a check to prevent inserting duplicates
            -- note use of assay_ID argument to prevent doubling of item rows
        -- save the items in a temp table
--          Dbms_Output.put_line ('iinsert into temp_context_item '
--        || ', exprt_id=' || ari_resulttype.experiment_id
--        || ', assay_id=' || ari_resulttype.assay_id
--        || ', rt_id=' || ari_resulttype.result_type_id
--        || ', sm_id=' || ari_resulttype.stats_modifier_id
--        || ', aid=' || ari_resulttype.aid
--        || ', resulttype=' || ari_resulttype.resulttype
--        || ', modifier=' || ari_resulttype.stats_modifier
--        || ', relationship=' || ari_resulttype.relationship
--        || ', tid=' || ari_resulttype.tid
--        || ', expseries_no=' || ari_resulttype.series_nos
--        || ', parentTIds=' || ari_resulttype.parent_tids);

        INSERT INTO temp_context_item
            (display_order,
              assay_id,
              attribute_id,
              value_id,
              aid,
              resultType,
              statsmodifier,
              contextItem,
              value1,
              value_num,
              unit)
        SELECT ROWNUM - 1 display_order,
              ci.*
        FROM (SELECT e.assay_id,
                el_ci.element_id attribute_id,
                el_val.element_id value_id,
                rm.aid,
                rm.resultType,
                rm.stats_modifier,
                rm.contextItem,
                Nvl(rm.value1, Decode(rm.value_num, NULL, NULL, rm.value_num || ' ' || rm.unit)) value1,
                rm.value_num,
                rm.unit
            FROM (SELECT rm_ci.aid, rm_ci.resultType, rm_ci.stats_modifier, rm_ci.contextItem, NULL value1, rm_ci.concentration value_num, rm_ci.concentrationunit unit
                  FROM southern.result_map rm_ci
                  WHERE Nvl(rm_ci.contextTID, rm_ci.tid) = rm_ci.tid
                    AND rm_ci.contextItem != 'do not import'
                    AND rm_ci.resultType IS null
                    AND rm_ci.aid = ari_resulttype.aid
                  GROUP BY rm_ci.aid, rm_ci.resultType, rm_ci.stats_modifier, rm_ci.contextItem, rm_ci.concentration, rm_ci.concentrationunit
                  UNION all
                  SELECT rm_ci.aid, rm_ci.resultType, rm_ci.stats_modifier, rm_ci.attribute1, rm_ci.value1, null value_num, NULL unit
                  FROM southern.result_map rm_ci
                  WHERE Nvl(rm_ci.contextTID, rm_ci.tid) = rm_ci.tid
                    AND rm_ci.attribute1 IS NOT null
                    AND rm_ci.resultType IS null
                    AND rm_ci.aid = ari_resulttype.aid
                  GROUP BY rm_ci.aid, rm_ci.resultType, rm_ci.stats_modifier, rm_ci.attribute1, rm_ci.value1
                  UNION all
                  SELECT rm_ci.aid, rm_ci.resultType, rm_ci.stats_modifier, rm_ci.attribute2, rm_ci.value2, null value_num, NULL unit
                  FROM southern.result_map rm_ci
                  WHERE Nvl(rm_ci.contextTID, rm_ci.tid) = rm_ci.tid
                    AND rm_ci.attribute2 IS NOT null
                    AND rm_ci.resultType IS null
                    AND rm_ci.aid = ari_resulttype.aid
                  GROUP BY rm_ci.aid, rm_ci.resultType, rm_ci.stats_modifier, rm_ci.attribute2, rm_ci.value2
                    ) rm,
                element el_ci,
                element el_val,
                external_reference er,
                experiment e
            WHERE er.ext_assay_ref = 'aid=' || rm.aid
              AND e.experiment_id = er.experiment_id
              AND e.assay_id = ari_resulttype.assay_id
              AND el_ci.label (+) = rm.contextItem
              AND el_val.label (+) = rm.value1
              ORDER BY rm.aid, rm.contextItem, rm.value_num, rm.value1) ci;

--         Dbms_Output.put_line ('inserted '
--              || 'SQL%rowcount=' || SQL%rowcount);

        IF SQL%ROWCOUNT = 0
        THEN
           return;
            -- nothing got inserted, so we can make a quick exit
        END IF;

        -- query to find an existing matching set
        OPEN cur_matching_context;
--        Dbms_Output.put_line (' opened the matching cursor');
        FETCH cur_matching_context INTO ln_assay_context_id;
--        Dbms_Output.put_line (' fetched the matching cursor');
        CLOSE cur_matching_context;

        IF ln_assay_context_id IS NULL
        THEN
            -- not found create an assay_context
           ln_assay_context_id := get_new_id ('assay_context_id_seq');
--          Dbms_Output.put_line (' got assay_context_id=' || ln_assay_context_id);

            INSERT INTO assay_context
                (assay_context_id,
                 assay_id,
                 context_name,
                 context_group,
                 display_order,
                 modified_by)
            VALUES
                (ln_assay_context_id,
                 ari_resultType.assay_id,
                 'annotations for ' || ari_resultType.resultType,
                 'project management> experiment>',
                 0,
                 pv_modified_by);
            -- cycle thru the items saving each as you go
            FOR lr_context_item IN  cur_temp_context_item
            LOOP
                -- check the inputs
                IF lr_context_item.attribute_id IS NULL
                    OR
                    lr_context_item.assay_id is NULL
                THEN
                    -- log the error;
                    log_error (-90002, 'Attribute not in Element', 'save_context_item_set',
                            'resultType=' || lr_context_item.resultType || lr_context_item.statsmodifier
                            || ', Attr_Id='|| To_Char(lr_context_item.attribute_id)
                            || ', contextItem/attribute1=' || lr_context_item.contextItem
                            || ', Assay=' || To_Char(lr_context_item.assay_id)
                            || ', AID='|| To_Char(lr_context_item.aid));
                    CONTINUE;
                END IF;
                IF lr_context_item.value_id IS NULL
                    and lr_context_item.value_num is NULL
                    and lr_context_item.attribute_type != 'Free'
                THEN
                    -- log the error;
                    log_error (-90003, 'WARNING: no value specified', 'save_context_item_set',
                            'resultType=' || lr_context_item.resultType || lr_context_item.statsmodifier
                            || ', Attr_Id='|| To_Char(lr_context_item.attribute_id)
                            || ', attribute=' || lr_context_item.contextItem
                            || ', value_display=' || lr_context_item.value1
                            || ', Assay=' || To_Char(lr_context_item.assay_id)
                            || ', AID='|| To_Char(lr_context_item.aid));
                END IF;
                -- convert the value1 into a number/unit pair if possible
--                Dbms_Output.put_line (' splitting value1=' || lr_context_item.value1);
                IF lr_context_item.value1 IS NOT NULL
                then
                    separate_value_unit (lr_context_item.value1, lr_context_item.value_num, lr_context_item.unit);
                END IF;

                ln_assay_context_item_id := get_new_id ('assay_context_item_id_seq');
                INSERT INTO assay_context_item
                    (assay_context_item_id,
                    assay_context_id,
                    display_order,
                    attribute_type,
                    attribute_id,
                    value_id,
                    value_display,
                    value_num,
                    modified_by)
                VALUES(
                    ln_assay_context_item_id,
                    ln_assay_context_id,
                    lr_context_item.display_order,
                    lr_context_item.attribute_type,
                    lr_context_item.attribute_id,
                    lr_context_item.value_id,
                    Nvl(lr_context_item.value1, Decode(lr_context_item.value_num, NULL, NULL, To_Char(lr_context_item.value_num) || ' ' || lr_context_item.unit)),
                    lr_context_item.value_num,
                    pv_modified_by);

            END LOOP;
        END IF;

        --RETURN ln_assay_context_id;

    END save_exprmt_context_item_set;

    PROCEDURE transfer_result_map (avi_AID IN VARCHAR2 DEFAULT NULL)
    AS
        CURSOR cur_assay_experiment (cn_AID NUMBER)
        IS
        SELECT e.assay_id,
            e.experiment_id,
            er.project_id,
            er.ext_assay_ref,
            SubStr(EXT_ASSAY_REF, 5) aid
        FROM external_reference er,
            experiment e
        WHERE e.experiment_id = er.experiment_id
          AND EXISTS (SELECT 1
              FROM southern.result_map rm
              WHERE 'aid=' || rm.aid = er.ext_assay_ref)
          AND er.project_id IS null
          AND (EXT_ASSAY_REF = 'aid=' || To_Char(cn_aid)
              OR cn_aid IS NULL);

        CURSOR cur_rm_measure (cn_aid NUMBER)
        IS
        SELECT e.experiment_id,
              e.assay_id,
              el.element_id result_type_id,
              el_sm.element_id stats_modifier_id,
              rm.aid,
              rm.resulttype,
              rm.stats_modifier,
              rm.relationship,
              rm.tid,
              rm.entry_unit,
              rm.series_nos,
              rm.parent_tids
        FROM (SELECT aid, resulttype, stats_modifier, relationship, tid, Decode(contextitem, NULL, concentrationunit) entry_unit,
            --listagg(relationship, ',') within GROUP (ORDER BY tid) relationship,
            listagg(seriesno, ',') within GROUP (ORDER BY tid) series_nos,
            listagg(parenttid, ',') within GROUP (ORDER BY tid) parent_tids
            FROM southern.result_map
            WHERE aid = cn_aid   --1705
              AND resulttype IS NOT NULL
              --AND modified_by != 'southalln'
              AND parenttid IS null
              --AND InStr(',' || parentTID || ',', ',6,') > 0
            GROuP BY aid, resulttype, stats_modifier, relationship, tid, Decode(contextitem, NULL, concentrationunit)) rm,
            external_reference er,
            experiment e,
            result_type_element el,
            element el_sm
        WHERE er.ext_assay_ref = 'aid=' || rm.aid
          AND e.experiment_id = er.experiment_id
          AND el.label (+) = rm.resulttype
          AND el_sm.label (+) = rm.stats_modifier;

       lr_rm_resultType       r_resultType;
       lt_TIDs                t_string;

    BEGIN
        -- get the list of assays to handle

        FOR lr_assay_experiment IN cur_assay_experiment(REPLACE (avi_aid, 'aid=', ''))
        loop
            ---------------------------------------------------------------------------------------
            -- TODO -  this may be doing duplicate deletion work.  maybe a separate loop for this?
            --------------------------------------------------------------------------------------
            delete_measure (lr_assay_experiment.assay_id, lr_assay_experiment.experiment_id, pv_modified_by);

            FOR lr_rm_measure IN cur_rm_measure (lr_assay_experiment.aid)
            LOOP
                 -- this is a recursive call!
--                Dbms_Output.put_line (' send to first recursion '
--                      || 'exprt_id=' || lr_rm_measure.experiment_id
--                      || ', assay_id=' || lr_rm_measure.assay_id
--                      || ', rt_id=' || lr_rm_measure.result_type_id
--                      || ', sm_id=' || lr_rm_measure.stats_modifier_id
--                      || ', aid=' || lr_rm_measure.aid
--                      || ', resulttype=' || lr_rm_measure.resulttype
--                      || ', modifier=' || lr_rm_measure.stats_modifier
--                      || ', relationship=' || lr_rm_measure.relationship
--                      || ', tid=' || lr_rm_measure.tid
--                      || ', expseries_no=' || lr_rm_measure.series_nos
--                      || ', parentTIds=' || lr_rm_measure.parent_tids);
                save_measure_and_children ( 0, To_Number(NULL), lr_rm_measure);  --lr_rm_resultType);

                -- to get the all the experiment, AID, assay information outside the loop
                lr_rm_resulttype := lr_rm_measure;

            END LOOP;
            -- now save the contextitems that are not associated with specific result types
            save_exprmt_context_item_set(lr_rm_resulttype);

            -- clean up the display_orders for this assay
            UPDATE assay_context_item aci
            SET display_order =
                (SELECT Count(*)
                FROM assay_context_item aci2
                WHERE aci2.assay_context_id = aci.assay_context_id
                  AND aci2.assay_context_item_id < aci.assay_context_item_id)
            WHERE display_order !=
                  (SELECT Count(*)
                FROM assay_context_item aci2
                WHERE aci2.assay_context_id = aci.assay_context_id
                  AND aci2.assay_context_item_id < aci.assay_context_item_id)
              AND EXISTS ( SELECT 1
                      FROM assay_context ac
                      WHERE ac.assay_context_id = aci.assay_context_id
                        AND ac.assay_id = lr_assay_experiment.assay_id);

            UPDATE assay_context aci
            SET display_order =
                (SELECT Count(*)
                FROM assay_context aci2
                WHERE aci2.assay_id = aci.assay_id
                  AND aci2.assay_context_id < aci.assay_context_id)
            WHERE display_order !=
                  (SELECT Count(*)
                FROM assay_context aci2
                WHERE aci2.assay_id = aci.assay_id
                  AND aci2.assay_context_id < aci.assay_context_id)
              AND aci.assay_id = lr_assay_experiment.assay_id;

            manage_names.update_context_name(lr_rm_resulttype.assay_id);

        END LOOP;


    END transfer_result_map;


    FUNCTION save_context_item_set (ari_resultType  IN  r_resultType)
        RETURN NUMBER
    AS
        CURSOR cur_matching_context
        IS
        SELECT aci.assay_context_id
        FROM temp_context_item tci,
            assay_context_item aci,
            assay_context ac
        WHERE ac.assay_context_id = aci.assay_context_id
          AND ac.assay_id = tci.assay_id
          AND aci.attribute_id = tci.attribute_id
          AND Nvl(aci.value_id, -100) = Nvl(tci.value_id, -100)
          --AND Nvl(aci.value_num, -99999.999) = Nvl(tci.value_num, -99999.999)
          and Decode(aci.value_id, NULL, Nvl(aci.value_display, '######'),'$$$$$$')
                  = Decode(tci.value_id, NULL, Nvl(tci.value1, '######'),'$$$$$$')
        GROUP BY aci.assay_context_id
        HAVING Count(*) = (SELECT Count(*) FRoM temp_context_item)
          AND Count(*) = (SELECT Count(*) FroM assay_context_item aci2
                                          WHERE aci2.assay_context_id = aci.assay_context_id);

        CURSOR cur_temp_context_item
        IS
        SELECT assay_id,
              attribute_id,
              display_order,
              value_num,
              unit,
              value_id,
              ext_value_id,
              value_min,
              value_max,
              aid,
              resultType,
              statsmodifier,
              contextItem,
              value1,
             Decode ((SELECT Count(*)
                     FROM temp_context_item tci2
                     WHERE tci2.contextItem = tci.contextItem),
                     0,'Free',
                     1,Decode(value1, NULL, 'Free', 'Fixed'),
                     'List') attribute_type
        FROM temp_context_item tci
        ORDER BY display_order;

        ln_assay_context_id NUMBER := null;
        ln_assay_context_item_id NUMBER ;

    BEGIN

        -- clean out the temp table
        DELETE FROM temp_context_item;
        -- get the context_item set from the result_map table
        -- AND save IN a TEMPORARY table
        -- need special care to find a set of 'List' type items
            -- look for the attribute without the value
            -- insert items with values with a check to prevent inserting duplicates
            -- note use of assay_ID argument to prevent doubling of item rows
        -- save the items in a temp table
--          Dbms_Output.put_line ('iinsert into temp_context_item '
--        || ', exprt_id=' || ari_resulttype.experiment_id
--        || ', assay_id=' || ari_resulttype.assay_id
--        || ', rt_id=' || ari_resulttype.result_type_id
--        || ', sm_id=' || ari_resulttype.stats_modifier_id
--        || ', aid=' || ari_resulttype.aid
--        || ', resulttype=' || ari_resulttype.resulttype
--        || ', modifier=' || ari_resulttype.stats_modifier
--        || ', relationship=' || ari_resulttype.relationship
--        || ', tid=' || ari_resulttype.tid
--        || ', expseries_no=' || ari_resulttype.series_nos
--        || ', parentTIds=' || ari_resulttype.parent_tids);

        INSERT INTO temp_context_item
            (display_order,
              assay_id,
              attribute_id,
              value_id,
              aid,
              resultType,
              statsmodifier,
              contextItem,
              value1,
              value_num,
              unit)
        SELECT ROWNUM - 1 display_order,
               ci.*
        FROM (SELECT e.assay_id,
                  el_ci.element_id attribute_id,
                  el_val.element_id value_id,
                  rm.aid,
                  rm.resultType,
                  rm.stats_modifier,
                  rm.contextItem,
                  Nvl(rm.value1, Decode(rm.value_num, NULL, NULL, rm.value_num || ' ' || rm.unit)) value1,
                  rm.value_num,
                  rm.unit
              FROM (SELECT rm_rt.aid, rm_rt.resultType, rm_rt.stats_modifier, rm_ci.contextItem, NULL value1, rm_ci.concentration value_num, rm_ci.concentrationunit unit
                    FROM southern.result_map rm_rt,
                        southern.result_map rm_ci
                    WHERE Nvl(rm_ci.contextTID, rm_ci.tid) = rm_rt.tid
                      AND rm_ci.aid = rm_rt.aid
                      AND rm_ci.contextItem != 'do not import'
                      AND rm_rt.resultType = ari_resultType.resultType
                      --AND rm_rt.resultType IS NOT null
                      AND Nvl(rm_rt.stats_modifier, '#####') = Nvl(ari_resultType.stats_modifier, '#####')
                      AND rm_rt.aid = ari_resultType.aid
                    GROUP BY rm_rt.aid, rm_rt.resultType, rm_rt.stats_modifier, rm_ci.contextItem, rm_ci.concentration, rm_ci.concentrationunit
                    UNION all
                    SELECT rm_rt.aid, rm_rt.resultType, rm_rt.stats_modifier, rm_ci.attribute1, rm_ci.value1, null value_num, NULL unit
                    FROM southern.result_map rm_rt,
                        southern.result_map rm_ci
                    WHERE Nvl(rm_ci.contextTID, rm_ci.tid) = rm_rt.tid
                      AND rm_ci.aid = rm_rt.aid
                      AND rm_ci.attribute1 IS NOT null
                      AND rm_rt.resultType = ari_resultType.resultType
                      --AND rm_rt.resultType IS NOT null
                      AND Nvl(rm_rt.stats_modifier, '#####') = Nvl(ari_resultType.stats_modifier, '#####')
                      AND rm_rt.aid = ari_resultType.aid
                    GROUP BY rm_rt.aid, rm_rt.resultType, rm_rt.stats_modifier, rm_ci.attribute1, rm_ci.value1
                    UNION all
                    SELECT rm_rt.aid, rm_rt.resultType, rm_rt.stats_modifier, rm_ci.attribute2, rm_ci.value2, null value_num, NULL unit
                    FROM southern.result_map rm_rt,
                        southern.result_map rm_ci
                    WHERE Nvl(rm_ci.contextTID, rm_ci.tid) = rm_rt.tid
                      AND rm_ci.aid = rm_rt.aid
                      AND rm_ci.attribute2 IS NOT null
                      AND rm_rt.resultType = ari_resultType.resultType
                      --AND rm_rt.resultType IS NOT null
                      AND Nvl(rm_rt.stats_modifier, '#####') = Nvl(ari_resultType.stats_modifier, '#####')  --
                      AND rm_rt.aid = ari_resultType.aid
                    GROUP BY rm_rt.aid, rm_rt.resultType, rm_rt.stats_modifier, rm_ci.attribute2, rm_ci.value2) rm,
                  element el_ci,
                  element el_val,
                  external_reference er,
                  experiment e
              WHERE er.ext_assay_ref = 'aid=' || rm.aid
                AND e.experiment_id = er.experiment_id
                AND e.assay_id = ari_resultType.assay_id
                AND el_ci.label (+) = rm.contextItem
                AND el_val.label (+) = rm.value1
                ORDER BY rm.aid, rm.contextItem, rm.value_num, rm.value1) ci;
--         Dbms_Output.put_line ('inserted '
--              || 'SQL%rowcount=' || SQL%rowcount);

        IF SQL%ROWCOUNT = 0
        THEN return NULL;
            -- nothing got inserted, so we can make a quick exit
        END IF;

        -- query to find an existing matching set
        OPEN cur_matching_context;
--        Dbms_Output.put_line (' opened the matching cursor');
        FETCH cur_matching_context INTO ln_assay_context_id;
--        Dbms_Output.put_line (' fetched the matching cursor');
        CLOSE cur_matching_context;

        IF ln_assay_context_id IS NULL
        THEN
            -- not found create an assay_context
           ln_assay_context_id := get_new_id ('assay_context_id_seq');
--          Dbms_Output.put_line (' got assay_context_id=' || ln_assay_context_id);

            INSERT INTO assay_context
                (assay_context_id,
                 assay_id,
                 context_name,
                 context_group,
                 display_order,
                 modified_by)
            VALUES
                (ln_assay_context_id,
                 ari_resultType.assay_id,
                 'Annotations for ' || ari_resultType.resultType,
                 'Project management> experiment>',
                 0,
                 pv_modified_by);
            -- cycle thru the items saving each as you go
            FOR lr_context_item IN  cur_temp_context_item
            LOOP
                -- check the inputs
                IF lr_context_item.attribute_id IS NULL
                    OR
                    lr_context_item.assay_id is NULL
                THEN
                    -- log the error;
                    log_error (-90002, 'Attribute not in Element', 'save_context_item_set',
                            'resultType=' || lr_context_item.resultType || lr_context_item.statsmodifier
                            || ', Attr_Id='|| To_Char(lr_context_item.attribute_id)
                            || ', contextItem/attribute1=' || lr_context_item.contextItem
                            || ', Assay=' || To_Char(lr_context_item.assay_id)
                            || ', AID='|| To_Char(lr_context_item.aid));
                    CONTINUE;
                END IF;
                IF lr_context_item.value_id IS NULL
                    and lr_context_item.value_num is NULL
                    and lr_context_item.attribute_type != 'Free'
                THEN
                    -- log the error;
                    log_error (-90003, 'WARNING: no value specified', 'save_context_item_set',
                            'resultType=' || lr_context_item.resultType || lr_context_item.statsmodifier
                            || ', Attr_Id='|| To_Char(lr_context_item.attribute_id)
                            || ', attribute=' || lr_context_item.contextItem
                            || ', value_display=' || lr_context_item.value1
                            || ', Assay=' || To_Char(lr_context_item.assay_id)
                            || ', AID='|| To_Char(lr_context_item.aid));
                END IF;
                -- convert the value1 into a number/unit pair if possible
--                Dbms_Output.put_line (' splitting value1=' || lr_context_item.value1);
                IF lr_context_item.value1 IS NOT NULL
                then
                    separate_value_unit (lr_context_item.value1, lr_context_item.value_num, lr_context_item.unit);
                END IF;

                ln_assay_context_item_id := get_new_id ('assay_context_item_id_seq');
                INSERT INTO assay_context_item
                    (assay_context_item_id,
                    assay_context_id,
                    display_order,
                    attribute_type,
                    attribute_id,
                    value_id,
                    value_display,
                    value_num,
                    modified_by)
                VALUES(
                    ln_assay_context_item_id,
                    ln_assay_context_id,
                    lr_context_item.display_order,
                    lr_context_item.attribute_type,
                    lr_context_item.attribute_id,
                    lr_context_item.value_id,
                    Nvl(lr_context_item.value1, Decode(lr_context_item.value_num, NULL, NULL, To_Char(lr_context_item.value_num) || ' ' || lr_context_item.unit)),
                    lr_context_item.value_num,
                    pv_modified_by);

            END LOOP;
        END IF;

        RETURN ln_assay_context_id;

    END save_context_item_set;

    PROCEDURE save_assay_context_measure (ani_assay_context_id IN number,
                               ani_measure_id IN number)
    AS
        ln_assay_context_measure_id NUMBER := null;

        CURSOR cur_assay_context_measure
        IS
        SELECT assay_context_measure_id
        FROM assay_context_measure acm
        WHERE assay_context_id = ani_assay_context_id
          AND measure_id = ani_measure_id;


    BEGIN
        -- try inserting but don't overwrite an existing entry
        open cur_assay_context_measure;
        fetch cur_assay_context_measure INto ln_assay_context_measure_id;
        CLOSE cur_assay_context_measure;

        IF ln_assay_context_measure_id IS NULL
        then
            ln_assay_context_measure_id := get_new_id ('assay_context_measure_id_seq');

            INSERT INTO assay_context_measure
                (assay_context_measure_id,
                assay_context_id,
                measure_id,
                modified_by)
            VALUES (ln_assay_context_measure_id,
                ani_assay_context_id,
                ani_measure_id,
                pv_modified_by);

          END IF;

    END save_assay_context_measure;

    PROCEDURE save_exprmt_measure (ani_experiment_id IN number,
                                ani_measure_id IN number,
                                ani_parent_measure_id IN NUMBER,
                                avi_relationship IN varchar2)
    AS
         CURSOR cur_exprmt_measure
         IS
         SELECT exprmt_measure_id
         FROM exprmt_measure
         WHERE experiment_id = ani_experiment_id
           AND measure_id = ani_parent_measure_id;

        ln_parent_exprmt_measure_id NUMBER := null;
        ln_exprmt_measure_id NUMBER;
        ln_exists           NUMBER := 0;
    BEGIN
        -- cleanup typos in the relationship
--        lv_relationship := Decode (Lower(Trim(avi_relationship)),
--                                  'derives', 'Derived from',
--                                  'child', 'has Child',
--                                  'sibling', 'has Sibling',
--                                  NULL);
        -- discover the ID of the parent exprmt_measure
        -- This works because we are walking down the parentage tree
        OPEN cur_exprmt_measure;
        FETCH cur_exprmt_measure INTO ln_parent_exprmt_measure_id;
        CLOSE cur_exprmt_measure;
        --- doesn't matter if we don't find a parent, cos the measure might not have one!

        -- now insert the exprmt_measure
        SELECT Count(*)  INTO ln_exists
        FROM exprmt_measure
        WHERE experiment_id = ani_experiment_id
          AND measure_id = ani_measure_id
          AND Nvl(parent_exprmt_measure_id, -600) = Nvl(ln_parent_exprmt_measure_id, -600);

        IF ln_exists = 0 OR ln_exists IS null
        THEN
            ln_exprmt_measure_id := get_new_id ('exprmt_measure_id_seq');
            INSERT INTO exprmt_measure
                (exprmt_measure_id,
                parent_exprmt_measure_id,
                parent_child_relationship,
                experiment_id,
                measure_id,
                modified_by)
            VALUES( ln_exprmt_measure_id,
                ln_parent_exprmt_measure_id,
                Decode (Lower(Trim(avi_relationship)),
                                      'derives', 'Derived from',
                                      'child', 'has Child',
                                      'sibling', 'has Sibling'),   -- no default allowed here!!!
                ani_experiment_id,
                ani_measure_id,
                pv_modified_by);

        END IF;
    END save_exprmt_measure;

    PROCEDURE save_measure_and_children (ani_recursion_level  IN binary_integer,
                                         ani_parent_measure_id IN NUMBER,
                                         ari_resulttype IN r_resultType)
    AS
        ln_measure_id       NUMBER;
        le_measure_failed   EXCEPTION;
        ln_assay_context_id NUMBER;
        ln_first_comma_pos  NUMBER;
        lv_parentTID        VARCHAR2(10);
        lr_rm_resultType    r_resultType;
        lt_TIDs             t_string;

    CURSOR cur_rm_measure (cn_aid NUMBER, cv_parentTID VARCHAR2)
        IS
        SELECT e.experiment_id,
              e.assay_id,
              el.element_id result_type_id,
              el_sm.element_id stats_modifier_id,
              rm.aid,
              rm.resulttype,
              rm.stats_modifier,
              rm.relationship,
              rm.tid,
              rm.entry_unit,
              rm.series_nos,
              rm.parent_tids
        FROM (SELECT aid, resulttype, stats_modifier, relationship, tid, Decode(contextitem, NULL, concentrationunit) entry_unit,
            --listagg(relationship, ',') within GROUP (ORDER BY tid) relationship,
            listagg(seriesno, ',') within GROUP (ORDER BY tid) series_nos,
            listagg(parenttid, ',') within GROUP (ORDER BY tid) parent_tids
            FROM southern.result_map
            WHERE aid = cn_aid
              AND resulttype IS NOT NULL
              --AND parenttid IS null
              AND relationship IS NOT null
              AND InStr(',' || parentTID || ',', ',' || cv_parentTID|| ',') > 0
            GROuP BY aid, resulttype, stats_modifier, relationship, tid, Decode(contextitem, NULL, concentrationunit)) rm,
            external_reference er,
            experiment e,
            element el,
            element el_sm
        WHERE er.ext_assay_ref = 'aid=' || rm.aid
          AND e.experiment_id = er.experiment_id
          AND el.label (+) = rm.resulttype
          AND el_sm.label (+) = rm.stats_modifier;


    BEGIN
        -- now the hard work begins
        -- first check the recursion depth
            -- more than 4-6 is a sign of a circular relationship so exit quickly
        -- save the measure
            -- and update it to store the parentage
        -- find and save (if necessary) it's contextItems as set, a context
        -- save the assay_context_measure (ensuring no duplicates)
        -- save the exprmt_measure
            -- with its corresponding parentage
        -- then find the child resultTypes
        -- and call this procedure all over again!
        IF ani_recursion_level > pn_max_recursion_level
        THEN  return; END IF;
--        Dbms_Output.put_line ('inside next recursion '
--              || 'recurse=' || ani_recursion_level
--              || ', prnt_meas=' || ani_parent_measure_id
--              || ', exprt_id=' || ari_resulttype.experiment_id
--              || ', assay_id=' || ari_resulttype.assay_id
--              || ', rt_id=' || ari_resulttype.result_type_id
--              || ', sm_id=' || ari_resulttype.stats_modifier_id
--              || ', aid=' || ari_resulttype.aid
--              || ', resulttype=' || ari_resulttype.resulttype
--              || ', modifier=' || ari_resulttype.stats_modifier
--              || ', relationship=' || ari_resulttype.relationship
--              || ', tid=' || ari_resulttype.tid
--              || ', expseries_no=' || ari_resulttype.series_nos
--              || ', parentTIds=' || ari_resulttype.parent_tids);

        ln_measure_id := save_measure ( ani_parent_measure_id, ari_resultType);
--        Dbms_Output.put_line (' found measure=' || ln_measure_id);

        IF ln_measure_id = -1
        THEN    --- we have an error!
            RAISE le_measure_failed;
        END IF;

        ln_assay_context_id := save_context_item_set(ari_resultType);
--        Dbms_Output.put_line (' saved the context=' || ln_assay_context_id);
       -- if there is an assay_context, link it to the measure
        IF ln_assay_context_id IS NOT NULL
        THEN
            save_assay_context_measure (ln_assay_context_id, ln_measure_id);
        END IF;

        -- assign this measure (with its parentage!) to the experiment
        save_exprmt_measure(ari_resultType.experiment_id,
                            ln_measure_id,
                            ani_parent_measure_id,
                            ari_resultType.relationship);

        --extract the first parentTID from TIDs for this resultType
        FOR lr_rm_measure IN cur_rm_measure(ari_resultType.aid, ari_resultType.TID)
        LOOP
            lr_rm_resultType := lr_rm_measure;
--            Dbms_Output.put_line ('  going to next recursion '
--              || 'recurse=' || To_Char(ani_recursion_level + 1)
--              || ', prnt_meas=' || ln_measure_id
--              || ', exprt_id=' || lr_rm_measure.experiment_id
--              || ', assay_id=' || lr_rm_measure.assay_id
--              || ', rt_id=' || lr_rm_measure.result_type_id
--              || ', sm_id=' || lr_rm_measure.stats_modifier_id
--              || ', aid=' || lr_rm_measure.aid
--              || ', resulttype=' || lr_rm_measure.resulttype
--              || ', modifier=' || lr_rm_measure.stats_modifier
--              || ', relationship=' || lr_rm_measure.relationship
--              || ', tid=' || lr_rm_measure.tid
--              || ', expseries_no=' || lr_rm_measure.series_nos
--              || ', parentTIds=' || lr_rm_measure.parent_tids
--              );

            save_measure_and_children ( ani_recursion_level + 1, ln_measure_id, lr_rm_measure);   --lr_rm_resultType);

        END LOOP;

    EXCEPTION
        WHEN le_measure_failed
        THEN
            log_error (-90001, 'Result Type not in Element', 'Save_measure_and_children',
                    'recursion level=' || ani_recursion_level
                    || 'RT_Id='|| To_Char(ari_resulttype.result_type_id)
                    || ', attribute=' || ari_resultType.resultType
                    || ', Assay=' || To_Char(ari_resultType.assay_id)
                    || ', AID='|| To_Char(ari_resultType.aid));

        WHEN OTHERS
        THEN
            RAISE;

    END save_measure_and_children;

END result_map_util;
/

